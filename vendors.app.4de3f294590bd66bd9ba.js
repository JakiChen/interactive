/*! For license information please see LICENSES */
(window.webpackJsonp = window.webpackJsonp || []).push([
    [23], {
        112: function (t, e, n) {
            "use strict";
            var r = {
                name: "ClientOnly",
                functional: !0,
                props: {
                    placeholder: String,
                    placeholderTag: {
                        type: String,
                        default: "div"
                    }
                },
                render: function (t, e) {
                    var n = e.parent,
                        r = e.slots,
                        o = e.props,
                        c = r(),
                        l = c.default;
                    void 0 === l && (l = []);
                    var h = c.placeholder;
                    return n._isMounted ? l : (n.$once("hook:mounted", (function () {
                        n.$forceUpdate()
                    })), o.placeholderTag && (o.placeholder || h) ? t(o.placeholderTag, {
                        class: ["client-only-placeholder"]
                    }, o.placeholder || h) : l.length > 0 ? l.map((function () {
                        return t(!1)
                    })) : t(!1))
                }
            };
            t.exports = r
        },
        116: function (t, e, n) {
            var r;
            ! function () {
                "use strict";
                var o = .5 * (Math.sqrt(3) - 1),
                    c = (3 - Math.sqrt(3)) / 6,
                    l = 1 / 6,
                    h = (Math.sqrt(5) - 1) / 4,
                    d = (5 - Math.sqrt(5)) / 20;

                function f(t) {
                    var e;
                    e = "function" == typeof t ? t : t ? function () {
                        var t = 0,
                            e = 0,
                            n = 0,
                            r = 1,
                            o = (c = 4022871197, function (data) {
                                data = data.toString();
                                for (var i = 0; i < data.length; i++) {
                                    var t = .02519603282416938 * (c += data.charCodeAt(i));
                                    t -= c = t >>> 0, c = (t *= c) >>> 0, c += 4294967296 * (t -= c)
                                }
                                return 2.3283064365386963e-10 * (c >>> 0)
                            });
                        var c;
                        t = o(" "), e = o(" "), n = o(" ");
                        for (var i = 0; i < arguments.length; i++)(t -= o(arguments[i])) < 0 && (t += 1), (e -= o(arguments[i])) < 0 && (e += 1), (n -= o(arguments[i])) < 0 && (n += 1);
                        return o = null,
                            function () {
                                var o = 2091639 * t + 2.3283064365386963e-10 * r;
                                return t = e, e = n, n = o - (r = 0 | o)
                            }
                    }(t) : Math.random, this.p = m(e), this.perm = new Uint8Array(512), this.permMod12 = new Uint8Array(512);
                    for (var i = 0; i < 512; i++) this.perm[i] = this.p[255 & i], this.permMod12[i] = this.perm[i] % 12
                }

                function m(t) {
                    var i, p = new Uint8Array(256);
                    for (i = 0; i < 256; i++) p[i] = i;
                    for (i = 0; i < 255; i++) {
                        var e = i + ~~(t() * (256 - i)),
                            n = p[i];
                        p[i] = p[e], p[e] = n
                    }
                    return p
                }
                f.prototype = {
                    grad3: new Float32Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1]),
                    grad4: new Float32Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1, -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1, 1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1, -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]),
                    noise2D: function (t, e) {
                        var n, r, l = this.permMod12,
                            h = this.perm,
                            d = this.grad3,
                            f = 0,
                            m = 0,
                            v = 0,
                            s = (t + e) * o,
                            i = Math.floor(t + s),
                            y = Math.floor(e + s),
                            _ = (i + y) * c,
                            x = t - (i - _),
                            w = e - (y - _);
                        x > w ? (n = 1, r = 0) : (n = 0, r = 1);
                        var M = x - n + c,
                            E = w - r + c,
                            T = x - 1 + 2 * c,
                            D = w - 1 + 2 * c,
                            S = 255 & i,
                            A = 255 & y,
                            C = .5 - x * x - w * w;
                        if (C >= 0) {
                            var L = 3 * l[S + h[A]];
                            f = (C *= C) * C * (d[L] * x + d[L + 1] * w)
                        }
                        var R = .5 - M * M - E * E;
                        if (R >= 0) {
                            var P = 3 * l[S + n + h[A + r]];
                            m = (R *= R) * R * (d[P] * M + d[P + 1] * E)
                        }
                        var O = .5 - T * T - D * D;
                        if (O >= 0) {
                            var F = 3 * l[S + 1 + h[A + 1]];
                            v = (O *= O) * O * (d[F] * T + d[F + 1] * D)
                        }
                        return 70 * (f + m + v)
                    },
                    noise3D: function (t, e, n) {
                        var r, o, c, h, d, f, m, v, y, _, x = this.permMod12,
                            w = this.perm,
                            M = this.grad3,
                            s = (t + e + n) * (1 / 3),
                            i = Math.floor(t + s),
                            E = Math.floor(e + s),
                            T = Math.floor(n + s),
                            D = (i + E + T) * l,
                            S = t - (i - D),
                            A = e - (E - D),
                            C = n - (T - D);
                        S >= A ? A >= C ? (d = 1, f = 0, m = 0, v = 1, y = 1, _ = 0) : S >= C ? (d = 1, f = 0, m = 0, v = 1, y = 0, _ = 1) : (d = 0, f = 0, m = 1, v = 1, y = 0, _ = 1) : A < C ? (d = 0, f = 0, m = 1, v = 0, y = 1, _ = 1) : S < C ? (d = 0, f = 1, m = 0, v = 0, y = 1, _ = 1) : (d = 0, f = 1, m = 0, v = 1, y = 1, _ = 0);
                        var L = S - d + l,
                            R = A - f + l,
                            P = C - m + l,
                            O = S - v + 2 * l,
                            F = A - y + 2 * l,
                            N = C - _ + 2 * l,
                            I = S - 1 + .5,
                            B = A - 1 + .5,
                            k = C - 1 + .5,
                            z = 255 & i,
                            U = 255 & E,
                            H = 255 & T,
                            G = .6 - S * S - A * A - C * C;
                        if (G < 0) r = 0;
                        else {
                            var V = 3 * x[z + w[U + w[H]]];
                            r = (G *= G) * G * (M[V] * S + M[V + 1] * A + M[V + 2] * C)
                        }
                        var j = .6 - L * L - R * R - P * P;
                        if (j < 0) o = 0;
                        else {
                            var W = 3 * x[z + d + w[U + f + w[H + m]]];
                            o = (j *= j) * j * (M[W] * L + M[W + 1] * R + M[W + 2] * P)
                        }
                        var Y = .6 - O * O - F * F - N * N;
                        if (Y < 0) c = 0;
                        else {
                            var X = 3 * x[z + v + w[U + y + w[H + _]]];
                            c = (Y *= Y) * Y * (M[X] * O + M[X + 1] * F + M[X + 2] * N)
                        }
                        var Z = .6 - I * I - B * B - k * k;
                        if (Z < 0) h = 0;
                        else {
                            var J = 3 * x[z + 1 + w[U + 1 + w[H + 1]]];
                            h = (Z *= Z) * Z * (M[J] * I + M[J + 1] * B + M[J + 2] * k)
                        }
                        return 32 * (r + o + c + h)
                    },
                    noise4D: function (t, e, n, r) {
                        var o, c, l, f, m, v, y, _, x, w, M, E, T, D, S, A, C, L = this.perm,
                            R = this.grad4,
                            s = (t + e + n + r) * h,
                            i = Math.floor(t + s),
                            P = Math.floor(e + s),
                            O = Math.floor(n + s),
                            F = Math.floor(r + s),
                            N = (i + P + O + F) * d,
                            I = t - (i - N),
                            B = e - (P - N),
                            k = n - (O - N),
                            z = r - (F - N),
                            U = 0,
                            H = 0,
                            G = 0,
                            V = 0;
                        I > B ? U++ : H++, I > k ? U++ : G++, I > z ? U++ : V++, B > k ? H++ : G++, B > z ? H++ : V++, k > z ? G++ : V++;
                        var j = I - (v = U >= 3 ? 1 : 0) + d,
                            W = B - (y = H >= 3 ? 1 : 0) + d,
                            Y = k - (_ = G >= 3 ? 1 : 0) + d,
                            X = z - (x = V >= 3 ? 1 : 0) + d,
                            Z = I - (w = U >= 2 ? 1 : 0) + 2 * d,
                            J = B - (M = H >= 2 ? 1 : 0) + 2 * d,
                            $ = k - (E = G >= 2 ? 1 : 0) + 2 * d,
                            Q = z - (T = V >= 2 ? 1 : 0) + 2 * d,
                            K = I - (D = U >= 1 ? 1 : 0) + 3 * d,
                            tt = B - (S = H >= 1 ? 1 : 0) + 3 * d,
                            et = k - (A = G >= 1 ? 1 : 0) + 3 * d,
                            nt = z - (C = V >= 1 ? 1 : 0) + 3 * d,
                            it = I - 1 + 4 * d,
                            at = B - 1 + 4 * d,
                            ot = k - 1 + 4 * d,
                            st = z - 1 + 4 * d,
                            ut = 255 & i,
                            ct = 255 & P,
                            lt = 255 & O,
                            ht = 255 & F,
                            pt = .6 - I * I - B * B - k * k - z * z;
                        if (pt < 0) o = 0;
                        else {
                            var ft = L[ut + L[ct + L[lt + L[ht]]]] % 32 * 4;
                            o = (pt *= pt) * pt * (R[ft] * I + R[ft + 1] * B + R[ft + 2] * k + R[ft + 3] * z)
                        }
                        var mt = .6 - j * j - W * W - Y * Y - X * X;
                        if (mt < 0) c = 0;
                        else {
                            var gt = L[ut + v + L[ct + y + L[lt + _ + L[ht + x]]]] % 32 * 4;
                            c = (mt *= mt) * mt * (R[gt] * j + R[gt + 1] * W + R[gt + 2] * Y + R[gt + 3] * X)
                        }
                        var vt = .6 - Z * Z - J * J - $ * $ - Q * Q;
                        if (vt < 0) l = 0;
                        else {
                            var yt = L[ut + w + L[ct + M + L[lt + E + L[ht + T]]]] % 32 * 4;
                            l = (vt *= vt) * vt * (R[yt] * Z + R[yt + 1] * J + R[yt + 2] * $ + R[yt + 3] * Q)
                        }
                        var _t = .6 - K * K - tt * tt - et * et - nt * nt;
                        if (_t < 0) f = 0;
                        else {
                            var xt = L[ut + D + L[ct + S + L[lt + A + L[ht + C]]]] % 32 * 4;
                            f = (_t *= _t) * _t * (R[xt] * K + R[xt + 1] * tt + R[xt + 2] * et + R[xt + 3] * nt)
                        }
                        var bt = .6 - it * it - at * at - ot * ot - st * st;
                        if (bt < 0) m = 0;
                        else {
                            var wt = L[ut + 1 + L[ct + 1 + L[lt + 1 + L[ht + 1]]]] % 32 * 4;
                            m = (bt *= bt) * bt * (R[wt] * it + R[wt + 1] * at + R[wt + 2] * ot + R[wt + 3] * st)
                        }
                        return 27 * (o + c + l + f + m)
                    }
                }, f._buildPermutationTable = m, void 0 === (r = function () {
                    return f
                }.call(e, n, e, t)) || (t.exports = r), e.SimplexNoise = f, t.exports = f
            }()
        },
        118: function (t, e, n) {
            "use strict";
            var r = ["style", "currency", "currencyDisplay", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits", "localeMatcher", "formatMatcher", "unit"];

            function o(t, e) {
                "undefined" != typeof console && (console.warn("[vue-i18n] " + t), e && console.warn(e.stack))
            }

            function c(t) {
                return null !== t && "object" == typeof t
            }
            var l = Object.prototype.toString,
                h = "[object Object]";

            function d(t) {
                return l.call(t) === h
            }

            function f(t) {
                return null == t
            }

            function m() {
                for (var t = [], e = arguments.length; e--;) t[e] = arguments[e];
                var n = null,
                    r = null;
                return 1 === t.length ? c(t[0]) || Array.isArray(t[0]) ? r = t[0] : "string" == typeof t[0] && (n = t[0]) : 2 === t.length && ("string" == typeof t[0] && (n = t[0]), (c(t[1]) || Array.isArray(t[1])) && (r = t[1])), {
                    locale: n,
                    params: r
                }
            }

            function v(t) {
                return JSON.parse(JSON.stringify(t))
            }
            var y = Object.prototype.hasOwnProperty;

            function _(t, e) {
                return y.call(t, e)
            }

            function x(t) {
                for (var e = arguments, output = Object(t), i = 1; i < arguments.length; i++) {
                    var source = e[i];
                    if (null != source) {
                        var n = void 0;
                        for (n in source) _(source, n) && (c(source[n]) ? output[n] = x(output[n], source[n]) : output[n] = source[n])
                    }
                }
                return output
            }

            function w(a, b) {
                if (a === b) return !0;
                var t = c(a),
                    e = c(b);
                if (!t || !e) return !t && !e && String(a) === String(b);
                try {
                    var n = Array.isArray(a),
                        r = Array.isArray(b);
                    if (n && r) return a.length === b.length && a.every((function (t, i) {
                        return w(t, b[i])
                    }));
                    if (n || r) return !1;
                    var o = Object.keys(a),
                        l = Object.keys(b);
                    return o.length === l.length && o.every((function (t) {
                        return w(a[t], b[t])
                    }))
                } catch (t) {
                    return !1
                }
            }
            var M = {
                    beforeCreate: function () {
                        var t = this.$options;
                        if (t.i18n = t.i18n || (t.__i18n ? {} : null), t.i18n)
                            if (t.i18n instanceof lt) {
                                if (t.__i18n) try {
                                    var e = {};
                                    t.__i18n.forEach((function (t) {
                                        e = x(e, JSON.parse(t))
                                    })), Object.keys(e).forEach((function (n) {
                                        t.i18n.mergeLocaleMessage(n, e[n])
                                    }))
                                } catch (t) {
                                    0
                                }
                                this._i18n = t.i18n, this._i18nWatcher = this._i18n.watchI18nData()
                            } else if (d(t.i18n)) {
                            if (this.$root && this.$root.$i18n && this.$root.$i18n instanceof lt && (t.i18n.root = this.$root, t.i18n.formatter = this.$root.$i18n.formatter, t.i18n.fallbackLocale = this.$root.$i18n.fallbackLocale, t.i18n.formatFallbackMessages = this.$root.$i18n.formatFallbackMessages, t.i18n.silentTranslationWarn = this.$root.$i18n.silentTranslationWarn, t.i18n.silentFallbackWarn = this.$root.$i18n.silentFallbackWarn, t.i18n.pluralizationRules = this.$root.$i18n.pluralizationRules, t.i18n.preserveDirectiveContent = this.$root.$i18n.preserveDirectiveContent), t.__i18n) try {
                                var n = {};
                                t.__i18n.forEach((function (t) {
                                    n = x(n, JSON.parse(t))
                                })), t.i18n.messages = n
                            } catch (t) {
                                0
                            }
                            var r = t.i18n.sharedMessages;
                            r && d(r) && (t.i18n.messages = x(t.i18n.messages, r)), this._i18n = new lt(t.i18n), this._i18nWatcher = this._i18n.watchI18nData(), (void 0 === t.i18n.sync || t.i18n.sync) && (this._localeWatcher = this.$i18n.watchLocale())
                        } else 0;
                        else this.$root && this.$root.$i18n && this.$root.$i18n instanceof lt ? this._i18n = this.$root.$i18n : t.parent && t.parent.$i18n && t.parent.$i18n instanceof lt && (this._i18n = t.parent.$i18n)
                    },
                    beforeMount: function () {
                        var t = this.$options;
                        t.i18n = t.i18n || (t.__i18n ? {} : null), t.i18n ? t.i18n instanceof lt ? (this._i18n.subscribeDataChanging(this), this._subscribing = !0) : d(t.i18n) && (this._i18n.subscribeDataChanging(this), this._subscribing = !0) : this.$root && this.$root.$i18n && this.$root.$i18n instanceof lt ? (this._i18n.subscribeDataChanging(this), this._subscribing = !0) : t.parent && t.parent.$i18n && t.parent.$i18n instanceof lt && (this._i18n.subscribeDataChanging(this), this._subscribing = !0)
                    },
                    beforeDestroy: function () {
                        if (this._i18n) {
                            var t = this;
                            this.$nextTick((function () {
                                t._subscribing && (t._i18n.unsubscribeDataChanging(t), delete t._subscribing), t._i18nWatcher && (t._i18nWatcher(), t._i18n.destroyVM(), delete t._i18nWatcher), t._localeWatcher && (t._localeWatcher(), delete t._localeWatcher), t._i18n = null
                            }))
                        }
                    }
                },
                E = {
                    name: "i18n",
                    functional: !0,
                    props: {
                        tag: {
                            type: String
                        },
                        path: {
                            type: String,
                            required: !0
                        },
                        locale: {
                            type: String
                        },
                        places: {
                            type: [Array, Object]
                        }
                    },
                    render: function (t, e) {
                        var data = e.data,
                            n = e.parent,
                            r = e.props,
                            o = e.slots,
                            c = n.$i18n;
                        if (c) {
                            var path = r.path,
                                l = r.locale,
                                h = r.places,
                                d = o(),
                                f = c.i(path, l, function (t) {
                                    var e;
                                    for (e in t)
                                        if ("default" !== e) return !1;
                                    return Boolean(e)
                                }(d) || h ? function (t, e) {
                                    var n = e ? function (t) {
                                        0;
                                        return Array.isArray(t) ? t.reduce(D, {}) : Object.assign({}, t)
                                    }(e) : {};
                                    if (!t) return n;
                                    var r = (t = t.filter((function (t) {
                                        return t.tag || "" !== t.text.trim()
                                    }))).every(S);
                                    0;
                                    return t.reduce(r ? T : D, n)
                                }(d.default, h) : d),
                                m = r.tag || "span";
                            return m ? t(m, data, f) : f
                        }
                    }
                };

            function T(t, e) {
                return e.data && e.data.attrs && e.data.attrs.place && (t[e.data.attrs.place] = e), t
            }

            function D(t, e, n) {
                return t[n] = e, t
            }

            function S(t) {
                return Boolean(t.data && t.data.attrs && t.data.attrs.place)
            }
            var A, C = {
                name: "i18n-n",
                functional: !0,
                props: {
                    tag: {
                        type: String,
                        default: "span"
                    },
                    value: {
                        type: Number,
                        required: !0
                    },
                    format: {
                        type: [String, Object]
                    },
                    locale: {
                        type: String
                    }
                },
                render: function (t, e) {
                    var n = e.props,
                        o = e.parent,
                        data = e.data,
                        l = o.$i18n;
                    if (!l) return null;
                    var h = null,
                        d = null;
                    "string" == typeof n.format ? h = n.format : c(n.format) && (n.format.key && (h = n.format.key), d = Object.keys(n.format).reduce((function (t, e) {
                        var o;
                        return r.includes(e) ? Object.assign({}, t, ((o = {})[e] = n.format[e], o)) : t
                    }), null));
                    var f = n.locale || l.locale,
                        m = l._ntp(n.value, f, h, d),
                        v = m.map((function (t, e) {
                            var n, slot = data.scopedSlots && data.scopedSlots[t.type];
                            return slot ? slot(((n = {})[t.type] = t.value, n.index = e, n.parts = m, n)) : t.value
                        }));
                    return t(n.tag, {
                        attrs: data.attrs,
                        class: data.class,
                        staticClass: data.staticClass
                    }, v)
                }
            };

            function L(t, e, n) {
                O(t, n) && F(t, e, n)
            }

            function R(t, e, n, r) {
                if (O(t, n)) {
                    var o = n.context.$i18n;
                    (function (t, e) {
                        var n = e.context;
                        return t._locale === n.$i18n.locale
                    })(t, n) && w(e.value, e.oldValue) && w(t._localeMessage, o.getLocaleMessage(o.locale)) || F(t, e, n)
                }
            }

            function P(t, e, n, r) {
                if (n.context) {
                    var c = n.context.$i18n || {};
                    e.modifiers.preserve || c.preserveDirectiveContent || (t.textContent = ""), t._vt = void 0, delete t._vt, t._locale = void 0, delete t._locale, t._localeMessage = void 0, delete t._localeMessage
                } else o("Vue instance does not exists in VNode context")
            }

            function O(t, e) {
                var n = e.context;
                return n ? !!n.$i18n || (o("VueI18n instance does not exists in Vue instance"), !1) : (o("Vue instance does not exists in VNode context"), !1)
            }

            function F(t, e, n) {
                var r, c, l = function (t) {
                        var path, e, n, r;
                        "string" == typeof t ? path = t : d(t) && (path = t.path, e = t.locale, n = t.args, r = t.choice);
                        return {
                            path: path,
                            locale: e,
                            args: n,
                            choice: r
                        }
                    }(e.value),
                    path = l.path,
                    h = l.locale,
                    f = l.args,
                    m = l.choice;
                if (path || h || f)
                    if (path) {
                        var v = n.context;
                        t._vt = t.textContent = m ? (r = v.$i18n).tc.apply(r, [path, m].concat(N(h, f))) : (c = v.$i18n).t.apply(c, [path].concat(N(h, f))), t._locale = v.$i18n.locale, t._localeMessage = v.$i18n.getLocaleMessage(v.$i18n.locale)
                    } else o("`path` is required in v-t directive");
                else o("value type not supported")
            }

            function N(t, e) {
                var n = [];
                return t && n.push(t), e && (Array.isArray(e) || d(e)) && n.push(e), n
            }

            function I(t) {
                I.installed = !0;
                (A = t).version && Number(A.version.split(".")[0]);
                (function (t) {
                    t.prototype.hasOwnProperty("$i18n") || Object.defineProperty(t.prototype, "$i18n", {
                        get: function () {
                            return this._i18n
                        }
                    }), t.prototype.$t = function (t) {
                        for (var e = [], n = arguments.length - 1; n-- > 0;) e[n] = arguments[n + 1];
                        var r = this.$i18n;
                        return r._t.apply(r, [t, r.locale, r._getMessages(), this].concat(e))
                    }, t.prototype.$tc = function (t, e) {
                        for (var n = [], r = arguments.length - 2; r-- > 0;) n[r] = arguments[r + 2];
                        var o = this.$i18n;
                        return o._tc.apply(o, [t, o.locale, o._getMessages(), this, e].concat(n))
                    }, t.prototype.$te = function (t, e) {
                        var n = this.$i18n;
                        return n._te(t, n.locale, n._getMessages(), e)
                    }, t.prototype.$d = function (t) {
                        for (var e, n = [], r = arguments.length - 1; r-- > 0;) n[r] = arguments[r + 1];
                        return (e = this.$i18n).d.apply(e, [t].concat(n))
                    }, t.prototype.$n = function (t) {
                        for (var e, n = [], r = arguments.length - 1; r-- > 0;) n[r] = arguments[r + 1];
                        return (e = this.$i18n).n.apply(e, [t].concat(n))
                    }
                })(A), A.mixin(M), A.directive("t", {
                    bind: L,
                    update: R,
                    unbind: P
                }), A.component(E.name, E), A.component(C.name, C), A.config.optionMergeStrategies.i18n = function (t, e) {
                    return void 0 === e ? t : e
                }
            }
            var B = function () {
                this._caches = Object.create(null)
            };
            B.prototype.interpolate = function (t, e) {
                if (!e) return [t];
                var n = this._caches[t];
                return n || (n = function (t) {
                        var e = [],
                            n = 0,
                            text = "";
                        for (; n < t.length;) {
                            var r = t[n++];
                            if ("{" === r) {
                                text && e.push({
                                    type: "text",
                                    value: text
                                }), text = "";
                                var sub = "";
                                for (r = t[n++]; void 0 !== r && "}" !== r;) sub += r, r = t[n++];
                                var o = "}" === r,
                                    c = k.test(sub) ? "list" : o && z.test(sub) ? "named" : "unknown";
                                e.push({
                                    value: sub,
                                    type: c
                                })
                            } else "%" === r ? "{" !== t[n] && (text += r) : text += r
                        }
                        return text && e.push({
                            type: "text",
                            value: text
                        }), e
                    }(t), this._caches[t] = n),
                    function (t, e) {
                        var n = [],
                            r = 0,
                            o = Array.isArray(e) ? "list" : c(e) ? "named" : "unknown";
                        if ("unknown" === o) return n;
                        for (; r < t.length;) {
                            var l = t[r];
                            switch (l.type) {
                                case "text":
                                    n.push(l.value);
                                    break;
                                case "list":
                                    n.push(e[parseInt(l.value, 10)]);
                                    break;
                                case "named":
                                    "named" === o && n.push(e[l.value]);
                                    break;
                                case "unknown":
                                    0
                            }
                            r++
                        }
                        return n
                    }(n, e)
            };
            var k = /^(?:\d)+/,
                z = /^(?:\w)+/;
            var U = 0,
                H = 1,
                G = 2,
                V = 3,
                j = 0,
                W = 4,
                Y = 5,
                X = 6,
                Z = 7,
                J = 8,
                $ = [];
            $[j] = {
                ws: [j],
                ident: [3, U],
                "[": [W],
                eof: [Z]
            }, $[1] = {
                ws: [1],
                ".": [2],
                "[": [W],
                eof: [Z]
            }, $[2] = {
                ws: [2],
                ident: [3, U],
                0: [3, U],
                number: [3, U]
            }, $[3] = {
                ident: [3, U],
                0: [3, U],
                number: [3, U],
                ws: [1, H],
                ".": [2, H],
                "[": [W, H],
                eof: [Z, H]
            }, $[W] = {
                "'": [Y, U],
                '"': [X, U],
                "[": [W, G],
                "]": [1, V],
                eof: J,
                else: [W, U]
            }, $[Y] = {
                "'": [W, U],
                eof: J,
                else: [Y, U]
            }, $[X] = {
                '"': [W, U],
                eof: J,
                else: [X, U]
            };
            var Q = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;

            function K(t) {
                if (null == t) return "eof";
                switch (t.charCodeAt(0)) {
                    case 91:
                    case 93:
                    case 46:
                    case 34:
                    case 39:
                        return t;
                    case 95:
                    case 36:
                    case 45:
                        return "ident";
                    case 9:
                    case 10:
                    case 13:
                    case 160:
                    case 65279:
                    case 8232:
                    case 8233:
                        return "ws"
                }
                return "ident"
            }

            function tt(path) {
                var t, a, e, n = path.trim();
                return ("0" !== path.charAt(0) || !isNaN(path)) && (e = n, Q.test(e) ? (a = (t = n).charCodeAt(0)) !== t.charCodeAt(t.length - 1) || 34 !== a && 39 !== a ? t : t.slice(1, -1) : "*" + n)
            }
            var et = function () {
                this._cache = Object.create(null)
            };
            et.prototype.parsePath = function (path) {
                var t = this._cache[path];
                return t || (t = function (path) {
                    var t, e, n, r, o, c, l, h = [],
                        d = -1,
                        f = j,
                        m = 0,
                        v = [];

                    function y() {
                        var t = path[d + 1];
                        if (f === Y && "'" === t || f === X && '"' === t) return d++, n = "\\" + t, v[U](), !0
                    }
                    for (v[H] = function () {
                            void 0 !== e && (h.push(e), e = void 0)
                        }, v[U] = function () {
                            void 0 === e ? e = n : e += n
                        }, v[G] = function () {
                            v[U](), m++
                        }, v[V] = function () {
                            if (m > 0) m--, f = W, v[U]();
                            else {
                                if (m = 0, void 0 === e) return !1;
                                if (!1 === (e = tt(e))) return !1;
                                v[H]()
                            }
                        }; null !== f;)
                        if (d++, "\\" !== (t = path[d]) || !y()) {
                            if (r = K(t), (o = (l = $[f])[r] || l.else || J) === J) return;
                            if (f = o[0], (c = v[o[1]]) && (n = void 0 === (n = o[2]) ? t : n, !1 === c())) return;
                            if (f === Z) return h
                        }
                }(path)) && (this._cache[path] = t), t || []
            }, et.prototype.getPathValue = function (t, path) {
                if (!c(t)) return null;
                var e = this.parsePath(path);
                if (0 === e.length) return null;
                for (var n = e.length, r = t, i = 0; i < n;) {
                    var o = r[e[i]];
                    if (void 0 === o) return null;
                    r = o, i++
                }
                return r
            };
            var nt, it = /<\/?[\w\s="/.':;#-\/]+>/,
                at = /(?:@(?:\.[a-z]+)?:(?:[\w\-_|.]+|\([\w\-_|.]+\)))/g,
                ot = /^@(?:\.([a-z]+))?:/,
                st = /[()]/g,
                ut = {
                    upper: function (t) {
                        return t.toLocaleUpperCase()
                    },
                    lower: function (t) {
                        return t.toLocaleLowerCase()
                    }
                },
                ct = new B,
                lt = function (t) {
                    var e = this;
                    void 0 === t && (t = {}), !A && "undefined" != typeof window && window.Vue && I(window.Vue);
                    var n = t.locale || "en-US",
                        r = t.fallbackLocale || "en-US",
                        o = t.messages || {},
                        c = t.dateTimeFormats || {},
                        l = t.numberFormats || {};
                    this._vm = null, this._formatter = t.formatter || ct, this._modifiers = t.modifiers || {}, this._missing = t.missing || null, this._root = t.root || null, this._sync = void 0 === t.sync || !!t.sync, this._fallbackRoot = void 0 === t.fallbackRoot || !!t.fallbackRoot, this._formatFallbackMessages = void 0 !== t.formatFallbackMessages && !!t.formatFallbackMessages, this._silentTranslationWarn = void 0 !== t.silentTranslationWarn && t.silentTranslationWarn, this._silentFallbackWarn = void 0 !== t.silentFallbackWarn && !!t.silentFallbackWarn, this._dateTimeFormatters = {}, this._numberFormatters = {}, this._path = new et, this._dataListeners = [], this._preserveDirectiveContent = void 0 !== t.preserveDirectiveContent && !!t.preserveDirectiveContent, this.pluralizationRules = t.pluralizationRules || {}, this._warnHtmlInMessage = t.warnHtmlInMessage || "off", this._exist = function (t, n) {
                        return !(!t || !n) && (!f(e._path.getPathValue(t, n)) || !!t[n])
                    }, "warn" !== this._warnHtmlInMessage && "error" !== this._warnHtmlInMessage || Object.keys(o).forEach((function (t) {
                        e._checkLocaleMessage(t, e._warnHtmlInMessage, o[t])
                    })), this._initVM({
                        locale: n,
                        fallbackLocale: r,
                        messages: o,
                        dateTimeFormats: c,
                        numberFormats: l
                    })
                },
                ht = {
                    vm: {
                        configurable: !0
                    },
                    messages: {
                        configurable: !0
                    },
                    dateTimeFormats: {
                        configurable: !0
                    },
                    numberFormats: {
                        configurable: !0
                    },
                    availableLocales: {
                        configurable: !0
                    },
                    locale: {
                        configurable: !0
                    },
                    fallbackLocale: {
                        configurable: !0
                    },
                    formatFallbackMessages: {
                        configurable: !0
                    },
                    missing: {
                        configurable: !0
                    },
                    formatter: {
                        configurable: !0
                    },
                    silentTranslationWarn: {
                        configurable: !0
                    },
                    silentFallbackWarn: {
                        configurable: !0
                    },
                    preserveDirectiveContent: {
                        configurable: !0
                    },
                    warnHtmlInMessage: {
                        configurable: !0
                    }
                };
            lt.prototype._checkLocaleMessage = function (t, e, n) {
                var r = function (t, e, n, c) {
                    if (d(n)) Object.keys(n).forEach((function (o) {
                        var l = n[o];
                        d(l) ? (c.push(o), c.push("."), r(t, e, l, c), c.pop(), c.pop()) : (c.push(o), r(t, e, l, c), c.pop())
                    }));
                    else if (Array.isArray(n)) n.forEach((function (n, o) {
                        d(n) ? (c.push("[" + o + "]"), c.push("."), r(t, e, n, c), c.pop(), c.pop()) : (c.push("[" + o + "]"), r(t, e, n, c), c.pop())
                    }));
                    else if ("string" == typeof n) {
                        if (it.test(n)) {
                            var l = "Detected HTML in message '" + n + "' of keypath '" + c.join("") + "' at '" + e + "'. Consider component interpolation with '<i18n>' to avoid XSS. See https://bit.ly/2ZqJzkp";
                            "warn" === t ? o(l) : "error" === t && function (t, e) {
                                "undefined" != typeof console && (console.error("[vue-i18n] " + t), e && console.error(e.stack))
                            }(l)
                        }
                    }
                };
                r(e, t, n, [])
            }, lt.prototype._initVM = function (data) {
                var t = A.config.silent;
                A.config.silent = !0, this._vm = new A({
                    data: data
                }), A.config.silent = t
            }, lt.prototype.destroyVM = function () {
                this._vm.$destroy()
            }, lt.prototype.subscribeDataChanging = function (t) {
                this._dataListeners.push(t)
            }, lt.prototype.unsubscribeDataChanging = function (t) {
                ! function (t, e) {
                    if (t.length) {
                        var n = t.indexOf(e);
                        if (n > -1) t.splice(n, 1)
                    }
                }(this._dataListeners, t)
            }, lt.prototype.watchI18nData = function () {
                var t = this;
                return this._vm.$watch("$data", (function () {
                    for (var i = t._dataListeners.length; i--;) A.nextTick((function () {
                        t._dataListeners[i] && t._dataListeners[i].$forceUpdate()
                    }))
                }), {
                    deep: !0
                })
            }, lt.prototype.watchLocale = function () {
                if (!this._sync || !this._root) return null;
                var t = this._vm;
                return this._root.$i18n.vm.$watch("locale", (function (e) {
                    t.$set(t, "locale", e), t.$forceUpdate()
                }), {
                    immediate: !0
                })
            }, ht.vm.get = function () {
                return this._vm
            }, ht.messages.get = function () {
                return v(this._getMessages())
            }, ht.dateTimeFormats.get = function () {
                return v(this._getDateTimeFormats())
            }, ht.numberFormats.get = function () {
                return v(this._getNumberFormats())
            }, ht.availableLocales.get = function () {
                return Object.keys(this.messages).sort()
            }, ht.locale.get = function () {
                return this._vm.locale
            }, ht.locale.set = function (t) {
                this._vm.$set(this._vm, "locale", t)
            }, ht.fallbackLocale.get = function () {
                return this._vm.fallbackLocale
            }, ht.fallbackLocale.set = function (t) {
                this._vm.$set(this._vm, "fallbackLocale", t)
            }, ht.formatFallbackMessages.get = function () {
                return this._formatFallbackMessages
            }, ht.formatFallbackMessages.set = function (t) {
                this._formatFallbackMessages = t
            }, ht.missing.get = function () {
                return this._missing
            }, ht.missing.set = function (t) {
                this._missing = t
            }, ht.formatter.get = function () {
                return this._formatter
            }, ht.formatter.set = function (t) {
                this._formatter = t
            }, ht.silentTranslationWarn.get = function () {
                return this._silentTranslationWarn
            }, ht.silentTranslationWarn.set = function (t) {
                this._silentTranslationWarn = t
            }, ht.silentFallbackWarn.get = function () {
                return this._silentFallbackWarn
            }, ht.silentFallbackWarn.set = function (t) {
                this._silentFallbackWarn = t
            }, ht.preserveDirectiveContent.get = function () {
                return this._preserveDirectiveContent
            }, ht.preserveDirectiveContent.set = function (t) {
                this._preserveDirectiveContent = t
            }, ht.warnHtmlInMessage.get = function () {
                return this._warnHtmlInMessage
            }, ht.warnHtmlInMessage.set = function (t) {
                var e = this,
                    n = this._warnHtmlInMessage;
                if (this._warnHtmlInMessage = t, n !== t && ("warn" === t || "error" === t)) {
                    var r = this._getMessages();
                    Object.keys(r).forEach((function (t) {
                        e._checkLocaleMessage(t, e._warnHtmlInMessage, r[t])
                    }))
                }
            }, lt.prototype._getMessages = function () {
                return this._vm.messages
            }, lt.prototype._getDateTimeFormats = function () {
                return this._vm.dateTimeFormats
            }, lt.prototype._getNumberFormats = function () {
                return this._vm.numberFormats
            }, lt.prototype._warnDefault = function (t, e, n, r, o) {
                if (!f(n)) return n;
                if (this._missing) {
                    var c = this._missing.apply(null, [t, e, r, o]);
                    if ("string" == typeof c) return c
                } else 0;
                if (this._formatFallbackMessages) {
                    var l = m.apply(void 0, o);
                    return this._render(e, "string", l.params, e)
                }
                return e
            }, lt.prototype._isFallbackRoot = function (t) {
                return !t && !f(this._root) && this._fallbackRoot
            }, lt.prototype._isSilentFallbackWarn = function (t) {
                return this._silentFallbackWarn instanceof RegExp ? this._silentFallbackWarn.test(t) : this._silentFallbackWarn
            }, lt.prototype._isSilentFallback = function (t, e) {
                return this._isSilentFallbackWarn(e) && (this._isFallbackRoot() || t !== this.fallbackLocale)
            }, lt.prototype._isSilentTranslationWarn = function (t) {
                return this._silentTranslationWarn instanceof RegExp ? this._silentTranslationWarn.test(t) : this._silentTranslationWarn
            }, lt.prototype._interpolate = function (t, e, n, r, o, c, l) {
                if (!e) return null;
                var h, m = this._path.getPathValue(e, n);
                if (Array.isArray(m) || d(m)) return m;
                if (f(m)) {
                    if (!d(e)) return null;
                    if ("string" != typeof (h = e[n])) return null
                } else {
                    if ("string" != typeof m) return null;
                    h = m
                }
                return (h.indexOf("@:") >= 0 || h.indexOf("@.") >= 0) && (h = this._link(t, e, h, r, "raw", c, l)), this._render(h, o, c, n)
            }, lt.prototype._link = function (t, e, n, r, o, c, l) {
                var h = n,
                    d = h.match(at);
                for (var f in d)
                    if (d.hasOwnProperty(f)) {
                        var link = d[f],
                            m = link.match(ot),
                            v = m[0],
                            y = m[1],
                            _ = link.replace(v, "").replace(st, "");
                        if (l.includes(_)) return h;
                        l.push(_);
                        var x = this._interpolate(t, e, _, r, "raw" === o ? "string" : o, "raw" === o ? void 0 : c, l);
                        if (this._isFallbackRoot(x)) {
                            if (!this._root) throw Error("unexpected error");
                            var w = this._root.$i18n;
                            x = w._translate(w._getMessages(), w.locale, w.fallbackLocale, _, r, o, c)
                        }
                        x = this._warnDefault(t, _, x, r, Array.isArray(c) ? c : [c]), this._modifiers.hasOwnProperty(y) ? x = this._modifiers[y](x) : ut.hasOwnProperty(y) && (x = ut[y](x)), l.pop(), h = x ? h.replace(link, x) : h
                    } return h
            }, lt.prototype._render = function (t, e, n, path) {
                var r = this._formatter.interpolate(t, n, path);
                return r || (r = ct.interpolate(t, n, path)), "string" === e ? r.join("") : r
            }, lt.prototype._translate = function (t, e, n, r, o, c, l) {
                var h = this._interpolate(e, t[e], r, o, c, l, [r]);
                return f(h) && f(h = this._interpolate(n, t[n], r, o, c, l, [r])) ? null : h
            }, lt.prototype._t = function (t, e, n, r) {
                for (var o, c = [], l = arguments.length - 4; l-- > 0;) c[l] = arguments[l + 4];
                if (!t) return "";
                var h = m.apply(void 0, c),
                    d = h.locale || e,
                    f = this._translate(n, d, this.fallbackLocale, t, r, "string", h.params);
                if (this._isFallbackRoot(f)) {
                    if (!this._root) throw Error("unexpected error");
                    return (o = this._root).$t.apply(o, [t].concat(c))
                }
                return this._warnDefault(d, t, f, r, c)
            }, lt.prototype.t = function (t) {
                for (var e, n = [], r = arguments.length - 1; r-- > 0;) n[r] = arguments[r + 1];
                return (e = this)._t.apply(e, [t, this.locale, this._getMessages(), null].concat(n))
            }, lt.prototype._i = function (t, e, n, r, o) {
                var c = this._translate(n, e, this.fallbackLocale, t, r, "raw", o);
                if (this._isFallbackRoot(c)) {
                    if (!this._root) throw Error("unexpected error");
                    return this._root.$i18n.i(t, e, o)
                }
                return this._warnDefault(e, t, c, r, [o])
            }, lt.prototype.i = function (t, e, n) {
                return t ? ("string" != typeof e && (e = this.locale), this._i(t, e, this._getMessages(), null, n)) : ""
            }, lt.prototype._tc = function (t, e, n, r, o) {
                for (var c, l = [], h = arguments.length - 5; h-- > 0;) l[h] = arguments[h + 5];
                if (!t) return "";
                void 0 === o && (o = 1);
                var d = {
                        count: o,
                        n: o
                    },
                    f = m.apply(void 0, l);
                return f.params = Object.assign(d, f.params), l = null === f.locale ? [f.params] : [f.locale, f.params], this.fetchChoice((c = this)._t.apply(c, [t, e, n, r].concat(l)), o)
            }, lt.prototype.fetchChoice = function (t, e) {
                if (!t && "string" != typeof t) return null;
                var n = t.split("|");
                return n[e = this.getChoiceIndex(e, n.length)] ? n[e].trim() : t
            }, lt.prototype.getChoiceIndex = function (t, e) {
                var n, r;
                return this.locale in this.pluralizationRules ? this.pluralizationRules[this.locale].apply(this, [t, e]) : (n = t, r = e, n = Math.abs(n), 2 === r ? n ? n > 1 ? 1 : 0 : 1 : n ? Math.min(n, 2) : 0)
            }, lt.prototype.tc = function (t, e) {
                for (var n, r = [], o = arguments.length - 2; o-- > 0;) r[o] = arguments[o + 2];
                return (n = this)._tc.apply(n, [t, this.locale, this._getMessages(), null, e].concat(r))
            }, lt.prototype._te = function (t, e, n) {
                for (var r = [], o = arguments.length - 3; o-- > 0;) r[o] = arguments[o + 3];
                var c = m.apply(void 0, r).locale || e;
                return this._exist(n[c], t)
            }, lt.prototype.te = function (t, e) {
                return this._te(t, this.locale, this._getMessages(), e)
            }, lt.prototype.getLocaleMessage = function (t) {
                return v(this._vm.messages[t] || {})
            }, lt.prototype.setLocaleMessage = function (t, e) {
                ("warn" !== this._warnHtmlInMessage && "error" !== this._warnHtmlInMessage || (this._checkLocaleMessage(t, this._warnHtmlInMessage, e), "error" !== this._warnHtmlInMessage)) && this._vm.$set(this._vm.messages, t, e)
            }, lt.prototype.mergeLocaleMessage = function (t, e) {
                ("warn" !== this._warnHtmlInMessage && "error" !== this._warnHtmlInMessage || (this._checkLocaleMessage(t, this._warnHtmlInMessage, e), "error" !== this._warnHtmlInMessage)) && this._vm.$set(this._vm.messages, t, x({}, this._vm.messages[t] || {}, e))
            }, lt.prototype.getDateTimeFormat = function (t) {
                return v(this._vm.dateTimeFormats[t] || {})
            }, lt.prototype.setDateTimeFormat = function (t, e) {
                this._vm.$set(this._vm.dateTimeFormats, t, e)
            }, lt.prototype.mergeDateTimeFormat = function (t, e) {
                this._vm.$set(this._vm.dateTimeFormats, t, x(this._vm.dateTimeFormats[t] || {}, e))
            }, lt.prototype._localizeDateTime = function (t, e, n, r, o) {
                var c = e,
                    l = r[c];
                if ((f(l) || f(l[o])) && (l = r[c = n]), f(l) || f(l[o])) return null;
                var h = l[o],
                    d = c + "__" + o,
                    m = this._dateTimeFormatters[d];
                return m || (m = this._dateTimeFormatters[d] = new Intl.DateTimeFormat(c, h)), m.format(t)
            }, lt.prototype._d = function (t, e, n) {
                if (!n) return new Intl.DateTimeFormat(e).format(t);
                var r = this._localizeDateTime(t, e, this.fallbackLocale, this._getDateTimeFormats(), n);
                if (this._isFallbackRoot(r)) {
                    if (!this._root) throw Error("unexpected error");
                    return this._root.$i18n.d(t, n, e)
                }
                return r || ""
            }, lt.prototype.d = function (t) {
                for (var e = [], n = arguments.length - 1; n-- > 0;) e[n] = arguments[n + 1];
                var r = this.locale,
                    o = null;
                return 1 === e.length ? "string" == typeof e[0] ? o = e[0] : c(e[0]) && (e[0].locale && (r = e[0].locale), e[0].key && (o = e[0].key)) : 2 === e.length && ("string" == typeof e[0] && (o = e[0]), "string" == typeof e[1] && (r = e[1])), this._d(t, r, o)
            }, lt.prototype.getNumberFormat = function (t) {
                return v(this._vm.numberFormats[t] || {})
            }, lt.prototype.setNumberFormat = function (t, e) {
                this._vm.$set(this._vm.numberFormats, t, e)
            }, lt.prototype.mergeNumberFormat = function (t, e) {
                this._vm.$set(this._vm.numberFormats, t, x(this._vm.numberFormats[t] || {}, e))
            }, lt.prototype._getNumberFormatter = function (t, e, n, r, o, c) {
                var l = e,
                    h = r[l];
                if ((f(h) || f(h[o])) && (h = r[l = n]), f(h) || f(h[o])) return null;
                var d, m = h[o];
                if (c) d = new Intl.NumberFormat(l, Object.assign({}, m, c));
                else {
                    var v = l + "__" + o;
                    (d = this._numberFormatters[v]) || (d = this._numberFormatters[v] = new Intl.NumberFormat(l, m))
                }
                return d
            }, lt.prototype._n = function (t, e, n, r) {
                if (!lt.availabilities.numberFormat) return "";
                if (!n) return (r ? new Intl.NumberFormat(e, r) : new Intl.NumberFormat(e)).format(t);
                var o = this._getNumberFormatter(t, e, this.fallbackLocale, this._getNumberFormats(), n, r),
                    c = o && o.format(t);
                if (this._isFallbackRoot(c)) {
                    if (!this._root) throw Error("unexpected error");
                    return this._root.$i18n.n(t, Object.assign({}, {
                        key: n,
                        locale: e
                    }, r))
                }
                return c || ""
            }, lt.prototype.n = function (t) {
                for (var e = [], n = arguments.length - 1; n-- > 0;) e[n] = arguments[n + 1];
                var o = this.locale,
                    l = null,
                    h = null;
                return 1 === e.length ? "string" == typeof e[0] ? l = e[0] : c(e[0]) && (e[0].locale && (o = e[0].locale), e[0].key && (l = e[0].key), h = Object.keys(e[0]).reduce((function (t, n) {
                    var o;
                    return r.includes(n) ? Object.assign({}, t, ((o = {})[n] = e[0][n], o)) : t
                }), null)) : 2 === e.length && ("string" == typeof e[0] && (l = e[0]), "string" == typeof e[1] && (o = e[1])), this._n(t, o, l, h)
            }, lt.prototype._ntp = function (t, e, n, r) {
                if (!lt.availabilities.numberFormat) return [];
                if (!n) return (r ? new Intl.NumberFormat(e, r) : new Intl.NumberFormat(e)).formatToParts(t);
                var o = this._getNumberFormatter(t, e, this.fallbackLocale, this._getNumberFormats(), n, r),
                    c = o && o.formatToParts(t);
                if (this._isFallbackRoot(c)) {
                    if (!this._root) throw Error("unexpected error");
                    return this._root.$i18n._ntp(t, e, n, r)
                }
                return c || []
            }, Object.defineProperties(lt.prototype, ht), Object.defineProperty(lt, "availabilities", {
                get: function () {
                    if (!nt) {
                        var t = "undefined" != typeof Intl;
                        nt = {
                            dateTimeFormat: t && void 0 !== Intl.DateTimeFormat,
                            numberFormat: t && void 0 !== Intl.NumberFormat
                        }
                    }
                    return nt
                }
            }), lt.install = I, lt.version = "8.15.3", e.a = lt
        },
        12: function (t, e, n) {
            "use strict";
            t.exports = function (t) {
                var e = [];
                return e.toString = function () {
                    return this.map((function (e) {
                        var content = function (t, e) {
                            var content = t[1] || "",
                                n = t[3];
                            if (!n) return content;
                            if (e && "function" == typeof btoa) {
                                var r = (c = n, l = btoa(unescape(encodeURIComponent(JSON.stringify(c)))), data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(l), "/*# ".concat(data, " */")),
                                    o = n.sources.map((function (source) {
                                        return "/*# sourceURL=".concat(n.sourceRoot).concat(source, " */")
                                    }));
                                return [content].concat(o).concat([r]).join("\n")
                            }
                            var c, l, data;
                            return [content].join("\n")
                        }(e, t);
                        return e[2] ? "@media ".concat(e[2], " {").concat(content, "}") : content
                    })).join("")
                }, e.i = function (t, n) {
                    "string" == typeof t && (t = [
                        [null, t, ""]
                    ]);
                    for (var i = 0; i < t.length; i++) {
                        var r = [].concat(t[i]);
                        n && (r[2] ? r[2] = "".concat(n, " and ").concat(r[2]) : r[2] = n), e.push(r)
                    }
                }, e
            }
        },
        13: function (t, e, n) {
            "use strict";

            function r(t, e) {
                for (var n = [], r = {}, i = 0; i < e.length; i++) {
                    var o = e[i],
                        c = o[0],
                        l = {
                            id: t + ":" + i,
                            css: o[1],
                            media: o[2],
                            sourceMap: o[3]
                        };
                    r[c] ? r[c].parts.push(l) : n.push(r[c] = {
                        id: c,
                        parts: [l]
                    })
                }
                return n
            }
            n.r(e), n.d(e, "default", (function () {
                return _
            }));
            var o = "undefined" != typeof document;
            if ("undefined" != typeof DEBUG && DEBUG && !o) throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");
            var c = {},
                head = o && (document.head || document.getElementsByTagName("head")[0]),
                l = null,
                h = 0,
                d = !1,
                f = function () {},
                m = null,
                v = "data-vue-ssr-id",
                y = "undefined" != typeof navigator && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase());

            function _(t, e, n, o) {
                d = n, m = o || {};
                var l = r(t, e);
                return x(l),
                    function (e) {
                        for (var n = [], i = 0; i < l.length; i++) {
                            var o = l[i];
                            (h = c[o.id]).refs--, n.push(h)
                        }
                        e ? x(l = r(t, e)) : l = [];
                        for (i = 0; i < n.length; i++) {
                            var h;
                            if (0 === (h = n[i]).refs) {
                                for (var d = 0; d < h.parts.length; d++) h.parts[d]();
                                delete c[h.id]
                            }
                        }
                    }
            }

            function x(t) {
                for (var i = 0; i < t.length; i++) {
                    var e = t[i],
                        n = c[e.id];
                    if (n) {
                        n.refs++;
                        for (var r = 0; r < n.parts.length; r++) n.parts[r](e.parts[r]);
                        for (; r < e.parts.length; r++) n.parts.push(M(e.parts[r]));
                        n.parts.length > e.parts.length && (n.parts.length = e.parts.length)
                    } else {
                        var o = [];
                        for (r = 0; r < e.parts.length; r++) o.push(M(e.parts[r]));
                        c[e.id] = {
                            id: e.id,
                            refs: 1,
                            parts: o
                        }
                    }
                }
            }

            function w() {
                var t = document.createElement("style");
                return t.type = "text/css", head.appendChild(t), t
            }

            function M(t) {
                var e, n, r = document.querySelector("style[" + v + '~="' + t.id + '"]');
                if (r) {
                    if (d) return f;
                    r.parentNode.removeChild(r)
                }
                if (y) {
                    var o = h++;
                    r = l || (l = w()), e = D.bind(null, r, o, !1), n = D.bind(null, r, o, !0)
                } else r = w(), e = S.bind(null, r), n = function () {
                    r.parentNode.removeChild(r)
                };
                return e(t),
                    function (r) {
                        if (r) {
                            if (r.css === t.css && r.media === t.media && r.sourceMap === t.sourceMap) return;
                            e(t = r)
                        } else n()
                    }
            }
            var E, T = (E = [], function (t, e) {
                return E[t] = e, E.filter(Boolean).join("\n")
            });

            function D(t, e, n, r) {
                var o = n ? "" : r.css;
                if (t.styleSheet) t.styleSheet.cssText = T(e, o);
                else {
                    var c = document.createTextNode(o),
                        l = t.childNodes;
                    l[e] && t.removeChild(l[e]), l.length ? t.insertBefore(c, l[e]) : t.appendChild(c)
                }
            }

            function S(t, e) {
                var n = e.css,
                    r = e.media,
                    o = e.sourceMap;
                if (r && t.setAttribute("media", r), m.ssrId && t.setAttribute(v, e.id), o && (n += "\n/*# sourceURL=" + o.sources[0] + " */", n += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(o)))) + " */"), t.styleSheet) t.styleSheet.cssText = n;
                else {
                    for (; t.firstChild;) t.removeChild(t.firstChild);
                    t.appendChild(document.createTextNode(n))
                }
            }
        },
        148: function (t, e, n) {
            ! function (t) {
                function e() {}

                function n(a, b) {
                    this.x = a || 0, this.y = b || 0
                }

                function r(a, b, t, e) {
                    this._x = a || 0, this._y = b || 0, this._z = t || 0, this._w = void 0 !== e ? e : 1
                }

                function o(a, b, t) {
                    this.x = a || 0, this.y = b || 0, this.z = t || 0
                }

                function c() {
                    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
                }

                function l(a, b, t, e, r, o, g, h, d, f) {
                    Object.defineProperty(this, "id", {
                        value: Za++
                    }), this.uuid = Va.generateUUID(), this.name = "", this.image = void 0 !== a ? a : l.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== b ? b : l.DEFAULT_MAPPING, this.wrapS = void 0 !== t ? t : 1001, this.wrapT = void 0 !== e ? e : 1001, this.magFilter = void 0 !== r ? r : 1006, this.minFilter = void 0 !== o ? o : 1008, this.anisotropy = void 0 !== d ? d : 1, this.format = void 0 !== g ? g : 1023, this.internalFormat = null, this.type = void 0 !== h ? h : 1009, this.offset = new n(0, 0), this.repeat = new n(1, 1), this.center = new n(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new c, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== f ? f : 3e3, this.version = 0, this.onUpdate = null
                }

                function h(a, b, t, e) {
                    this.x = a || 0, this.y = b || 0, this.z = t || 0, this.w = void 0 !== e ? e : 1
                }

                function d(a, b, t) {
                    this.width = a, this.height = b, this.scissor = new h(0, 0, a, b), this.scissorTest = !1, this.viewport = new h(0, 0, a, b), t = t || {}, this.texture = new l(void 0, void 0, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.image = {}, this.texture.image.width = a, this.texture.image.height = b, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : 1006, this.depthBuffer = void 0 === t.depthBuffer || t.depthBuffer, this.stencilBuffer = void 0 === t.stencilBuffer || t.stencilBuffer, this.depthTexture = void 0 !== t.depthTexture ? t.depthTexture : null
                }

                function f(a, b, t) {
                    d.call(this, a, b, t), this.samples = 4
                }

                function m() {
                    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
                }

                function v(a, b, t, e) {
                    this._x = a || 0, this._y = b || 0, this._z = t || 0, this._order = e || v.DefaultOrder
                }

                function y() {
                    this.mask = 1
                }

                function _() {
                    Object.defineProperty(this, "id", {
                        value: ao++
                    }), this.uuid = Va.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = _.DefaultUp.clone();
                    var a = new o,
                        b = new v,
                        t = new r,
                        e = new o(1, 1, 1);
                    b._onChange((function () {
                        t.setFromEuler(b, !1)
                    })), t._onChange((function () {
                        b.setFromQuaternion(t, void 0, !1)
                    })), Object.defineProperties(this, {
                        position: {
                            configurable: !0,
                            enumerable: !0,
                            value: a
                        },
                        rotation: {
                            configurable: !0,
                            enumerable: !0,
                            value: b
                        },
                        quaternion: {
                            configurable: !0,
                            enumerable: !0,
                            value: t
                        },
                        scale: {
                            configurable: !0,
                            enumerable: !0,
                            value: e
                        },
                        modelViewMatrix: {
                            value: new m
                        },
                        normalMatrix: {
                            value: new c
                        }
                    }), this.matrix = new m, this.matrixWorld = new m, this.matrixAutoUpdate = _.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new y, this.visible = !0, this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
                }

                function x() {
                    _.call(this), this.type = "Scene", this.overrideMaterial = this.fog = this.environment = this.background = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                        detail: this
                    }))
                }

                function w(a, b) {
                    this.min = void 0 !== a ? a : new o(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== b ? b : new o(-1 / 0, -1 / 0, -1 / 0)
                }

                function M(a, b, t, e, n) {
                    var r, g = 0;
                    for (r = a.length - 3; g <= r; g += 3) {
                        Ro.fromArray(a, g);
                        var o = n.x * Math.abs(Ro.x) + n.y * Math.abs(Ro.y) + n.z * Math.abs(Ro.z),
                            c = b.dot(Ro),
                            l = t.dot(Ro),
                            h = e.dot(Ro);
                        if (Math.max(-Math.max(c, l, h), Math.min(c, l, h)) > o) return !1
                    }
                    return !0
                }

                function E(a, b) {
                    this.center = void 0 !== a ? a : new o, this.radius = void 0 !== b ? b : 0
                }

                function T(a, b) {
                    this.origin = void 0 !== a ? a : new o, this.direction = void 0 !== b ? b : new o(0, 0, -1)
                }

                function D(a, b) {
                    this.normal = void 0 !== a ? a : new o(1, 0, 0), this.constant = void 0 !== b ? b : 0
                }

                function S(a, b, t) {
                    this.a = void 0 !== a ? a : new o, this.b = void 0 !== b ? b : new o, this.c = void 0 !== t ? t : new o
                }

                function A(a, b, t) {
                    return void 0 === b && void 0 === t ? this.set(a) : this.setRGB(a, b, t)
                }

                function C(a, b, t) {
                    return 0 > t && (t += 1), 1 < t && --t, t < 1 / 6 ? a + 6 * (b - a) * t : .5 > t ? b : t < 2 / 3 ? a + 6 * (b - a) * (2 / 3 - t) : a
                }

                function L(a) {
                    return .04045 > a ? .0773993808 * a : Math.pow(.9478672986 * a + .0521327014, 2.4)
                }

                function R(a) {
                    return .0031308 > a ? 12.92 * a : 1.055 * Math.pow(a, .41666) - .055
                }

                function P(a, b, t, e, n, r) {
                    this.a = a, this.b = b, this.c = t, this.normal = e && e.isVector3 ? e : new o, this.vertexNormals = Array.isArray(e) ? e : [], this.color = n && n.isColor ? n : new A, this.vertexColors = Array.isArray(n) ? n : [], this.materialIndex = void 0 !== r ? r : 0
                }

                function O() {
                    Object.defineProperty(this, "id", {
                        value: es++
                    }), this.uuid = Va.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexTangents = this.flatShading = !1, this.vertexColors = 0, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null, this.depthFunc = 3, this.depthWrite = this.depthTest = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilZPass = this.stencilZFail = this.stencilFail = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipShadows = this.clipIntersection = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.toneMapped = this.visible = !0, this.userData = {}, this.version = 0
                }

                function F(a) {
                    O.call(this), this.type = "MeshBasicMaterial", this.color = new A(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphTargets = this.skinning = !1, this.setValues(a)
                }

                function N(a, b, t) {
                    if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    this.name = "", this.array = a, this.itemSize = b, this.count = void 0 !== a ? a.length / b : 0, this.normalized = !0 === t, this.usage = 35044, this.updateRange = {
                        offset: 0,
                        count: -1
                    }, this.version = 0
                }

                function I(a, b, t) {
                    N.call(this, new Int8Array(a), b, t)
                }

                function B(a, b, t) {
                    N.call(this, new Uint8Array(a), b, t)
                }

                function k(a, b, t) {
                    N.call(this, new Uint8ClampedArray(a), b, t)
                }

                function z(a, b, t) {
                    N.call(this, new Int16Array(a), b, t)
                }

                function U(a, b, t) {
                    N.call(this, new Uint16Array(a), b, t)
                }

                function H(a, b, t) {
                    N.call(this, new Int32Array(a), b, t)
                }

                function G(a, b, t) {
                    N.call(this, new Uint32Array(a), b, t)
                }

                function V(a, b, t) {
                    N.call(this, new Float32Array(a), b, t)
                }

                function j(a, b, t) {
                    N.call(this, new Float64Array(a), b, t)
                }

                function W() {
                    this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1
                }

                function Y(a) {
                    if (0 === a.length) return -1 / 0;
                    for (var b = a[0], t = 1, e = a.length; t < e; ++t) a[t] > b && (b = a[t]);
                    return b
                }

                function X() {
                    Object.defineProperty(this, "id", {
                        value: is += 2
                    }), this.uuid = Va.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingSphere = this.boundingBox = null, this.drawRange = {
                        start: 0,
                        count: 1 / 0
                    }, this.userData = {}
                }

                function Z(a, b) {
                    _.call(this), this.type = "Mesh", this.geometry = void 0 !== a ? a : new X, this.material = void 0 !== b ? b : new F({
                        color: 16777215 * Math.random()
                    }), this.updateMorphTargets()
                }

                function J(a, b, t, e, n, r, g, o) {
                    return null === (1 === b.side ? e.intersectTriangle(g, r, n, !0, o) : e.intersectTriangle(n, r, g, 2 !== b.side, o)) ? null : (Ds.copy(o), Ds.applyMatrix4(a.matrixWorld), (b = t.ray.origin.distanceTo(Ds)) < t.near || b > t.far ? null : {
                        distance: b,
                        point: Ds.clone(),
                        object: a
                    })
                }

                function $(a, b, t, e, r, o, g, c, l, h, d, p) {
                    if (ps.fromBufferAttribute(r, h), fs.fromBufferAttribute(r, d), ms.fromBufferAttribute(r, p), r = a.morphTargetInfluences, b.morphTargets && o && r) {
                        _s.set(0, 0, 0), xs.set(0, 0, 0), bs.set(0, 0, 0);
                        for (var q = 0, f = o.length; q < f; q++) {
                            var m = r[q],
                                u = o[q];
                            0 !== m && (gs.fromBufferAttribute(u, h), vs.fromBufferAttribute(u, d), ys.fromBufferAttribute(u, p), g ? (_s.addScaledVector(gs, m), xs.addScaledVector(vs, m), bs.addScaledVector(ys, m)) : (_s.addScaledVector(gs.sub(ps), m), xs.addScaledVector(vs.sub(fs), m), bs.addScaledVector(ys.sub(ms), m)))
                        }
                        ps.add(_s), fs.add(xs), ms.add(bs)
                    }
                    return (a = J(a, b, t, e, ps, fs, ms, Ts)) && (c && (ws.fromBufferAttribute(c, h), Ms.fromBufferAttribute(c, d), Es.fromBufferAttribute(c, p), a.uv = S.getUV(Ts, ps, fs, ms, ws, Ms, Es, new n)), l && (ws.fromBufferAttribute(l, h), Ms.fromBufferAttribute(l, d), Es.fromBufferAttribute(l, p), a.uv2 = S.getUV(Ts, ps, fs, ms, ws, Ms, Es, new n)), c = new P(h, d, p), S.getNormal(ps, fs, ms, c.normal), a.face = c), a
                }

                function Q() {
                    Object.defineProperty(this, "id", {
                        value: Ss += 2
                    }), this.uuid = Va.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                        []
                    ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1
                }

                function K(a) {
                    var t, b = {};
                    for (t in a)
                        for (var e in b[t] = {}, a[t]) {
                            var n = a[t][e];
                            n && (n.isColor || n.isMatrix3 || n.isMatrix4 || n.isVector2 || n.isVector3 || n.isVector4 || n.isTexture) ? b[t][e] = n.clone() : Array.isArray(n) ? b[t][e] = n.slice() : b[t][e] = n
                        }
                    return b
                }

                function tt(a) {
                    for (var b = {}, t = 0; t < a.length; t++) {
                        var e, n = K(a[t]);
                        for (e in n) b[e] = n[e]
                    }
                    return b
                }

                function et(a) {
                    O.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1, this.extensions = {
                        derivatives: !1,
                        fragDepth: !1,
                        drawBuffers: !1,
                        shaderTextureLOD: !1
                    }, this.defaultAttributeValues = {
                        color: [1, 1, 1],
                        uv: [0, 0],
                        uv2: [0, 0]
                    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== a && (void 0 !== a.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(a))
                }

                function nt() {
                    _.call(this), this.type = "Camera", this.matrixWorldInverse = new m, this.projectionMatrix = new m, this.projectionMatrixInverse = new m
                }

                function it(a, b, t, e) {
                    nt.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== a ? a : 50, this.zoom = 1, this.near = void 0 !== t ? t : .1, this.far = void 0 !== e ? e : 2e3, this.focus = 10, this.aspect = void 0 !== b ? b : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
                }

                function at(a, b, t, e) {
                    _.call(this), this.type = "CubeCamera";
                    var n = new it(90, 1, a, b);
                    n.up.set(0, -1, 0), n.lookAt(new o(1, 0, 0)), this.add(n);
                    var r = new it(90, 1, a, b);
                    r.up.set(0, -1, 0), r.lookAt(new o(-1, 0, 0)), this.add(r);
                    var g = new it(90, 1, a, b);
                    g.up.set(0, 0, 1), g.lookAt(new o(0, 1, 0)), this.add(g);
                    var c = new it(90, 1, a, b);
                    c.up.set(0, 0, -1), c.lookAt(new o(0, -1, 0)), this.add(c);
                    var l = new it(90, 1, a, b);
                    l.up.set(0, -1, 0), l.lookAt(new o(0, 0, 1)), this.add(l);
                    var h = new it(90, 1, a, b);
                    h.up.set(0, -1, 0), h.lookAt(new o(0, 0, -1)), this.add(h), e = e || {
                        format: 1022,
                        magFilter: 1006,
                        minFilter: 1006
                    }, this.renderTarget = new ot(t, t, e), this.renderTarget.texture.name = "CubeCamera", this.update = function (a, b) {
                        null === this.parent && this.updateMatrixWorld();
                        var t = a.getRenderTarget(),
                            e = this.renderTarget,
                            p = e.texture.generateMipmaps;
                        e.texture.generateMipmaps = !1, a.setRenderTarget(e, 0), a.render(b, n), a.setRenderTarget(e, 1), a.render(b, r), a.setRenderTarget(e, 2), a.render(b, g), a.setRenderTarget(e, 3), a.render(b, c), a.setRenderTarget(e, 4), a.render(b, l), e.texture.generateMipmaps = p, a.setRenderTarget(e, 5), a.render(b, h), a.setRenderTarget(t)
                    }, this.clear = function (a, b, t, e) {
                        for (var n = a.getRenderTarget(), r = this.renderTarget, g = 0; 6 > g; g++) a.setRenderTarget(r, g), a.clear(b, t, e);
                        a.setRenderTarget(n)
                    }
                }

                function ot(a, b, t) {
                    d.call(this, a, b, t)
                }

                function st(a, b, t, e, n, r, g, o, c, h, d, p) {
                    l.call(this, null, r, g, o, c, h, e, n, d, p), this.image = {
                        data: a || null,
                        width: b || 1,
                        height: t || 1
                    }, this.magFilter = void 0 !== c ? c : 1003, this.minFilter = void 0 !== h ? h : 1003, this.flipY = this.generateMipmaps = !1, this.unpackAlignment = 1, this.needsUpdate = !0
                }

                function ut(a, b, t, e, n, r) {
                    this.planes = [void 0 !== a ? a : new D, void 0 !== b ? b : new D, void 0 !== t ? t : new D, void 0 !== e ? e : new D, void 0 !== n ? n : new D, void 0 !== r ? r : new D]
                }

                function ct() {
                    function a(n, r) {
                        !1 !== t && (e(n, r), b.requestAnimationFrame(a))
                    }
                    var b = null,
                        t = !1,
                        e = null;
                    return {
                        start: function () {
                            !0 !== t && null !== e && (b.requestAnimationFrame(a), t = !0)
                        },
                        stop: function () {
                            t = !1
                        },
                        setAnimationLoop: function (a) {
                            e = a
                        },
                        setContext: function (a) {
                            b = a
                        }
                    }
                }

                function lt(a) {
                    var t = new WeakMap;
                    return {
                        get: function (a) {
                            return a.isInterleavedBufferAttribute && (a = a.data), t.get(a)
                        },
                        remove: function (b) {
                            b.isInterleavedBufferAttribute && (b = b.data);
                            var e = t.get(b);
                            e && (a.deleteBuffer(e.buffer), t.delete(b))
                        },
                        update: function (e, n) {
                            e.isInterleavedBufferAttribute && (e = e.data);
                            var r = t.get(e);
                            if (void 0 === r) t.set(e, function (b, t) {
                                var e = b.array,
                                    n = b.usage,
                                    r = a.createBuffer();
                                return a.bindBuffer(t, r), a.bufferData(t, e, n), b.onUploadCallback(), t = 5126, e instanceof Float32Array ? t = 5126 : e instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : e instanceof Uint16Array ? t = 5123 : e instanceof Int16Array ? t = 5122 : e instanceof Uint32Array ? t = 5125 : e instanceof Int32Array ? t = 5124 : e instanceof Int8Array ? t = 5120 : e instanceof Uint8Array && (t = 5121), {
                                    buffer: r,
                                    type: t,
                                    bytesPerElement: e.BYTES_PER_ELEMENT,
                                    version: b.version
                                }
                            }(e, n));
                            else if (r.version < e.version) {
                                var g = e.array,
                                    o = e.updateRange;
                                a.bindBuffer(n, r.buffer), -1 === o.count ? a.bufferSubData(n, 0, g) : (a.bufferSubData(n, o.offset * g.BYTES_PER_ELEMENT, g.subarray(o.offset, o.offset + o.count)), o.count = -1), r.version = e.version
                            }
                        }
                    }
                }

                function ht(a, b, t, e) {
                    Q.call(this), this.type = "PlaneGeometry", this.parameters = {
                        width: a,
                        height: b,
                        widthSegments: t,
                        heightSegments: e
                    }, this.fromBufferGeometry(new pt(a, b, t, e)), this.mergeVertices()
                }

                function pt(a, b, t, e) {
                    X.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                        width: a,
                        height: b,
                        widthSegments: t,
                        heightSegments: e
                    };
                    var n = (a = a || 1) / 2,
                        r = (b = b || 1) / 2,
                        g = (t = Math.floor(t) || 1) + 1,
                        o = (e = Math.floor(e) || 1) + 1,
                        c = a / t,
                        l = b / e,
                        h = [],
                        p = [],
                        q = [],
                        d = [];
                    for (a = 0; a < o; a++) {
                        var f = a * l - r;
                        for (b = 0; b < g; b++) p.push(b * c - n, -f, 0), q.push(0, 0, 1), d.push(b / t), d.push(1 - a / e)
                    }
                    for (a = 0; a < e; a++)
                        for (b = 0; b < t; b++) n = b + g * (a + 1), r = b + 1 + g * (a + 1), o = b + 1 + g * a, h.push(b + g * a, n, o), h.push(n, r, o);
                    this.setIndex(h), this.setAttribute("position", new V(p, 3)), this.setAttribute("normal", new V(q, 3)), this.setAttribute("uv", new V(d, 2))
                }

                function ft(a, b, t, e) {
                    function n(a, t) {
                        b.buffers.color.setClear(a.r, a.g, a.b, t, e)
                    }
                    var r, o, c = new A(0),
                        g = 0,
                        l = null,
                        h = 0;
                    return {
                        getClearColor: function () {
                            return c
                        },
                        setClearColor: function (a, b) {
                            c.set(a), n(c, g = void 0 !== b ? b : 1)
                        },
                        getClearAlpha: function () {
                            return g
                        },
                        setClearAlpha: function (a) {
                            n(c, g = a)
                        },
                        render: function (b, e, d, f) {
                            e = e.background, (d = (d = a.xr).getSession && d.getSession()) && "additive" === d.environmentBlendMode && (e = null), null === e ? (n(c, g), l = null, h = 0) : e && e.isColor && (n(e, 1), f = !0, l = null, h = 0), (a.autoClear || f) && a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil), e && (e.isCubeTexture || e.isWebGLRenderTargetCube || 306 === e.mapping) ? (void 0 === o && ((o = new Z(new Ps(1, 1, 1), new et({
                                type: "BackgroundCubeMaterial",
                                uniforms: K(ks.cube.uniforms),
                                vertexShader: ks.cube.vertexShader,
                                fragmentShader: ks.cube.fragmentShader,
                                side: 1,
                                depthTest: !1,
                                depthWrite: !1,
                                fog: !1
                            }))).geometry.deleteAttribute("normal"), o.geometry.deleteAttribute("uv"), o.onBeforeRender = function (a, b, t) {
                                this.matrixWorld.copyPosition(t.matrixWorld)
                            }, Object.defineProperty(o.material, "envMap", {
                                get: function () {
                                    return this.uniforms.envMap.value
                                }
                            }), t.update(o)), f = e.isWebGLRenderTargetCube ? e.texture : e, o.material.uniforms.envMap.value = f, o.material.uniforms.flipEnvMap.value = f.isCubeTexture ? -1 : 1, l === e && h === f.version || (o.material.needsUpdate = !0, l = e, h = f.version), b.unshift(o, o.geometry, o.material, 0, 0, null)) : e && e.isTexture && (void 0 === r && ((r = new Z(new pt(2, 2), new et({
                                type: "BackgroundMaterial",
                                uniforms: K(ks.background.uniforms),
                                vertexShader: ks.background.vertexShader,
                                fragmentShader: ks.background.fragmentShader,
                                side: 0,
                                depthTest: !1,
                                depthWrite: !1,
                                fog: !1
                            }))).geometry.deleteAttribute("normal"), Object.defineProperty(r.material, "map", {
                                get: function () {
                                    return this.uniforms.t2D.value
                                }
                            }), t.update(r)), r.material.uniforms.t2D.value = e, !0 === e.matrixAutoUpdate && e.updateMatrix(), r.material.uniforms.uvTransform.value.copy(e.matrix), l === e && h === e.version || (r.material.needsUpdate = !0, l = e, h = e.version), b.unshift(r, r.geometry, r.material, 0, 0, null))
                        }
                    }
                }

                function mt(a, b, t, e) {
                    var n, r = e.isWebGL2;
                    this.setMode = function (a) {
                        n = a
                    }, this.render = function (b, e) {
                        a.drawArrays(n, b, e), t.update(e, n)
                    }, this.renderInstances = function (e, o, c, l) {
                        if (0 !== l) {
                            if (r) {
                                e = a;
                                var g = "drawArraysInstanced"
                            } else if (g = "drawArraysInstancedANGLE", null === (e = b.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                            e[g](n, o, c, l), t.update(c, n, l)
                        }
                    }
                }

                function gt(a, b, t) {
                    function e(b) {
                        if ("highp" === b) {
                            if (0 < a.getShaderPrecisionFormat(35633, 36338).precision && 0 < a.getShaderPrecisionFormat(35632, 36338).precision) return "highp";
                            b = "mediump"
                        }
                        return "mediump" === b && 0 < a.getShaderPrecisionFormat(35633, 36337).precision && 0 < a.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp"
                    }
                    var n, r = "undefined" != typeof WebGL2RenderingContext && a instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && a instanceof WebGL2ComputeRenderingContext,
                        g = void 0 !== t.precision ? t.precision : "highp",
                        o = e(g);
                    o !== g && (console.warn("THREE.WebGLRenderer:", g, "not supported, using", o, "instead."), g = o), t = !0 === t.logarithmicDepthBuffer, o = a.getParameter(34930);
                    var c = a.getParameter(35660),
                        l = a.getParameter(3379),
                        h = a.getParameter(34076),
                        p = a.getParameter(34921),
                        q = a.getParameter(36347),
                        d = a.getParameter(36348),
                        f = a.getParameter(36349),
                        u = 0 < c,
                        m = r || !!b.get("OES_texture_float");
                    return {
                        isWebGL2: r,
                        getMaxAnisotropy: function () {
                            if (void 0 !== n) return n;
                            var t = b.get("EXT_texture_filter_anisotropic");
                            return n = null !== t ? a.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                        },
                        getMaxPrecision: e,
                        precision: g,
                        logarithmicDepthBuffer: t,
                        maxTextures: o,
                        maxVertexTextures: c,
                        maxTextureSize: l,
                        maxCubemapSize: h,
                        maxAttributes: p,
                        maxVertexUniforms: q,
                        maxVaryings: d,
                        maxFragmentUniforms: f,
                        vertexTextures: u,
                        floatFragmentTextures: m,
                        floatVertexTextures: u && m,
                        maxSamples: r ? a.getParameter(36183) : 0
                    }
                }

                function vt() {
                    function a() {
                        h.value !== e && (h.value = e, h.needsUpdate = 0 < n), t.numPlanes = n, t.numIntersection = 0
                    }

                    function b(a, b, e, n) {
                        var r = null !== a ? a.length : 0,
                            g = null;
                        if (0 !== r) {
                            if (g = h.value, !0 !== n || null === g)
                                for (n = e + 4 * r, b = b.matrixWorldInverse, l.getNormalMatrix(b), (null === g || g.length < n) && (g = new Float32Array(n)), n = 0; n !== r; ++n, e += 4) o.copy(a[n]).applyMatrix4(b, l), o.normal.toArray(g, e), g[e + 3] = o.constant;
                            h.value = g, h.needsUpdate = !0
                        }
                        return t.numPlanes = r, g
                    }
                    var t = this,
                        e = null,
                        n = 0,
                        r = !1,
                        g = !1,
                        o = new D,
                        l = new c,
                        h = {
                            value: null,
                            needsUpdate: !1
                        };
                    this.uniform = h, this.numIntersection = this.numPlanes = 0, this.init = function (a, t, g) {
                        var o = 0 !== a.length || t || 0 !== n || r;
                        return r = t, e = b(a, g, 0), n = a.length, o
                    }, this.beginShadows = function () {
                        g = !0, b(null)
                    }, this.endShadows = function () {
                        g = !1, a()
                    }, this.setState = function (t, o, c, l, d, u) {
                        if (!r || null === t || 0 === t.length || g && !c) g ? b(null) : a();
                        else {
                            var p = 4 * (c = g ? 0 : n),
                                f = d.clippingState || null;
                            for (h.value = f, f = b(t, l, p, u), t = 0; t !== p; ++t) f[t] = e[t];
                            d.clippingState = f, this.numIntersection = o ? this.numPlanes : 0, this.numPlanes += c
                        }
                    }
                }

                function yt(a) {
                    var b = {};
                    return {
                        get: function (t) {
                            if (void 0 !== b[t]) return b[t];
                            switch (t) {
                                case "WEBGL_depth_texture":
                                    var e = a.getExtension("WEBGL_depth_texture") || a.getExtension("MOZ_WEBGL_depth_texture") || a.getExtension("WEBKIT_WEBGL_depth_texture");
                                    break;
                                case "EXT_texture_filter_anisotropic":
                                    e = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                    break;
                                case "WEBGL_compressed_texture_s3tc":
                                    e = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                    break;
                                case "WEBGL_compressed_texture_pvrtc":
                                    e = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                    break;
                                default:
                                    e = a.getExtension(t)
                            }
                            return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), b[t] = e
                        }
                    }
                }

                function _t(a, b, t) {
                    function e(a) {
                        var n = a.target;
                        for (var o in null !== (a = r.get(n)).index && b.remove(a.index), a.attributes) b.remove(a.attributes[o]);
                        n.removeEventListener("dispose", e), r.delete(n), (o = g.get(a)) && (b.remove(o), g.delete(a)), t.memory.geometries--
                    }

                    function n(a) {
                        var t = [],
                            e = a.index,
                            n = a.attributes.position;
                        if (null !== e) {
                            var r = e.array;
                            e = e.version, n = 0;
                            for (var o = r.length; n < o; n += 3) {
                                var c = r[n + 0],
                                    l = r[n + 1],
                                    u = r[n + 2];
                                t.push(c, l, l, u, u, c)
                            }
                        } else
                            for (r = n.array, e = n.version, n = 0, o = r.length / 3 - 1; n < o; n += 3) c = n + 0, l = n + 1, u = n + 2, t.push(c, l, l, u, u, c);
                        (t = new(65535 < Y(t) ? G : U)(t, 1)).version = e, b.update(t, 34963), (r = g.get(a)) && b.remove(r), g.set(a, t)
                    }
                    var r = new WeakMap,
                        g = new WeakMap;
                    return {
                        get: function (a, b) {
                            var n = r.get(b);
                            return n || (b.addEventListener("dispose", e), b.isBufferGeometry ? n = b : b.isGeometry && (void 0 === b._bufferGeometry && (b._bufferGeometry = (new X).setFromObject(a)), n = b._bufferGeometry), r.set(b, n), t.memory.geometries++, n)
                        },
                        update: function (a) {
                            var t = a.index,
                                e = a.attributes;
                            for (var n in null !== t && b.update(t, 34963), e) b.update(e[n], 34962);
                            for (n in a = a.morphAttributes) {
                                e = 0;
                                for (var r = (t = a[n]).length; e < r; e++) b.update(t[e], 34962)
                            }
                        },
                        getWireframeAttribute: function (a) {
                            var b = g.get(a);
                            if (b) {
                                var t = a.index;
                                null !== t && b.version < t.version && n(a)
                            } else n(a);
                            return g.get(a)
                        }
                    }
                }

                function xt(a, b, t, e) {
                    var n, g, r, o = e.isWebGL2;
                    this.setMode = function (a) {
                        n = a
                    }, this.setIndex = function (a) {
                        g = a.type, r = a.bytesPerElement
                    }, this.render = function (b, e) {
                        a.drawElements(n, e, g, b * r), t.update(e, n)
                    }, this.renderInstances = function (e, c, l, p) {
                        if (0 !== p) {
                            if (o) {
                                e = a;
                                var h = "drawElementsInstanced"
                            } else if (h = "drawElementsInstancedANGLE", null === (e = b.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                            e[h](n, l, g, c * r, p), t.update(l, n, p)
                        }
                    }
                }

                function bt(a) {
                    var b = {
                        frame: 0,
                        calls: 0,
                        triangles: 0,
                        points: 0,
                        lines: 0
                    };
                    return {
                        memory: {
                            geometries: 0,
                            textures: 0
                        },
                        render: b,
                        programs: null,
                        autoReset: !0,
                        reset: function () {
                            b.frame++, b.calls = 0, b.triangles = 0, b.points = 0, b.lines = 0
                        },
                        update: function (a, t, e) {
                            switch (e = e || 1, b.calls++, t) {
                                case 4:
                                    b.triangles += a / 3 * e;
                                    break;
                                case 1:
                                    b.lines += a / 2 * e;
                                    break;
                                case 3:
                                    b.lines += e * (a - 1);
                                    break;
                                case 2:
                                    b.lines += e * a;
                                    break;
                                case 0:
                                    b.points += e * a;
                                    break;
                                default:
                                    console.error("THREE.WebGLInfo: Unknown draw mode:", t)
                            }
                        }
                    }
                }

                function wt(a, b) {
                    return Math.abs(b[1]) - Math.abs(a[1])
                }

                function Mt(a) {
                    var b = {},
                        t = new Float32Array(8);
                    return {
                        update: function (e, n, r, g) {
                            var o = e.morphTargetInfluences,
                                c = void 0 === o ? 0 : o.length;
                            if (void 0 === (e = b[n.id])) {
                                e = [];
                                for (var l = 0; l < c; l++) e[l] = [l, 0];
                                b[n.id] = e
                            }
                            var h = r.morphTargets && n.morphAttributes.position;
                            for (r = r.morphNormals && n.morphAttributes.normal, l = 0; l < c; l++) {
                                var p = e[l];
                                0 !== p[1] && (h && n.deleteAttribute("morphTarget" + l), r && n.deleteAttribute("morphNormal" + l))
                            }
                            for (l = 0; l < c; l++)(p = e[l])[0] = l, p[1] = o[l];
                            for (e.sort(wt), l = o = 0; 8 > l; l++)(p = e[l]) && (c = p[0], p = p[1]) ? (h && n.setAttribute("morphTarget" + l, h[c]), r && n.setAttribute("morphNormal" + l, r[c]), t[l] = p, o += p) : t[l] = 0;
                            n = n.morphTargetsRelative ? 1 : 1 - o, g.getUniforms().setValue(a, "morphTargetBaseInfluence", n), g.getUniforms().setValue(a, "morphTargetInfluences", t)
                        }
                    }
                }

                function Et(a, b, t, e) {
                    var n = {};
                    return {
                        update: function (a) {
                            var r = e.render.frame,
                                o = a.geometry,
                                c = b.get(a, o);
                            return n[c.id] !== r && (o.isGeometry && c.updateFromObject(a), b.update(c), n[c.id] = r), a.isInstancedMesh && t.update(a.instanceMatrix, 34962), c
                        },
                        dispose: function () {
                            n = {}
                        }
                    }
                }

                function Tt(a, b, t, e, n, r, g, o, c, h) {
                    a = void 0 !== a ? a : [], l.call(this, a, void 0 !== b ? b : 301, t, e, n, r, void 0 !== g ? g : 1022, o, c, h), this.flipY = !1
                }

                function Dt(a, b, t, e) {
                    l.call(this, null), this.image = {
                        data: a || null,
                        width: b || 1,
                        height: t || 1,
                        depth: e || 1
                    }, this.minFilter = this.magFilter = 1003, this.wrapR = 1001, this.flipY = this.generateMipmaps = !1, this.needsUpdate = !0
                }

                function St(a, b, t, e) {
                    l.call(this, null), this.image = {
                        data: a || null,
                        width: b || 1,
                        height: t || 1,
                        depth: e || 1
                    }, this.minFilter = this.magFilter = 1003, this.wrapR = 1001, this.flipY = this.generateMipmaps = !1, this.needsUpdate = !0
                }

                function At(a, b, t) {
                    var e = a[0];
                    if (0 >= e || 0 < e) return a;
                    var n = b * t,
                        r = Vs[n];
                    if (void 0 === r && (r = new Float32Array(n), Vs[n] = r), 0 !== b)
                        for (e.toArray(r, 0), e = 1, n = 0; e !== b; ++e) n += t, a[e].toArray(r, n);
                    return r
                }

                function Ct(a, b) {
                    if (a.length !== b.length) return !1;
                    for (var t = 0, e = a.length; t < e; t++)
                        if (a[t] !== b[t]) return !1;
                    return !0
                }

                function Lt(a, b) {
                    for (var t = 0, e = b.length; t < e; t++) a[t] = b[t]
                }

                function Rt(a, b) {
                    var t = js[b];
                    void 0 === t && (t = new Int32Array(b), js[b] = t);
                    for (var e = 0; e !== b; ++e) t[e] = a.allocateTextureUnit();
                    return t
                }

                function Pt(a, b) {
                    var t = this.cache;
                    t[0] !== b && (a.uniform1f(this.addr, b), t[0] = b)
                }

                function Ot(a, b) {
                    var t = this.cache;
                    void 0 !== b.x ? t[0] === b.x && t[1] === b.y || (a.uniform2f(this.addr, b.x, b.y), t[0] = b.x, t[1] = b.y) : Ct(t, b) || (a.uniform2fv(this.addr, b), Lt(t, b))
                }

                function Ft(a, b) {
                    var t = this.cache;
                    void 0 !== b.x ? t[0] === b.x && t[1] === b.y && t[2] === b.z || (a.uniform3f(this.addr, b.x, b.y, b.z), t[0] = b.x, t[1] = b.y, t[2] = b.z) : void 0 !== b.r ? t[0] === b.r && t[1] === b.g && t[2] === b.b || (a.uniform3f(this.addr, b.r, b.g, b.b), t[0] = b.r, t[1] = b.g, t[2] = b.b) : Ct(t, b) || (a.uniform3fv(this.addr, b), Lt(t, b))
                }

                function Nt(a, b) {
                    var t = this.cache;
                    void 0 !== b.x ? t[0] === b.x && t[1] === b.y && t[2] === b.z && t[3] === b.w || (a.uniform4f(this.addr, b.x, b.y, b.z, b.w), t[0] = b.x, t[1] = b.y, t[2] = b.z, t[3] = b.w) : Ct(t, b) || (a.uniform4fv(this.addr, b), Lt(t, b))
                }

                function It(a, b) {
                    var t = this.cache,
                        e = b.elements;
                    void 0 === e ? Ct(t, b) || (a.uniformMatrix2fv(this.addr, !1, b), Lt(t, b)) : Ct(t, e) || (qs.set(e), a.uniformMatrix2fv(this.addr, !1, qs), Lt(t, e))
                }

                function Bt(a, b) {
                    var t = this.cache,
                        e = b.elements;
                    void 0 === e ? Ct(t, b) || (a.uniformMatrix3fv(this.addr, !1, b), Lt(t, b)) : Ct(t, e) || (Ys.set(e), a.uniformMatrix3fv(this.addr, !1, Ys), Lt(t, e))
                }

                function kt(a, b) {
                    var t = this.cache,
                        e = b.elements;
                    void 0 === e ? Ct(t, b) || (a.uniformMatrix4fv(this.addr, !1, b), Lt(t, b)) : Ct(t, e) || (Ws.set(e), a.uniformMatrix4fv(this.addr, !1, Ws), Lt(t, e))
                }

                function zt(a, b, t) {
                    var e = this.cache,
                        n = t.allocateTextureUnit();
                    e[0] !== n && (a.uniform1i(this.addr, n), e[0] = n), t.safeSetTexture2D(b || zs, n)
                }

                function Ut(a, b, t) {
                    var e = this.cache,
                        n = t.allocateTextureUnit();
                    e[0] !== n && (a.uniform1i(this.addr, n), e[0] = n), t.setTexture2DArray(b || Us, n)
                }

                function Ht(a, b, t) {
                    var e = this.cache,
                        n = t.allocateTextureUnit();
                    e[0] !== n && (a.uniform1i(this.addr, n), e[0] = n), t.setTexture3D(b || Hs, n)
                }

                function Gt(a, b, t) {
                    var e = this.cache,
                        n = t.allocateTextureUnit();
                    e[0] !== n && (a.uniform1i(this.addr, n), e[0] = n), t.safeSetTextureCube(b || Gs, n)
                }

                function Vt(a, b) {
                    var t = this.cache;
                    t[0] !== b && (a.uniform1i(this.addr, b), t[0] = b)
                }

                function jt(a, b) {
                    var t = this.cache;
                    Ct(t, b) || (a.uniform2iv(this.addr, b), Lt(t, b))
                }

                function Wt(a, b) {
                    var t = this.cache;
                    Ct(t, b) || (a.uniform3iv(this.addr, b), Lt(t, b))
                }

                function Yt(a, b) {
                    var t = this.cache;
                    Ct(t, b) || (a.uniform4iv(this.addr, b), Lt(t, b))
                }

                function qt(a, b) {
                    a.uniform1fv(this.addr, b)
                }

                function Xt(a, b) {
                    a.uniform1iv(this.addr, b)
                }

                function Zt(a, b) {
                    a.uniform2iv(this.addr, b)
                }

                function Jt(a, b) {
                    a.uniform3iv(this.addr, b)
                }

                function $t(a, b) {
                    a.uniform4iv(this.addr, b)
                }

                function Qt(a, b) {
                    b = At(b, this.size, 2), a.uniform2fv(this.addr, b)
                }

                function Kt(a, b) {
                    b = At(b, this.size, 3), a.uniform3fv(this.addr, b)
                }

                function te(a, b) {
                    b = At(b, this.size, 4), a.uniform4fv(this.addr, b)
                }

                function ee(a, b) {
                    b = At(b, this.size, 4), a.uniformMatrix2fv(this.addr, !1, b)
                }

                function ne(a, b) {
                    b = At(b, this.size, 9), a.uniformMatrix3fv(this.addr, !1, b)
                }

                function ie(a, b) {
                    b = At(b, this.size, 16), a.uniformMatrix4fv(this.addr, !1, b)
                }

                function re(a, b, t) {
                    var e = b.length,
                        n = Rt(t, e);
                    for (a.uniform1iv(this.addr, n), a = 0; a !== e; ++a) t.safeSetTexture2D(b[a] || zs, n[a])
                }

                function ae(a, b, t) {
                    var e = b.length,
                        n = Rt(t, e);
                    for (a.uniform1iv(this.addr, n), a = 0; a !== e; ++a) t.safeSetTextureCube(b[a] || Gs, n[a])
                }

                function oe(a, b, t) {
                    this.id = a, this.addr = t, this.cache = [], this.setValue = function (a) {
                        switch (a) {
                            case 5126:
                                return Pt;
                            case 35664:
                                return Ot;
                            case 35665:
                                return Ft;
                            case 35666:
                                return Nt;
                            case 35674:
                                return It;
                            case 35675:
                                return Bt;
                            case 35676:
                                return kt;
                            case 35678:
                            case 36198:
                                return zt;
                            case 35679:
                                return Ht;
                            case 35680:
                                return Gt;
                            case 36289:
                                return Ut;
                            case 5124:
                            case 35670:
                                return Vt;
                            case 35667:
                            case 35671:
                                return jt;
                            case 35668:
                            case 35672:
                                return Wt;
                            case 35669:
                            case 35673:
                                return Yt
                        }
                    }(b.type)
                }

                function se(a, b, t) {
                    this.id = a, this.addr = t, this.cache = [], this.size = b.size, this.setValue = function (a) {
                        switch (a) {
                            case 5126:
                                return qt;
                            case 35664:
                                return Qt;
                            case 35665:
                                return Kt;
                            case 35666:
                                return te;
                            case 35674:
                                return ee;
                            case 35675:
                                return ne;
                            case 35676:
                                return ie;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                                return re;
                            case 35680:
                            case 36300:
                            case 36308:
                                return ae;
                            case 5124:
                            case 35670:
                                return Xt;
                            case 35667:
                            case 35671:
                                return Zt;
                            case 35668:
                            case 35672:
                                return Jt;
                            case 35669:
                            case 35673:
                                return $t
                        }
                    }(b.type)
                }

                function ue(a) {
                    this.id = a, this.seq = [], this.map = {}
                }

                function ce(a, b) {
                    this.seq = [], this.map = {};
                    for (var t = a.getProgramParameter(b, 35718), e = 0; e < t; ++e) {
                        var n = a.getActiveUniform(b, e),
                            r = a.getUniformLocation(b, n.name),
                            g = this,
                            o = n.name,
                            c = o.length;
                        for (Xs.lastIndex = 0;;) {
                            var l = Xs.exec(o),
                                h = Xs.lastIndex,
                                p = l[1],
                                d = l[3];
                            if ("]" === l[2] && (p |= 0), void 0 === d || "[" === d && h + 2 === c) {
                                o = g, n = void 0 === d ? new oe(p, n, r) : new se(p, n, r), o.seq.push(n), o.map[n.id] = n;
                                break
                            }
                            void 0 === (d = g.map[p]) && (d = new ue(p), p = g, g = d, p.seq.push(g), p.map[g.id] = g), g = d
                        }
                    }
                }

                function le(a, b, t) {
                    return b = a.createShader(b), a.shaderSource(b, t), a.compileShader(b), b
                }

                function he(a) {
                    switch (a) {
                        case 3e3:
                            return ["Linear", "( value )"];
                        case 3001:
                            return ["sRGB", "( value )"];
                        case 3002:
                            return ["RGBE", "( value )"];
                        case 3004:
                            return ["RGBM", "( value, 7.0 )"];
                        case 3005:
                            return ["RGBM", "( value, 16.0 )"];
                        case 3006:
                            return ["RGBD", "( value, 256.0 )"];
                        case 3007:
                            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                        case 3003:
                            return ["LogLuv", "( value )"];
                        default:
                            throw Error("unsupported encoding: " + a)
                    }
                }

                function de(a, b, t) {
                    var e = a.getShaderParameter(b, 35713),
                        n = a.getShaderInfoLog(b).trim();
                    if (e && "" === n) return "";
                    for (a = a.getShaderSource(b).split("\n"), b = 0; b < a.length; b++) a[b] = b + 1 + ": " + a[b];
                    return "THREE.WebGLShader: gl.getShaderInfoLog() " + t + "\n" + n + (a = a.join("\n"))
                }

                function pe(a, b) {
                    return "vec4 " + a + "( vec4 value ) { return " + (b = he(b))[0] + "ToLinear" + b[1] + "; }"
                }

                function fe(a, b) {
                    return "vec4 " + a + "( vec4 value ) { return LinearTo" + (b = he(b))[0] + b[1] + "; }"
                }

                function me(a, b) {
                    switch (b) {
                        case 1:
                            b = "Linear";
                            break;
                        case 2:
                            b = "Reinhard";
                            break;
                        case 3:
                            b = "Uncharted2";
                            break;
                        case 4:
                            b = "OptimizedCineon";
                            break;
                        case 5:
                            b = "ACESFilmic";
                            break;
                        default:
                            throw Error("unsupported toneMapping: " + b)
                    }
                    return "vec3 " + a + "( vec3 color ) { return " + b + "ToneMapping( color ); }"
                }

                function ge(a) {
                    return "" !== a
                }

                function ve(a, b) {
                    return a.replace(/NUM_DIR_LIGHTS/g, b.numDirLights).replace(/NUM_SPOT_LIGHTS/g, b.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, b.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, b.numPointLights).replace(/NUM_HEMI_LIGHTS/g, b.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, b.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, b.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, b.numPointLightShadows)
                }

                function ye(a, b) {
                    return a.replace(/NUM_CLIPPING_PLANES/g, b.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, b.numClippingPlanes - b.numClipIntersection)
                }

                function _e(a, b) {
                    if (void 0 === (a = Is[b])) throw Error("Can not resolve #include <" + b + ">");
                    return a.replace(Js, _e)
                }

                function xe(a, b, t, e) {
                    for (a = "", b = parseInt(b); b < parseInt(t); b++) a += e.replace(/\[ i \]/g, "[ " + b + " ]").replace(/UNROLLED_LOOP_INDEX/g, b);
                    return a
                }

                function be(a) {
                    var b = "precision " + a.precision + " float;\nprecision " + a.precision + " int;";
                    return "highp" === a.precision ? b += "\n#define HIGH_PRECISION" : "mediump" === a.precision ? b += "\n#define MEDIUM_PRECISION" : "lowp" === a.precision && (b += "\n#define LOW_PRECISION"), b
                }

                function we(a, b, t, e, n, r) {
                    var o, c, g = a.getContext(),
                        l = e.defines,
                        h = n.vertexShader,
                        d = n.fragmentShader,
                        f = function (a) {
                            var b = "SHADOWMAP_TYPE_BASIC";
                            return 1 === a.shadowMapType ? b = "SHADOWMAP_TYPE_PCF" : 2 === a.shadowMapType ? b = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === a.shadowMapType && (b = "SHADOWMAP_TYPE_VSM"), b
                        }(r),
                        p = function (a) {
                            var b = "ENVMAP_TYPE_CUBE";
                            if (a.envMap) switch (a.envMapMode) {
                                case 301:
                                case 302:
                                    b = "ENVMAP_TYPE_CUBE";
                                    break;
                                case 306:
                                case 307:
                                    b = "ENVMAP_TYPE_CUBE_UV";
                                    break;
                                case 303:
                                case 304:
                                    b = "ENVMAP_TYPE_EQUIREC";
                                    break;
                                case 305:
                                    b = "ENVMAP_TYPE_SPHERE"
                            }
                            return b
                        }(r),
                        m = function (a) {
                            var b = "ENVMAP_MODE_REFLECTION";
                            if (a.envMap) switch (a.envMapMode) {
                                case 302:
                                case 304:
                                    b = "ENVMAP_MODE_REFRACTION"
                            }
                            return b
                        }(r),
                        v = function (a) {
                            var b = "ENVMAP_BLENDING_NONE";
                            if (a.envMap) switch (a.combine) {
                                case 0:
                                    b = "ENVMAP_BLENDING_MULTIPLY";
                                    break;
                                case 1:
                                    b = "ENVMAP_BLENDING_MIX";
                                    break;
                                case 2:
                                    b = "ENVMAP_BLENDING_ADD"
                            }
                            return b
                        }(r),
                        y = 0 < a.gammaFactor ? a.gammaFactor : 1,
                        u = r.isWebGL2 ? "" : function (a, b, t) {
                            return [(a = a || {}).derivatives || b.envMapCubeUV || b.bumpMap || b.tangentSpaceNormalMap || b.clearcoatNormalMap || b.flatShading || "physical" === b.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (a.fragDepth || b.logarithmicDepthBuffer) && t.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", a.drawBuffers && t.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (a.shaderTextureLOD || b.envMap) && t.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(ge).join("\n")
                        }(e.extensions, r, b),
                        _ = function (a) {
                            var t, b = [];
                            for (t in a) {
                                var e = a[t];
                                !1 !== e && b.push("#define " + t + " " + e)
                            }
                            return b.join("\n")
                        }(l),
                        x = g.createProgram(),
                        w = r.numMultiviewViews;
                    return e.isRawShaderMaterial ? (0 < (l = [_].filter(ge).join("\n")).length && (l += "\n"), 0 < (b = [u, _].filter(ge).join("\n")).length && (b += "\n")) : (l = [be(r), "#define SHADER_NAME " + n.name, _, r.instancing ? "#define USE_INSTANCING" : "", r.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + y, "#define MAX_BONES " + r.maxBones, r.useFog && r.fog ? "#define USE_FOG" : "", r.useFog && r.fogExp2 ? "#define FOG_EXP2" : "", r.map ? "#define USE_MAP" : "", r.envMap ? "#define USE_ENVMAP" : "", r.envMap ? "#define " + m : "", r.lightMap ? "#define USE_LIGHTMAP" : "", r.aoMap ? "#define USE_AOMAP" : "", r.emissiveMap ? "#define USE_EMISSIVEMAP" : "", r.bumpMap ? "#define USE_BUMPMAP" : "", r.normalMap ? "#define USE_NORMALMAP" : "", r.normalMap && r.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", r.normalMap && r.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", r.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", r.displacementMap && r.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", r.specularMap ? "#define USE_SPECULARMAP" : "", r.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", r.metalnessMap ? "#define USE_METALNESSMAP" : "", r.alphaMap ? "#define USE_ALPHAMAP" : "", r.vertexTangents ? "#define USE_TANGENT" : "", r.vertexColors ? "#define USE_COLOR" : "", r.vertexUvs ? "#define USE_UV" : "", r.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", r.flatShading ? "#define FLAT_SHADED" : "", r.skinning ? "#define USE_SKINNING" : "", r.useVertexTexture ? "#define BONE_TEXTURE" : "", r.morphTargets ? "#define USE_MORPHTARGETS" : "", r.morphNormals && !1 === r.flatShading ? "#define USE_MORPHNORMALS" : "", r.doubleSided ? "#define DOUBLE_SIDED" : "", r.flipSided ? "#define FLIP_SIDED" : "", r.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", r.shadowMapEnabled ? "#define " + f : "", r.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", r.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", r.logarithmicDepthBuffer && (r.isWebGL2 || b.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", " attribute mat4 instanceMatrix;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(ge).join("\n"), b = [u, be(r), "#define SHADER_NAME " + n.name, _, r.alphaTest ? "#define ALPHATEST " + r.alphaTest + (r.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + y, r.useFog && r.fog ? "#define USE_FOG" : "", r.useFog && r.fogExp2 ? "#define FOG_EXP2" : "", r.map ? "#define USE_MAP" : "", r.matcap ? "#define USE_MATCAP" : "", r.envMap ? "#define USE_ENVMAP" : "", r.envMap ? "#define " + p : "", r.envMap ? "#define " + m : "", r.envMap ? "#define " + v : "", r.lightMap ? "#define USE_LIGHTMAP" : "", r.aoMap ? "#define USE_AOMAP" : "", r.emissiveMap ? "#define USE_EMISSIVEMAP" : "", r.bumpMap ? "#define USE_BUMPMAP" : "", r.normalMap ? "#define USE_NORMALMAP" : "", r.normalMap && r.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", r.normalMap && r.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", r.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", r.specularMap ? "#define USE_SPECULARMAP" : "", r.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", r.metalnessMap ? "#define USE_METALNESSMAP" : "", r.alphaMap ? "#define USE_ALPHAMAP" : "", r.sheen ? "#define USE_SHEEN" : "", r.vertexTangents ? "#define USE_TANGENT" : "", r.vertexColors ? "#define USE_COLOR" : "", r.vertexUvs ? "#define USE_UV" : "", r.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", r.gradientMap ? "#define USE_GRADIENTMAP" : "", r.flatShading ? "#define FLAT_SHADED" : "", r.doubleSided ? "#define DOUBLE_SIDED" : "", r.flipSided ? "#define FLIP_SIDED" : "", r.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", r.shadowMapEnabled ? "#define " + f : "", r.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", r.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", r.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", r.logarithmicDepthBuffer && (r.isWebGL2 || b.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", (e.extensions && e.extensions.shaderTextureLOD || r.envMap) && (r.isWebGL2 || b.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== r.toneMapping ? "#define TONE_MAPPING" : "", 0 !== r.toneMapping ? Is.tonemapping_pars_fragment : "", 0 !== r.toneMapping ? me("toneMapping", r.toneMapping) : "", r.dithering ? "#define DITHERING" : "", r.outputEncoding || r.mapEncoding || r.matcapEncoding || r.envMapEncoding || r.emissiveMapEncoding || r.lightMapEncoding ? Is.encodings_pars_fragment : "", r.mapEncoding ? pe("mapTexelToLinear", r.mapEncoding) : "", r.matcapEncoding ? pe("matcapTexelToLinear", r.matcapEncoding) : "", r.envMapEncoding ? pe("envMapTexelToLinear", r.envMapEncoding) : "", r.emissiveMapEncoding ? pe("emissiveMapTexelToLinear", r.emissiveMapEncoding) : "", r.lightMapEncoding ? pe("lightMapTexelToLinear", r.lightMapEncoding) : "", r.outputEncoding ? fe("linearToOutputTexel", r.outputEncoding) : "", r.depthPacking ? "#define DEPTH_PACKING " + e.depthPacking : "", "\n"].filter(ge).join("\n")), h = ye(h = ve(h = h.replace(Js, _e), r), r), d = ye(d = ve(d = d.replace(Js, _e), r), r), h = h.replace($s, xe), d = d.replace($s, xe), r.isWebGL2 && !e.isRawShaderMaterial && (f = !1, p = /^\s*#version\s+300\s+es\s*\n/, e.isShaderMaterial && null !== h.match(p) && null !== d.match(p) && (f = !0, h = h.replace(p, ""), d = d.replace(p, "")), l = "#version 300 es\n\n#define attribute in\n#define varying out\n#define texture2D texture\n" + l, b = ["#version 300 es\n\n#define varying in", f ? "" : "out highp vec4 pc_fragColor;", f ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + b, 0 < w && (l = (l = l.replace("#version 300 es\n", ["#version 300 es\n\n#extension GL_OVR_multiview2 : require", "layout(num_views = " + w + ") in;", "#define VIEW_ID gl_ViewID_OVR"].join("\n"))).replace("uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;", ["uniform mat4 modelViewMatrices[" + w + "];", "uniform mat4 projectionMatrices[" + w + "];", "uniform mat4 viewMatrices[" + w + "];", "uniform mat3 normalMatrices[" + w + "];", "#define modelViewMatrix modelViewMatrices[VIEW_ID]\n#define projectionMatrix projectionMatrices[VIEW_ID]\n#define viewMatrix viewMatrices[VIEW_ID]\n#define normalMatrix normalMatrices[VIEW_ID]"].join("\n")), b = (b = b.replace("#version 300 es\n", "#version 300 es\n\n#extension GL_OVR_multiview2 : require\n#define VIEW_ID gl_ViewID_OVR")).replace("uniform mat4 viewMatrix;", ["uniform mat4 viewMatrices[" + w + "];", "#define viewMatrix viewMatrices[VIEW_ID]"].join("\n")))), d = b + d, h = le(g, 35633, l + h), d = le(g, 35632, d), g.attachShader(x, h), g.attachShader(x, d), void 0 !== e.index0AttributeName ? g.bindAttribLocation(x, 0, e.index0AttributeName) : !0 === r.morphTargets && g.bindAttribLocation(x, 0, "position"), g.linkProgram(x), a.debug.checkShaderErrors && (a = g.getProgramInfoLog(x).trim(), r = g.getShaderInfoLog(h).trim(), f = g.getShaderInfoLog(d).trim(), m = p = !0, !1 === g.getProgramParameter(x, 35714) ? (p = !1, v = de(g, h, "vertex"), y = de(g, d, "fragment"), console.error("THREE.WebGLProgram: shader error: ", g.getError(), "35715", g.getProgramParameter(x, 35715), "gl.getProgramInfoLog", a, v, y)) : "" !== a ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", a) : "" !== r && "" !== f || (m = !1), m && (this.diagnostics = {
                        runnable: p,
                        material: e,
                        programLog: a,
                        vertexShader: {
                            log: r,
                            prefix: l
                        },
                        fragmentShader: {
                            log: f,
                            prefix: b
                        }
                    })), g.deleteShader(h), g.deleteShader(d), this.getUniforms = function () {
                        return void 0 === o && (o = new ce(g, x)), o
                    }, this.getAttributes = function () {
                        if (void 0 === c) {
                            for (var a = {}, b = g.getProgramParameter(x, 35721), t = 0; t < b; t++) {
                                var e = g.getActiveAttrib(x, t).name;
                                a[e] = g.getAttribLocation(x, e)
                            }
                            c = a
                        }
                        return c
                    }, this.destroy = function () {
                        g.deleteProgram(x), this.program = void 0
                    }, this.name = n.name, this.id = Zs++, this.cacheKey = t, this.usedTimes = 1, this.program = x, this.vertexShader = h, this.fragmentShader = d, this.numMultiviewViews = w, this
                }

                function Me(a, b, t) {
                    function e(a) {
                        if (a) a.isTexture ? b = a.encoding : a.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), b = a.texture.encoding);
                        else var b = 3e3;
                        return b
                    }
                    var n = [],
                        r = t.isWebGL2,
                        g = t.logarithmicDepthBuffer,
                        o = t.floatVertexTextures,
                        c = t.precision,
                        l = t.maxVertexUniforms,
                        h = t.vertexTextures,
                        p = {
                            MeshDepthMaterial: "depth",
                            MeshDistanceMaterial: "distanceRGBA",
                            MeshNormalMaterial: "normal",
                            MeshBasicMaterial: "basic",
                            MeshLambertMaterial: "lambert",
                            MeshPhongMaterial: "phong",
                            MeshToonMaterial: "toon",
                            MeshStandardMaterial: "physical",
                            MeshPhysicalMaterial: "physical",
                            MeshMatcapMaterial: "matcap",
                            LineBasicMaterial: "basic",
                            LineDashedMaterial: "dashed",
                            PointsMaterial: "points",
                            ShadowMaterial: "shadow",
                            SpriteMaterial: "sprite"
                        },
                        d = "precision isWebGL2 supportsVertexTextures outputEncoding instancing numMultiviewViews map mapEncoding matcap matcapEncoding envMap envMapMode envMapEncoding envMapCubeUV lightMap lightMapEncoding aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap tangentSpaceNormalMap clearcoatNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors vertexTangents vertexUvs uvsVertexOnly fog useFog fogExp2 flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights numDirLightShadows numPointLightShadows numSpotLightShadows shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering sheen".split(" ");
                    this.getParameters = function (b, n, d, q, f, m, v) {
                        var y = q.fog;
                        q = b.isMeshStandardMaterial ? q.environment : null, q = b.envMap || q;
                        var _ = p[b.type];
                        if (v.isSkinnedMesh) {
                            var u = v.skeleton.bones;
                            if (o) u = 1024;
                            else {
                                var x = Math.min(Math.floor((l - 20) / 4), u.length);
                                x < u.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + u.length + " bones. This GPU supports " + x + "."), u = 0) : u = x
                            }
                        } else u = 0;
                        return null !== b.precision && (c = t.getMaxPrecision(b.precision)) !== b.precision && console.warn("THREE.WebGLProgram.getParameters:", b.precision, "not supported, using", c, "instead."), x = a.getRenderTarget(), {
                            isWebGL2: r,
                            shaderID: _,
                            precision: c,
                            instancing: !0 === v.isInstancedMesh,
                            supportsVertexTextures: h,
                            numMultiviewViews: x && x.isWebGLMultiviewRenderTarget ? x.numViews : 0,
                            outputEncoding: null !== x ? e(x.texture) : a.outputEncoding,
                            map: !!b.map,
                            mapEncoding: e(b.map),
                            matcap: !!b.matcap,
                            matcapEncoding: e(b.matcap),
                            envMap: !!q,
                            envMapMode: q && q.mapping,
                            envMapEncoding: e(q),
                            envMapCubeUV: !!q && (306 === q.mapping || 307 === q.mapping),
                            lightMap: !!b.lightMap,
                            lightMapEncoding: e(b.lightMap),
                            aoMap: !!b.aoMap,
                            emissiveMap: !!b.emissiveMap,
                            emissiveMapEncoding: e(b.emissiveMap),
                            bumpMap: !!b.bumpMap,
                            normalMap: !!b.normalMap,
                            objectSpaceNormalMap: 1 === b.normalMapType,
                            tangentSpaceNormalMap: 0 === b.normalMapType,
                            clearcoatNormalMap: !!b.clearcoatNormalMap,
                            displacementMap: !!b.displacementMap,
                            roughnessMap: !!b.roughnessMap,
                            metalnessMap: !!b.metalnessMap,
                            specularMap: !!b.specularMap,
                            alphaMap: !!b.alphaMap,
                            gradientMap: !!b.gradientMap,
                            sheen: !!b.sheen,
                            combine: b.combine,
                            vertexTangents: b.normalMap && b.vertexTangents,
                            vertexColors: b.vertexColors,
                            vertexUvs: !!(b.map || b.bumpMap || b.normalMap || b.specularMap || b.alphaMap || b.emissiveMap || b.roughnessMap || b.metalnessMap || b.clearcoatNormalMap || b.displacementMap),
                            uvsVertexOnly: !(b.map || b.bumpMap || b.normalMap || b.specularMap || b.alphaMap || b.emissiveMap || b.roughnessMap || b.metalnessMap || b.clearcoatNormalMap || !b.displacementMap),
                            fog: !!y,
                            useFog: b.fog,
                            fogExp2: y && y.isFogExp2,
                            flatShading: b.flatShading,
                            sizeAttenuation: b.sizeAttenuation,
                            logarithmicDepthBuffer: g,
                            skinning: b.skinning && 0 < u,
                            maxBones: u,
                            useVertexTexture: o,
                            morphTargets: b.morphTargets,
                            morphNormals: b.morphNormals,
                            maxMorphTargets: a.maxMorphTargets,
                            maxMorphNormals: a.maxMorphNormals,
                            numDirLights: n.directional.length,
                            numPointLights: n.point.length,
                            numSpotLights: n.spot.length,
                            numRectAreaLights: n.rectArea.length,
                            numHemiLights: n.hemi.length,
                            numDirLightShadows: n.directionalShadowMap.length,
                            numPointLightShadows: n.pointShadowMap.length,
                            numSpotLightShadows: n.spotShadowMap.length,
                            numClippingPlanes: f,
                            numClipIntersection: m,
                            dithering: b.dithering,
                            shadowMapEnabled: a.shadowMap.enabled && 0 < d.length,
                            shadowMapType: a.shadowMap.type,
                            toneMapping: b.toneMapped ? a.toneMapping : 0,
                            physicallyCorrectLights: a.physicallyCorrectLights,
                            premultipliedAlpha: b.premultipliedAlpha,
                            alphaTest: b.alphaTest,
                            doubleSided: 2 === b.side,
                            flipSided: 1 === b.side,
                            depthPacking: void 0 !== b.depthPacking && b.depthPacking
                        }
                    }, this.getProgramCacheKey = function (b, t) {
                        var e = [];
                        if (t.shaderID ? e.push(t.shaderID) : (e.push(b.fragmentShader), e.push(b.vertexShader)), void 0 !== b.defines)
                            for (var n in b.defines) e.push(n), e.push(b.defines[n]);
                        if (void 0 === b.isRawShaderMaterial) {
                            for (n = 0; n < d.length; n++) e.push(t[d[n]]);
                            e.push(a.outputEncoding), e.push(a.gammaFactor)
                        }
                        return e.push(b.onBeforeCompile.toString()), e.join()
                    }, this.acquireProgram = function (t, e, r, g) {
                        for (var o, c = 0, l = n.length; c < l; c++) {
                            var p = n[c];
                            if (p.cacheKey === g) {
                                ++(o = p).usedTimes;
                                break
                            }
                        }
                        return void 0 === o && (o = new we(a, b, g, t, e, r), n.push(o)), o
                    }, this.releaseProgram = function (a) {
                        if (0 == --a.usedTimes) {
                            var b = n.indexOf(a);
                            n[b] = n[n.length - 1], n.pop(), a.destroy()
                        }
                    }, this.programs = n
                }

                function Ee() {
                    var a = new WeakMap;
                    return {
                        get: function (b) {
                            var t = a.get(b);
                            return void 0 === t && (t = {}, a.set(b, t)), t
                        },
                        remove: function (b) {
                            a.delete(b)
                        },
                        update: function (b, t, e) {
                            a.get(b)[t] = e
                        },
                        dispose: function () {
                            a = new WeakMap
                        }
                    }
                }

                function Te(a, b) {
                    return a.groupOrder !== b.groupOrder ? a.groupOrder - b.groupOrder : a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.program !== b.program ? a.program.id - b.program.id : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id
                }

                function De(a, b) {
                    return a.groupOrder !== b.groupOrder ? a.groupOrder - b.groupOrder : a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id
                }

                function Se() {
                    function a(a, e, n, o, c, p) {
                        var g = b[t];
                        return void 0 === g ? (g = {
                            id: a.id,
                            object: a,
                            geometry: e,
                            material: n,
                            program: n.program || r,
                            groupOrder: o,
                            renderOrder: a.renderOrder,
                            z: c,
                            group: p
                        }, b[t] = g) : (g.id = a.id, g.object = a, g.geometry = e, g.material = n, g.program = n.program || r, g.groupOrder = o, g.renderOrder = a.renderOrder, g.z = c, g.group = p), t++, g
                    }
                    var b = [],
                        t = 0,
                        e = [],
                        n = [],
                        r = {
                            id: -1
                        };
                    return {
                        opaque: e,
                        transparent: n,
                        init: function () {
                            t = 0, e.length = 0, n.length = 0
                        },
                        push: function (b, t, r, o, c, p) {
                            b = a(b, t, r, o, c, p), (!0 === r.transparent ? n : e).push(b)
                        },
                        unshift: function (b, t, r, o, c, p) {
                            b = a(b, t, r, o, c, p), (!0 === r.transparent ? n : e).unshift(b)
                        },
                        sort: function (a, b) {
                            1 < e.length && e.sort(a || Te), 1 < n.length && n.sort(b || De)
                        }
                    }
                }

                function Ae() {
                    function a(t) {
                        (t = t.target).removeEventListener("dispose", a), b.delete(t)
                    }
                    var b = new WeakMap;
                    return {
                        get: function (t, e) {
                            var n = b.get(t);
                            if (void 0 === n) {
                                var r = new Se;
                                b.set(t, new WeakMap), b.get(t).set(e, r), t.addEventListener("dispose", a)
                            } else void 0 === (r = n.get(e)) && (r = new Se, n.set(e, r));
                            return r
                        },
                        dispose: function () {
                            b = new WeakMap
                        }
                    }
                }

                function Ce() {
                    var a = {};
                    return {
                        get: function (b) {
                            if (void 0 !== a[b.id]) return a[b.id];
                            switch (b.type) {
                                case "DirectionalLight":
                                    var t = {
                                        direction: new o,
                                        color: new A,
                                        shadow: !1,
                                        shadowBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new n
                                    };
                                    break;
                                case "SpotLight":
                                    t = {
                                        position: new o,
                                        direction: new o,
                                        color: new A,
                                        distance: 0,
                                        coneCos: 0,
                                        penumbraCos: 0,
                                        decay: 0,
                                        shadow: !1,
                                        shadowBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new n
                                    };
                                    break;
                                case "PointLight":
                                    t = {
                                        position: new o,
                                        color: new A,
                                        distance: 0,
                                        decay: 0,
                                        shadow: !1,
                                        shadowBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new n,
                                        shadowCameraNear: 1,
                                        shadowCameraFar: 1e3
                                    };
                                    break;
                                case "HemisphereLight":
                                    t = {
                                        direction: new o,
                                        skyColor: new A,
                                        groundColor: new A
                                    };
                                    break;
                                case "RectAreaLight":
                                    t = {
                                        color: new A,
                                        position: new o,
                                        halfWidth: new o,
                                        halfHeight: new o
                                    }
                            }
                            return a[b.id] = t
                        }
                    }
                }

                function Le(a, b) {
                    return (b.castShadow ? 1 : 0) - (a.castShadow ? 1 : 0)
                }

                function Re() {
                    for (var a = new Ce, b = {
                            version: 0,
                            hash: {
                                directionalLength: -1,
                                pointLength: -1,
                                spotLength: -1,
                                rectAreaLength: -1,
                                hemiLength: -1,
                                numDirectionalShadows: -1,
                                numPointShadows: -1,
                                numSpotShadows: -1
                            },
                            ambient: [0, 0, 0],
                            probe: [],
                            directional: [],
                            directionalShadowMap: [],
                            directionalShadowMatrix: [],
                            spot: [],
                            spotShadowMap: [],
                            spotShadowMatrix: [],
                            rectArea: [],
                            point: [],
                            pointShadowMap: [],
                            pointShadowMatrix: [],
                            hemi: [],
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1
                        }, t = 0; 9 > t; t++) b.probe.push(new o);
                    var e = new o,
                        n = new m,
                        r = new m;
                    return {
                        setup: function (t, o, c) {
                            for (var g = 0, l = 0, p = 0, h = 0; 9 > h; h++) b.probe[h].set(0, 0, 0);
                            var d = o = 0,
                                f = 0,
                                u = 0,
                                m = 0,
                                v = 0,
                                y = 0,
                                _ = 0;
                            c = c.matrixWorldInverse, t.sort(Le), h = 0;
                            for (var x = t.length; h < x; h++) {
                                var w = t[h],
                                    M = w.color,
                                    E = w.intensity,
                                    T = w.distance,
                                    D = w.shadow && w.shadow.map ? w.shadow.map.texture : null;
                                if (w.isAmbientLight) g += M.r * E, l += M.g * E, p += M.b * E;
                                else if (w.isLightProbe)
                                    for (D = 0; 9 > D; D++) b.probe[D].addScaledVector(w.sh.coefficients[D], E);
                                else if (w.isDirectionalLight) {
                                    var S = a.get(w);
                                    S.color.copy(w.color).multiplyScalar(w.intensity), S.direction.setFromMatrixPosition(w.matrixWorld), e.setFromMatrixPosition(w.target.matrixWorld), S.direction.sub(e), S.direction.transformDirection(c), (S.shadow = w.castShadow) && (E = w.shadow, S.shadowBias = E.bias, S.shadowRadius = E.radius, S.shadowMapSize = E.mapSize, b.directionalShadowMap[o] = D, b.directionalShadowMatrix[o] = w.shadow.matrix, v++), b.directional[o] = S, o++
                                } else w.isSpotLight ? ((S = a.get(w)).position.setFromMatrixPosition(w.matrixWorld), S.position.applyMatrix4(c), S.color.copy(M).multiplyScalar(E), S.distance = T, S.direction.setFromMatrixPosition(w.matrixWorld), e.setFromMatrixPosition(w.target.matrixWorld), S.direction.sub(e), S.direction.transformDirection(c), S.coneCos = Math.cos(w.angle), S.penumbraCos = Math.cos(w.angle * (1 - w.penumbra)), S.decay = w.decay, (S.shadow = w.castShadow) && (E = w.shadow, S.shadowBias = E.bias, S.shadowRadius = E.radius, S.shadowMapSize = E.mapSize, b.spotShadowMap[f] = D, b.spotShadowMatrix[f] = w.shadow.matrix, _++), b.spot[f] = S, f++) : w.isRectAreaLight ? ((S = a.get(w)).color.copy(M).multiplyScalar(E), S.position.setFromMatrixPosition(w.matrixWorld), S.position.applyMatrix4(c), r.identity(), n.copy(w.matrixWorld), n.premultiply(c), r.extractRotation(n), S.halfWidth.set(.5 * w.width, 0, 0), S.halfHeight.set(0, .5 * w.height, 0), S.halfWidth.applyMatrix4(r), S.halfHeight.applyMatrix4(r), b.rectArea[u] = S, u++) : w.isPointLight ? ((S = a.get(w)).position.setFromMatrixPosition(w.matrixWorld), S.position.applyMatrix4(c), S.color.copy(w.color).multiplyScalar(w.intensity), S.distance = w.distance, S.decay = w.decay, (S.shadow = w.castShadow) && (E = w.shadow, S.shadowBias = E.bias, S.shadowRadius = E.radius, S.shadowMapSize = E.mapSize, S.shadowCameraNear = E.camera.near, S.shadowCameraFar = E.camera.far, b.pointShadowMap[d] = D, b.pointShadowMatrix[d] = w.shadow.matrix, y++), b.point[d] = S, d++) : w.isHemisphereLight && ((S = a.get(w)).direction.setFromMatrixPosition(w.matrixWorld), S.direction.transformDirection(c), S.direction.normalize(), S.skyColor.copy(w.color).multiplyScalar(E), S.groundColor.copy(w.groundColor).multiplyScalar(E), b.hemi[m] = S, m++)
                            }
                            b.ambient[0] = g, b.ambient[1] = l, b.ambient[2] = p, (t = b.hash).directionalLength === o && t.pointLength === d && t.spotLength === f && t.rectAreaLength === u && t.hemiLength === m && t.numDirectionalShadows === v && t.numPointShadows === y && t.numSpotShadows === _ || (b.directional.length = o, b.spot.length = f, b.rectArea.length = u, b.point.length = d, b.hemi.length = m, b.directionalShadowMap.length = v, b.pointShadowMap.length = y, b.spotShadowMap.length = _, b.directionalShadowMatrix.length = v, b.pointShadowMatrix.length = y, b.spotShadowMatrix.length = _, t.directionalLength = o, t.pointLength = d, t.spotLength = f, t.rectAreaLength = u, t.hemiLength = m, t.numDirectionalShadows = v, t.numPointShadows = y, t.numSpotShadows = _, b.version = Qs++)
                        },
                        state: b
                    }
                }

                function Pe() {
                    var a = new Re,
                        b = [],
                        t = [];
                    return {
                        init: function () {
                            b.length = 0, t.length = 0
                        },
                        state: {
                            lightsArray: b,
                            shadowsArray: t,
                            lights: a
                        },
                        setupLights: function (e) {
                            a.setup(b, t, e)
                        },
                        pushLight: function (a) {
                            b.push(a)
                        },
                        pushShadow: function (a) {
                            t.push(a)
                        }
                    }
                }

                function Oe() {
                    function a(t) {
                        (t = t.target).removeEventListener("dispose", a), b.delete(t)
                    }
                    var b = new WeakMap;
                    return {
                        get: function (t, e) {
                            if (!1 === b.has(t)) {
                                var n = new Pe;
                                b.set(t, new WeakMap), b.get(t).set(e, n), t.addEventListener("dispose", a)
                            } else !1 === b.get(t).has(e) ? (n = new Pe, b.get(t).set(e, n)) : n = b.get(t).get(e);
                            return n
                        },
                        dispose: function () {
                            b = new WeakMap
                        }
                    }
                }

                function Fe(a) {
                    O.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(a)
                }

                function Ne(a) {
                    O.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new o, this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(a)
                }

                function Ie(a, b, t) {
                    function e(a, b, t) {
                        var e = p[t = a << 0 | b << 1 | t << 2];
                        return void 0 === e && (e = new Fe({
                            depthPacking: 3201,
                            morphTargets: a,
                            skinning: b
                        }), p[t] = e), e
                    }

                    function r(a, b, t) {
                        var e = v[t = a << 0 | b << 1 | t << 2];
                        return void 0 === e && (e = new Ne({
                            morphTargets: a,
                            skinning: b
                        }), v[t] = e), e
                    }

                    function o(b, t, n, g, o, c) {
                        var l = b.geometry,
                            p = e,
                            h = b.customDepthMaterial;
                        return !0 === n.isPointLight && (p = r, h = b.customDistanceMaterial), void 0 === h ? (h = !1, !0 === t.morphTargets && (!0 === l.isBufferGeometry ? h = l.morphAttributes && l.morphAttributes.position && 0 < l.morphAttributes.position.length : !0 === l.isGeometry && (h = l.morphTargets && 0 < l.morphTargets.length)), l = !1, !0 === b.isSkinnedMesh && (!0 === t.skinning ? l = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", b)), b = p(h, l, !0 === b.isInstancedMesh)) : b = h, a.localClippingEnabled && !0 === t.clipShadows && 0 !== t.clippingPlanes.length && (h = b.uuid, p = t.uuid, void 0 === (l = y[h]) && (l = {}, y[h] = l), void 0 === (h = l[p]) && (h = b.clone(), l[p] = h), b = h), b.visible = t.visible, b.wireframe = t.wireframe, b.side = 3 === c ? null !== t.shadowSide ? t.shadowSide : t.side : null !== t.shadowSide ? t.shadowSide : _[t.side], b.clipShadows = t.clipShadows, b.clippingPlanes = t.clippingPlanes, b.clipIntersection = t.clipIntersection, b.wireframeLinewidth = t.wireframeLinewidth, b.linewidth = t.linewidth, !0 === n.isPointLight && !0 === b.isMeshDistanceMaterial && (b.referencePosition.setFromMatrixPosition(n.matrixWorld), b.nearDistance = g, b.farDistance = o), b
                    }

                    function g(t, e, n, r, l) {
                        if (!1 !== t.visible) {
                            if (t.layers.test(e.layers) && (t.isMesh || t.isLine || t.isPoints) && (t.castShadow || t.receiveShadow && 3 === l) && (!t.frustumCulled || c.intersectsObject(t))) {
                                t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld);
                                var p = b.update(t),
                                    h = t.material;
                                if (Array.isArray(h))
                                    for (var d = p.groups, q = 0, f = d.length; q < f; q++) {
                                        var u = d[q],
                                            m = h[u.materialIndex];
                                        m && m.visible && (m = o(t, m, r, n.near, n.far, l), a.renderBufferDirect(n, null, p, m, t, u))
                                    } else h.visible && (m = o(t, h, r, n.near, n.far, l), a.renderBufferDirect(n, null, p, m, t, null))
                            }
                            for (p = 0, h = (t = t.children).length; p < h; p++) g(t[p], e, n, r, l)
                        }
                    }
                    var c = new ut,
                        l = new n,
                        f = new n,
                        m = new h,
                        p = [],
                        v = [],
                        y = {},
                        _ = {
                            0: 1,
                            1: 0,
                            2: 2
                        },
                        u = new et({
                            defines: {
                                SAMPLE_RATE: .25,
                                HALF_SAMPLE_RATE: .125
                            },
                            uniforms: {
                                shadow_pass: {
                                    value: null
                                },
                                resolution: {
                                    value: new n
                                },
                                radius: {
                                    value: 4
                                }
                            },
                            vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                            fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                        }),
                        x = u.clone();
                    x.defines.HORIZONAL_PASS = 1;
                    var w = new X;
                    w.setAttribute("position", new N(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                    var M = new Z(w, u),
                        E = this;
                    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function (e, n, r) {
                        if (!1 !== E.enabled && (!1 !== E.autoUpdate || !1 !== E.needsUpdate) && 0 !== e.length) {
                            var p = a.getRenderTarget(),
                                o = a.getActiveCubeFace(),
                                q = a.getActiveMipmapLevel(),
                                h = a.state;
                            h.setBlending(0), h.buffers.color.setClear(1, 1, 1, 1), h.buffers.depth.setTest(!0), h.setScissorTest(!1);
                            for (var v = 0, y = e.length; v < y; v++) {
                                var _ = e[v],
                                    w = _.shadow;
                                if (void 0 === w) console.warn("THREE.WebGLShadowMap:", _, "has no shadow.");
                                else {
                                    l.copy(w.mapSize);
                                    var T = w.getFrameExtents();
                                    l.multiply(T), f.copy(w.mapSize), (l.x > t || l.y > t) && (console.warn("THREE.WebGLShadowMap:", _, "has shadow exceeding max texture size, reducing"), l.x > t && (f.x = Math.floor(t / T.x), l.x = f.x * T.x, w.mapSize.x = f.x), l.y > t && (f.y = Math.floor(t / T.y), l.y = f.y * T.y, w.mapSize.y = f.y)), null !== w.map || w.isPointLightShadow || 3 !== this.type || (T = {
                                        minFilter: 1006,
                                        magFilter: 1006,
                                        format: 1023
                                    }, w.map = new d(l.x, l.y, T), w.map.texture.name = _.name + ".shadowMap", w.mapPass = new d(l.x, l.y, T), w.camera.updateProjectionMatrix()), null === w.map && (T = {
                                        minFilter: 1003,
                                        magFilter: 1003,
                                        format: 1023
                                    }, w.map = new d(l.x, l.y, T), w.map.texture.name = _.name + ".shadowMap", w.camera.updateProjectionMatrix()), a.setRenderTarget(w.map), a.clear(), T = w.getViewportCount();
                                    for (var D = 0; D < T; D++) {
                                        var S = w.getViewport(D);
                                        m.set(f.x * S.x, f.y * S.y, f.x * S.z, f.y * S.w), h.viewport(m), w.updateMatrices(_, D), c = w.getFrustum(), g(n, r, w.camera, _, this.type)
                                    }
                                    w.isPointLightShadow || 3 !== this.type || (_ = w, w = r, T = b.update(M), u.uniforms.shadow_pass.value = _.map.texture, u.uniforms.resolution.value = _.mapSize, u.uniforms.radius.value = _.radius, a.setRenderTarget(_.mapPass), a.clear(), a.renderBufferDirect(w, null, T, u, M, null), x.uniforms.shadow_pass.value = _.mapPass.texture, x.uniforms.resolution.value = _.mapSize, x.uniforms.radius.value = _.radius, a.setRenderTarget(_.map), a.clear(), a.renderBufferDirect(w, null, T, x, M, null))
                                }
                            }
                            E.needsUpdate = !1, a.setRenderTarget(p, o, q)
                        }
                    }
                }

                function Be(a, b, t) {
                    function e(b, t, e) {
                        var n = new Uint8Array(4),
                            r = a.createTexture();
                        for (a.bindTexture(b, r), a.texParameteri(b, 10241, 9728), a.texParameteri(b, 10240, 9728), b = 0; b < e; b++) a.texImage2D(t + b, 0, 6408, 1, 1, 0, 6408, 5121, n);
                        return r
                    }

                    function n(t, e) {
                        y[t] = 1, 0 === _[t] && (a.enableVertexAttribArray(t), _[t] = 1), x[t] !== e && ((f ? a : b.get("ANGLE_instanced_arrays"))[f ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](t, e), x[t] = e)
                    }

                    function r(b) {
                        !0 !== w[b] && (a.enable(b), w[b] = !0)
                    }

                    function g(b) {
                        !1 !== w[b] && (a.disable(b), w[b] = !1)
                    }

                    function o(b, t, e, n, o, c, l, p) {
                        if (0 === b) E && (g(3042), E = !1);
                        else if (E || (r(3042), E = !0), 5 !== b) {
                            if (b !== T || p !== P) {
                                if (100 === D && 100 === C || (a.blendEquation(32774), C = D = 100), p) switch (b) {
                                    case 1:
                                        a.blendFuncSeparate(1, 771, 1, 771);
                                        break;
                                    case 2:
                                        a.blendFunc(1, 1);
                                        break;
                                    case 3:
                                        a.blendFuncSeparate(0, 0, 769, 771);
                                        break;
                                    case 4:
                                        a.blendFuncSeparate(0, 768, 0, 770);
                                        break;
                                    default:
                                        console.error("THREE.WebGLState: Invalid blending: ", b)
                                } else switch (b) {
                                    case 1:
                                        a.blendFuncSeparate(770, 771, 1, 771);
                                        break;
                                    case 2:
                                        a.blendFunc(770, 1);
                                        break;
                                    case 3:
                                        a.blendFunc(0, 769);
                                        break;
                                    case 4:
                                        a.blendFunc(0, 768);
                                        break;
                                    default:
                                        console.error("THREE.WebGLState: Invalid blending: ", b)
                                }
                                R = L = A = S = null, T = b, P = p
                            }
                        } else o = o || t, c = c || e, l = l || n, t === D && o === C || (a.blendEquationSeparate(W[t], W[o]), D = t, C = o), e === S && n === A && c === L && l === R || (a.blendFuncSeparate(Y[e], Y[n], Y[c], Y[l]), S = e, A = n, L = c, R = l), T = b, P = null
                    }

                    function c(b) {
                        O !== b && (b ? a.frontFace(2304) : a.frontFace(2305), O = b)
                    }

                    function l(b) {
                        0 !== b ? (r(2884), b !== F && (1 === b ? a.cullFace(1029) : 2 === b ? a.cullFace(1028) : a.cullFace(1032))) : g(2884), F = b
                    }

                    function d(b, t, e) {
                        b ? (r(32823), (I !== t || B !== e) && (a.polygonOffset(t, e), I = t, B = e)) : g(32823)
                    }

                    function p(b) {
                        void 0 === b && (b = 33984 + k - 1), U !== b && (a.activeTexture(b), U = b)
                    }
                    var f = t.isWebGL2,
                        m = new function () {
                            var b = !1,
                                t = new h,
                                e = null,
                                n = new h(0, 0, 0, 0);
                            return {
                                setMask: function (t) {
                                    e === t || b || (a.colorMask(t, t, t, t), e = t)
                                },
                                setLocked: function (a) {
                                    b = a
                                },
                                setClear: function (b, e, r, g, o) {
                                    !0 === o && (b *= g, e *= g, r *= g), t.set(b, e, r, g), !1 === n.equals(t) && (a.clearColor(b, e, r, g), n.copy(t))
                                },
                                reset: function () {
                                    b = !1, e = null, n.set(-1, 0, 0, 0)
                                }
                            }
                        },
                        v = new function () {
                            var b = !1,
                                t = null,
                                e = null,
                                n = null;
                            return {
                                setTest: function (a) {
                                    a ? r(2929) : g(2929)
                                },
                                setMask: function (e) {
                                    t === e || b || (a.depthMask(e), t = e)
                                },
                                setFunc: function (b) {
                                    if (e !== b) {
                                        if (b) switch (b) {
                                            case 0:
                                                a.depthFunc(512);
                                                break;
                                            case 1:
                                                a.depthFunc(519);
                                                break;
                                            case 2:
                                                a.depthFunc(513);
                                                break;
                                            case 3:
                                                a.depthFunc(515);
                                                break;
                                            case 4:
                                                a.depthFunc(514);
                                                break;
                                            case 5:
                                                a.depthFunc(518);
                                                break;
                                            case 6:
                                                a.depthFunc(516);
                                                break;
                                            case 7:
                                                a.depthFunc(517);
                                                break;
                                            default:
                                                a.depthFunc(515)
                                        } else a.depthFunc(515);
                                        e = b
                                    }
                                },
                                setLocked: function (a) {
                                    b = a
                                },
                                setClear: function (b) {
                                    n !== b && (a.clearDepth(b), n = b)
                                },
                                reset: function () {
                                    b = !1, n = e = t = null
                                }
                            }
                        },
                        u = new function () {
                            var b = !1,
                                t = null,
                                e = null,
                                n = null,
                                o = null,
                                c = null,
                                l = null,
                                p = null,
                                h = null;
                            return {
                                setTest: function (a) {
                                    b || (a ? r(2960) : g(2960))
                                },
                                setMask: function (e) {
                                    t === e || b || (a.stencilMask(e), t = e)
                                },
                                setFunc: function (b, t, r) {
                                    e === b && n === t && o === r || (a.stencilFunc(b, t, r), e = b, n = t, o = r)
                                },
                                setOp: function (b, t, e) {
                                    c === b && l === t && p === e || (a.stencilOp(b, t, e), c = b, l = t, p = e)
                                },
                                setLocked: function (a) {
                                    b = a
                                },
                                setClear: function (b) {
                                    h !== b && (a.clearStencil(b), h = b)
                                },
                                reset: function () {
                                    b = !1, h = p = l = c = o = n = e = t = null
                                }
                            }
                        };
                    t = a.getParameter(34921);
                    var y = new Uint8Array(t),
                        _ = new Uint8Array(t),
                        x = new Uint8Array(t),
                        w = {},
                        M = null,
                        E = null,
                        T = null,
                        D = null,
                        S = null,
                        A = null,
                        C = null,
                        L = null,
                        R = null,
                        P = !1,
                        O = null,
                        F = null,
                        N = null,
                        I = null,
                        B = null,
                        k = a.getParameter(35661),
                        z = !1;
                    t = 0, -1 !== (t = a.getParameter(7938)).indexOf("WebGL") ? (t = parseFloat(/^WebGL ([0-9])/.exec(t)[1]), z = 1 <= t) : -1 !== t.indexOf("OpenGL ES") && (t = parseFloat(/^OpenGL ES ([0-9])/.exec(t)[1]), z = 2 <= t);
                    var U = null,
                        H = {},
                        G = new h,
                        V = new h,
                        j = {};
                    j[3553] = e(3553, 3553, 1), j[34067] = e(34067, 34069, 6), m.setClear(0, 0, 0, 1), v.setClear(1), u.setClear(0), r(2929), v.setFunc(3), c(!1), l(1), r(2884), o(0);
                    var W = {
                        100: 32774,
                        101: 32778,
                        102: 32779
                    };
                    f ? (W[103] = 32775, W[104] = 32776) : null !== (t = b.get("EXT_blend_minmax")) && (W[103] = t.MIN_EXT, W[104] = t.MAX_EXT);
                    var Y = {
                        200: 0,
                        201: 1,
                        202: 768,
                        204: 770,
                        210: 776,
                        208: 774,
                        206: 772,
                        203: 769,
                        205: 771,
                        209: 775,
                        207: 773
                    };
                    return {
                        buffers: {
                            color: m,
                            depth: v,
                            stencil: u
                        },
                        initAttributes: function () {
                            for (var a = 0, b = y.length; a < b; a++) y[a] = 0
                        },
                        enableAttribute: function (a) {
                            n(a, 0)
                        },
                        enableAttributeAndDivisor: n,
                        disableUnusedAttributes: function () {
                            for (var b = 0, t = _.length; b !== t; ++b) _[b] !== y[b] && (a.disableVertexAttribArray(b), _[b] = 0)
                        },
                        enable: r,
                        disable: g,
                        useProgram: function (b) {
                            return M !== b && (a.useProgram(b), M = b, !0)
                        },
                        setBlending: o,
                        setMaterial: function (a, b) {
                            2 === a.side ? g(2884) : r(2884);
                            var t = 1 === a.side;
                            b && (t = !t), c(t), 1 === a.blending && !1 === a.transparent ? o(0) : o(a.blending, a.blendEquation, a.blendSrc, a.blendDst, a.blendEquationAlpha, a.blendSrcAlpha, a.blendDstAlpha, a.premultipliedAlpha), v.setFunc(a.depthFunc), v.setTest(a.depthTest), v.setMask(a.depthWrite), m.setMask(a.colorWrite), b = a.stencilWrite, u.setTest(b), b && (u.setMask(a.stencilWriteMask), u.setFunc(a.stencilFunc, a.stencilRef, a.stencilFuncMask), u.setOp(a.stencilFail, a.stencilZFail, a.stencilZPass)), d(a.polygonOffset, a.polygonOffsetFactor, a.polygonOffsetUnits)
                        },
                        setFlipSided: c,
                        setCullFace: l,
                        setLineWidth: function (b) {
                            b !== N && (z && a.lineWidth(b), N = b)
                        },
                        setPolygonOffset: d,
                        setScissorTest: function (a) {
                            a ? r(3089) : g(3089)
                        },
                        activeTexture: p,
                        bindTexture: function (b, t) {
                            null === U && p();
                            var e = H[U];
                            void 0 === e && (e = {
                                type: void 0,
                                texture: void 0
                            }, H[U] = e), e.type === b && e.texture === t || (a.bindTexture(b, t || j[b]), e.type = b, e.texture = t)
                        },
                        unbindTexture: function () {
                            var b = H[U];
                            void 0 !== b && void 0 !== b.type && (a.bindTexture(b.type, null), b.type = void 0, b.texture = void 0)
                        },
                        compressedTexImage2D: function () {
                            try {
                                a.compressedTexImage2D.apply(a, arguments)
                            } catch (t) {
                                console.error("THREE.WebGLState:", t)
                            }
                        },
                        texImage2D: function () {
                            try {
                                a.texImage2D.apply(a, arguments)
                            } catch (t) {
                                console.error("THREE.WebGLState:", t)
                            }
                        },
                        texImage3D: function () {
                            try {
                                a.texImage3D.apply(a, arguments)
                            } catch (t) {
                                console.error("THREE.WebGLState:", t)
                            }
                        },
                        scissor: function (b) {
                            !1 === G.equals(b) && (a.scissor(b.x, b.y, b.z, b.w), G.copy(b))
                        },
                        viewport: function (b) {
                            !1 === V.equals(b) && (a.viewport(b.x, b.y, b.z, b.w), V.copy(b))
                        },
                        reset: function () {
                            for (var b = 0; b < _.length; b++) 1 === _[b] && (a.disableVertexAttribArray(b), _[b] = 0);
                            w = {}, U = null, H = {}, F = O = T = M = null, m.reset(), v.reset(), u.reset()
                        }
                    }
                }

                function ke(a, b, t, e, n, r, g) {
                    function o(a, b) {
                        return F ? new OffscreenCanvas(a, b) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
                    }

                    function c(a, b, t, e) {
                        var n = 1;
                        if ((a.width > e || a.height > e) && (n = e / Math.max(a.width, a.height)), 1 > n || !0 === b) {
                            if ("undefined" != typeof HTMLImageElement && a instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && a instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && a instanceof ImageBitmap) return b = (e = b ? Va.floorPowerOfTwo : Math.floor)(n * a.width), n = e(n * a.height), void 0 === S && (S = o(b, n)), (t = t ? o(b, n) : S).width = b, t.height = n, t.getContext("2d").drawImage(a, 0, 0, b, n), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + a.width + "x" + a.height + ") to (" + b + "x" + n + ")."), t;
                            "data" in a && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + a.width + "x" + a.height + ").")
                        }
                        return a
                    }

                    function l(a) {
                        return Va.isPowerOfTwo(a.width) && Va.isPowerOfTwo(a.height)
                    }

                    function h(a, b) {
                        return a.generateMipmaps && b && 1003 !== a.minFilter && 1006 !== a.minFilter
                    }

                    function p(b, t, n, r) {
                        a.generateMipmap(b), e.get(t).__maxMipLevel = Math.log(Math.max(n, r)) * Math.LOG2E
                    }

                    function d(t, e, n) {
                        if (!1 === A) return e;
                        if (null !== t) {
                            if (void 0 !== a[t]) return a[t];
                            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + t + "'")
                        }
                        return t = e, 6403 === e && (5126 === n && (t = 33326), 5131 === n && (t = 33325), 5121 === n && (t = 33321)), 6407 === e && (5126 === n && (t = 34837), 5131 === n && (t = 34843), 5121 === n && (t = 32849)), 6408 === e && (5126 === n && (t = 34836), 5131 === n && (t = 34842), 5121 === n && (t = 32856)), 33325 === t || 33326 === t || 34842 === t || 34836 === t ? b.get("EXT_color_buffer_float") : (34843 === t || 34837 === t) && console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."), t
                    }

                    function f(a) {
                        return 1003 === a || 1004 === a || 1005 === a ? 9728 : 9729
                    }

                    function m(b) {
                        (b = b.target).removeEventListener("dispose", m);
                        var t = e.get(b);
                        void 0 !== t.__webglInit && (a.deleteTexture(t.__webglTexture), e.remove(b)), b.isVideoTexture && O.delete(b), g.memory.textures--
                    }

                    function u(b) {
                        (b = b.target).removeEventListener("dispose", u);
                        var t = e.get(b),
                            n = e.get(b.texture);
                        if (b) {
                            if (void 0 !== n.__webglTexture && a.deleteTexture(n.__webglTexture), b.depthTexture && b.depthTexture.dispose(), b.isWebGLRenderTargetCube)
                                for (n = 0; 6 > n; n++) a.deleteFramebuffer(t.__webglFramebuffer[n]), t.__webglDepthbuffer && a.deleteRenderbuffer(t.__webglDepthbuffer[n]);
                            else a.deleteFramebuffer(t.__webglFramebuffer), t.__webglDepthbuffer && a.deleteRenderbuffer(t.__webglDepthbuffer);
                            if (b.isWebGLMultiviewRenderTarget) {
                                a.deleteTexture(t.__webglColorTexture), a.deleteTexture(t.__webglDepthStencilTexture), g.memory.textures -= 2, n = 0;
                                for (var r = t.__webglViewFramebuffers.length; n < r; n++) a.deleteFramebuffer(t.__webglViewFramebuffers[n])
                            }
                            e.remove(b.texture), e.remove(b)
                        }
                        g.memory.textures--
                    }

                    function v(a, b) {
                        var n = e.get(a);
                        if (a.isVideoTexture) {
                            var r = g.render.frame;
                            O.get(a) !== r && (O.set(a, r), a.update())
                        }
                        if (0 < a.version && n.__version !== a.version)
                            if (void 0 === (r = a.image)) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                            else {
                                if (!1 !== r.complete) return void M(n, a, b);
                                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                            } t.activeTexture(33984 + b), t.bindTexture(3553, n.__webglTexture)
                    }

                    function y(b, n) {
                        if (6 === b.image.length) {
                            var g = e.get(b);
                            if (0 < b.version && g.__version !== b.version) {
                                w(g, b), t.activeTexture(33984 + n), t.bindTexture(34067, g.__webglTexture), a.pixelStorei(37440, b.flipY);
                                var o = b && b.isCompressedTexture;
                                n = b.image[0] && b.image[0].isDataTexture;
                                for (var f = [], q = 0; 6 > q; q++) f[q] = o || n ? n ? b.image[q].image : b.image[q] : c(b.image[q], !1, !0, L);
                                var m = f[0],
                                    u = l(m) || A,
                                    v = r.convert(b.format),
                                    y = r.convert(b.type),
                                    _ = d(b.internalFormat, v, y);
                                if (x(34067, b, u), o) {
                                    for (q = 0; 6 > q; q++) {
                                        var M = f[q].mipmaps;
                                        for (o = 0; o < M.length; o++) {
                                            var E = M[o];
                                            1023 !== b.format && 1022 !== b.format ? null !== v ? t.compressedTexImage2D(34069 + q, o, _, E.width, E.height, 0, E.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : t.texImage2D(34069 + q, o, _, E.width, E.height, 0, v, y, E.data)
                                        }
                                    }
                                    g.__maxMipLevel = M.length - 1
                                } else {
                                    for (M = b.mipmaps, q = 0; 6 > q; q++)
                                        if (n)
                                            for (t.texImage2D(34069 + q, 0, _, f[q].width, f[q].height, 0, v, y, f[q].data), o = 0; o < M.length; o++) E = (E = M[o]).image[q].image, t.texImage2D(34069 + q, o + 1, _, E.width, E.height, 0, v, y, E.data);
                                        else
                                            for (t.texImage2D(34069 + q, 0, _, v, y, f[q]), o = 0; o < M.length; o++) E = M[o], t.texImage2D(34069 + q, o + 1, _, v, y, E.image[q]);
                                    g.__maxMipLevel = M.length
                                }
                                h(b, u) && p(34067, b, m.width, m.height), g.__version = b.version, b.onUpdate && b.onUpdate(b)
                            } else t.activeTexture(33984 + n), t.bindTexture(34067, g.__webglTexture)
                        }
                    }

                    function _(a, b) {
                        t.activeTexture(33984 + b), t.bindTexture(34067, e.get(a).__webglTexture)
                    }

                    function x(t, r, g) {
                        g ? (a.texParameteri(t, 10242, I[r.wrapS]), a.texParameteri(t, 10243, I[r.wrapT]), 32879 !== t && 35866 !== t || a.texParameteri(t, 32882, I[r.wrapR]), a.texParameteri(t, 10240, B[r.magFilter]), a.texParameteri(t, 10241, B[r.minFilter])) : (a.texParameteri(t, 10242, 33071), a.texParameteri(t, 10243, 33071), 32879 !== t && 35866 !== t || a.texParameteri(t, 32882, 33071), 1001 === r.wrapS && 1001 === r.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), a.texParameteri(t, 10240, f(r.magFilter)), a.texParameteri(t, 10241, f(r.minFilter)), 1003 !== r.minFilter && 1006 !== r.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !(g = b.get("EXT_texture_filter_anisotropic")) || 1015 === r.type && null === b.get("OES_texture_float_linear") || 1016 === r.type && null === (A || b.get("OES_texture_half_float_linear")) || !(1 < r.anisotropy || e.get(r).__currentAnisotropy) || (a.texParameterf(t, g.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(r.anisotropy, n.getMaxAnisotropy())), e.get(r).__currentAnisotropy = r.anisotropy)
                    }

                    function w(b, t) {
                        void 0 === b.__webglInit && (b.__webglInit = !0, t.addEventListener("dispose", m), b.__webglTexture = a.createTexture(), g.memory.textures++)
                    }

                    function M(b, e, n) {
                        var g = 3553;
                        e.isDataTexture2DArray && (g = 35866), e.isDataTexture3D && (g = 32879), w(b, e), t.activeTexture(33984 + n), t.bindTexture(g, b.__webglTexture), a.pixelStorei(37440, e.flipY), a.pixelStorei(37441, e.premultiplyAlpha), a.pixelStorei(3317, e.unpackAlignment), n = (n = !A && (1001 !== e.wrapS || 1001 !== e.wrapT || 1003 !== e.minFilter && 1006 !== e.minFilter)) && !1 === l(e.image);
                        var o = l(n = c(e.image, n, !1, R)) || A,
                            q = r.convert(e.format),
                            f = r.convert(e.type),
                            m = d(e.internalFormat, q, f);
                        x(g, e, o);
                        var u = e.mipmaps;
                        if (e.isDepthTexture) {
                            if (m = 6402, 1015 === e.type) {
                                if (!1 === A) throw Error("Float Depth Texture only supported in WebGL2.0");
                                m = 36012
                            } else A && (m = 33189);
                            1026 === e.format && 6402 === m && 1012 !== e.type && 1014 !== e.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), e.type = 1012, f = r.convert(e.type)), 1027 === e.format && (m = 34041, 1020 !== e.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), e.type = 1020, f = r.convert(e.type))), t.texImage2D(3553, 0, m, n.width, n.height, 0, q, f, null)
                        } else if (e.isDataTexture)
                            if (0 < u.length && o) {
                                for (var v = 0, y = u.length; v < y; v++) {
                                    var _ = u[v];
                                    t.texImage2D(3553, v, m, _.width, _.height, 0, q, f, _.data)
                                }
                                e.generateMipmaps = !1, b.__maxMipLevel = u.length - 1
                            } else t.texImage2D(3553, 0, m, n.width, n.height, 0, q, f, n.data), b.__maxMipLevel = 0;
                        else if (e.isCompressedTexture) {
                            for (v = 0, y = u.length; v < y; v++) _ = u[v], 1023 !== e.format && 1022 !== e.format ? null !== q ? t.compressedTexImage2D(3553, v, m, _.width, _.height, 0, _.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : t.texImage2D(3553, v, m, _.width, _.height, 0, q, f, _.data);
                            b.__maxMipLevel = u.length - 1
                        } else if (e.isDataTexture2DArray) t.texImage3D(35866, 0, m, n.width, n.height, n.depth, 0, q, f, n.data), b.__maxMipLevel = 0;
                        else if (e.isDataTexture3D) t.texImage3D(32879, 0, m, n.width, n.height, n.depth, 0, q, f, n.data), b.__maxMipLevel = 0;
                        else if (0 < u.length && o) {
                            for (v = 0, y = u.length; v < y; v++) _ = u[v], t.texImage2D(3553, v, m, q, f, _);
                            e.generateMipmaps = !1, b.__maxMipLevel = u.length - 1
                        } else t.texImage2D(3553, 0, m, q, f, n), b.__maxMipLevel = 0;
                        h(e, o) && p(g, e, n.width, n.height), b.__version = e.version, e.onUpdate && e.onUpdate(e)
                    }

                    function E(b, n, g, o) {
                        var c = r.convert(n.texture.format),
                            l = r.convert(n.texture.type),
                            p = d(n.texture.internalFormat, c, l);
                        t.texImage2D(o, 0, p, n.width, n.height, 0, c, l, null), a.bindFramebuffer(36160, b), a.framebufferTexture2D(36160, g, o, e.get(n.texture).__webglTexture, 0), a.bindFramebuffer(36160, null)
                    }

                    function T(b, t, e) {
                        if (a.bindRenderbuffer(36161, b), t.depthBuffer && !t.stencilBuffer) e ? (e = D(t), a.renderbufferStorageMultisample(36161, e, 33189, t.width, t.height)) : a.renderbufferStorage(36161, 33189, t.width, t.height), a.framebufferRenderbuffer(36160, 36096, 36161, b);
                        else if (t.depthBuffer && t.stencilBuffer) e ? (e = D(t), a.renderbufferStorageMultisample(36161, e, 35056, t.width, t.height)) : a.renderbufferStorage(36161, 34041, t.width, t.height), a.framebufferRenderbuffer(36160, 33306, 36161, b);
                        else {
                            b = r.convert(t.texture.format);
                            var n = r.convert(t.texture.type);
                            b = d(t.texture.internalFormat, b, n), e ? (e = D(t), a.renderbufferStorageMultisample(36161, e, b, t.width, t.height)) : a.renderbufferStorage(36161, b, t.width, t.height)
                        }
                        a.bindRenderbuffer(36161, null)
                    }

                    function D(a) {
                        return A && a.isWebGLMultisampleRenderTarget ? Math.min(P, a.samples) : 0
                    }
                    var S, A = n.isWebGL2,
                        C = n.maxTextures,
                        L = n.maxCubemapSize,
                        R = n.maxTextureSize,
                        P = n.maxSamples,
                        O = new WeakMap,
                        F = !1;
                    try {
                        F = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
                    } catch (t) {}
                    var N = 0,
                        I = {
                            1e3: 10497,
                            1001: 33071,
                            1002: 33648
                        },
                        B = {
                            1003: 9728,
                            1004: 9984,
                            1005: 9986,
                            1006: 9729,
                            1007: 9985,
                            1008: 9987
                        },
                        k = !1,
                        z = !1;
                    this.allocateTextureUnit = function () {
                        var a = N;
                        return a >= C && console.warn("THREE.WebGLTextures: Trying to use " + a + " texture units while this GPU supports only " + C), N += 1, a
                    }, this.resetTextureUnits = function () {
                        N = 0
                    }, this.setTexture2D = v, this.setTexture2DArray = function (a, b) {
                        var n = e.get(a);
                        0 < a.version && n.__version !== a.version ? M(n, a, b) : (t.activeTexture(33984 + b), t.bindTexture(35866, n.__webglTexture))
                    }, this.setTexture3D = function (a, b) {
                        var n = e.get(a);
                        0 < a.version && n.__version !== a.version ? M(n, a, b) : (t.activeTexture(33984 + b), t.bindTexture(32879, n.__webglTexture))
                    }, this.setTextureCube = y, this.setTextureCubeDynamic = _, this.setupRenderTarget = function (n) {
                        var o = e.get(n),
                            c = e.get(n.texture);
                        n.addEventListener("dispose", u), c.__webglTexture = a.createTexture(), g.memory.textures++;
                        var q = !0 === n.isWebGLRenderTargetCube,
                            f = !0 === n.isWebGLMultisampleRenderTarget,
                            m = !0 === n.isWebGLMultiviewRenderTarget,
                            y = l(n) || A;
                        if (q) {
                            o.__webglFramebuffer = [];
                            for (var _ = 0; 6 > _; _++) o.__webglFramebuffer[_] = a.createFramebuffer()
                        } else if (o.__webglFramebuffer = a.createFramebuffer(), f)
                            if (A) {
                                o.__webglMultisampledFramebuffer = a.createFramebuffer(), o.__webglColorRenderbuffer = a.createRenderbuffer(), a.bindRenderbuffer(36161, o.__webglColorRenderbuffer), f = r.convert(n.texture.format);
                                var w = r.convert(n.texture.type);
                                f = d(n.texture.internalFormat, f, w), w = D(n), a.renderbufferStorageMultisample(36161, w, f, n.width, n.height), a.bindFramebuffer(36160, o.__webglMultisampledFramebuffer), a.framebufferRenderbuffer(36160, 36064, 36161, o.__webglColorRenderbuffer), a.bindRenderbuffer(36161, null), n.depthBuffer && (o.__webglDepthRenderbuffer = a.createRenderbuffer(), T(o.__webglDepthRenderbuffer, n, !0)), a.bindFramebuffer(36160, null)
                            } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                        else if (m) {
                            _ = n.width;
                            var M = n.height;
                            f = n.numViews, a.bindFramebuffer(36160, o.__webglFramebuffer);
                            var S = b.get("OVR_multiview2");
                            g.memory.textures += 2, w = a.createTexture(), a.bindTexture(35866, w), a.texParameteri(35866, 10240, 9728), a.texParameteri(35866, 10241, 9728), a.texImage3D(35866, 0, 32856, _, M, f, 0, 6408, 5121, null), S.framebufferTextureMultiviewOVR(36160, 36064, w, 0, 0, f);
                            var C = a.createTexture();
                            for (a.bindTexture(35866, C), a.texParameteri(35866, 10240, 9728), a.texParameteri(35866, 10241, 9728), a.texImage3D(35866, 0, 35056, _, M, f, 0, 34041, 34042, null), S.framebufferTextureMultiviewOVR(36160, 33306, C, 0, 0, f), M = Array(f), _ = 0; _ < f; ++_) M[_] = a.createFramebuffer(), a.bindFramebuffer(36160, M[_]), a.framebufferTextureLayer(36160, 36064, w, 0, _);
                            o.__webglColorTexture = w, o.__webglDepthStencilTexture = C, o.__webglViewFramebuffers = M, a.bindFramebuffer(36160, null), a.bindTexture(35866, null)
                        }
                        if (q) {
                            for (t.bindTexture(34067, c.__webglTexture), x(34067, n.texture, y), _ = 0; 6 > _; _++) E(o.__webglFramebuffer[_], n, 36064, 34069 + _);
                            h(n.texture, y) && p(34067, n.texture, n.width, n.height), t.bindTexture(34067, null)
                        } else m || (t.bindTexture(3553, c.__webglTexture), x(3553, n.texture, y), E(o.__webglFramebuffer, n, 36064, 3553), h(n.texture, y) && p(3553, n.texture, n.width, n.height), t.bindTexture(3553, null));
                        if (n.depthBuffer) {
                            if (o = e.get(n), c = !0 === n.isWebGLRenderTargetCube, n.depthTexture) {
                                if (c) throw Error("target.depthTexture not supported in Cube render targets");
                                if (n && n.isWebGLRenderTargetCube) throw Error("Depth Texture with cube render targets is not supported");
                                if (a.bindFramebuffer(36160, o.__webglFramebuffer), !n.depthTexture || !n.depthTexture.isDepthTexture) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                                if (e.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), v(n.depthTexture, 0), o = e.get(n.depthTexture).__webglTexture, 1026 === n.depthTexture.format) a.framebufferTexture2D(36160, 36096, 3553, o, 0);
                                else {
                                    if (1027 !== n.depthTexture.format) throw Error("Unknown depthTexture format");
                                    a.framebufferTexture2D(36160, 33306, 3553, o, 0)
                                }
                            } else if (c)
                                for (o.__webglDepthbuffer = [], c = 0; 6 > c; c++) a.bindFramebuffer(36160, o.__webglFramebuffer[c]), o.__webglDepthbuffer[c] = a.createRenderbuffer(), T(o.__webglDepthbuffer[c], n);
                            else a.bindFramebuffer(36160, o.__webglFramebuffer), o.__webglDepthbuffer = a.createRenderbuffer(), T(o.__webglDepthbuffer, n);
                            a.bindFramebuffer(36160, null)
                        }
                    }, this.updateRenderTargetMipmap = function (a) {
                        var b = a.texture,
                            n = l(a) || A;
                        if (h(b, n)) {
                            n = a.isWebGLRenderTargetCube ? 34067 : 3553;
                            var r = e.get(b).__webglTexture;
                            t.bindTexture(n, r), p(n, b, a.width, a.height), t.bindTexture(n, null)
                        }
                    }, this.updateMultisampleRenderTarget = function (b) {
                        if (b.isWebGLMultisampleRenderTarget)
                            if (A) {
                                var t = e.get(b);
                                a.bindFramebuffer(36008, t.__webglMultisampledFramebuffer), a.bindFramebuffer(36009, t.__webglFramebuffer), t = b.width;
                                var n = b.height,
                                    r = 16384;
                                b.depthBuffer && (r |= 256), b.stencilBuffer && (r |= 1024), a.blitFramebuffer(0, 0, t, n, 0, 0, t, n, r, 9728)
                            } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
                    }, this.safeSetTexture2D = function (a, b) {
                        a && a.isWebGLRenderTarget && (!1 === k && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), k = !0), a = a.texture), v(a, b)
                    }, this.safeSetTextureCube = function (a, b) {
                        a && a.isWebGLRenderTargetCube && (!1 === z && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), z = !0), a = a.texture), a && a.isCubeTexture || Array.isArray(a.image) && 6 === a.image.length ? y(a, b) : _(a, b)
                    }
                }

                function ze(a, b, t) {
                    var e = t.isWebGL2;
                    return {
                        convert: function (a) {
                            if (1009 === a) return 5121;
                            if (1017 === a) return 32819;
                            if (1018 === a) return 32820;
                            if (1019 === a) return 33635;
                            if (1010 === a) return 5120;
                            if (1011 === a) return 5122;
                            if (1012 === a) return 5123;
                            if (1013 === a) return 5124;
                            if (1014 === a) return 5125;
                            if (1015 === a) return 5126;
                            if (1016 === a) {
                                if (e) return 5131;
                                var t = b.get("OES_texture_half_float");
                                return null !== t ? t.HALF_FLOAT_OES : null
                            }
                            if (1021 === a) return 6406;
                            if (1022 === a) return 6407;
                            if (1023 === a) return 6408;
                            if (1024 === a) return 6409;
                            if (1025 === a) return 6410;
                            if (1026 === a) return 6402;
                            if (1027 === a) return 34041;
                            if (1028 === a) return 6403;
                            if (1029 === a) return 36244;
                            if (1030 === a) return 33319;
                            if (1031 === a) return 33320;
                            if (1032 === a) return 36248;
                            if (1033 === a) return 36249;
                            if (33776 === a || 33777 === a || 33778 === a || 33779 === a) {
                                if (null === (t = b.get("WEBGL_compressed_texture_s3tc"))) return null;
                                if (33776 === a) return t.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                if (33777 === a) return t.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                if (33778 === a) return t.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                if (33779 === a) return t.COMPRESSED_RGBA_S3TC_DXT5_EXT
                            }
                            if (35840 === a || 35841 === a || 35842 === a || 35843 === a) {
                                if (null === (t = b.get("WEBGL_compressed_texture_pvrtc"))) return null;
                                if (35840 === a) return t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                                if (35841 === a) return t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                                if (35842 === a) return t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                                if (35843 === a) return t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                            }
                            return 36196 === a ? null !== (t = b.get("WEBGL_compressed_texture_etc1")) ? t.COMPRESSED_RGB_ETC1_WEBGL : null : 37808 === a || 37809 === a || 37810 === a || 37811 === a || 37812 === a || 37813 === a || 37814 === a || 37815 === a || 37816 === a || 37817 === a || 37818 === a || 37819 === a || 37820 === a || 37821 === a ? null !== (t = b.get("WEBGL_compressed_texture_astc")) ? a : null : 1020 === a ? e ? 34042 : null !== (t = b.get("WEBGL_depth_texture")) ? t.UNSIGNED_INT_24_8_WEBGL : null : void 0
                        }
                    }
                }

                function Ue(a, b, t, e) {
                    d.call(this, a, b, e), this.stencilBuffer = this.depthBuffer = !1, this.numViews = t
                }

                function He(a, b) {
                    function t(a) {
                        return a.isArrayCamera ? a.cameras : (l[0] = a, l)
                    }
                    var g, e, r, o, l, p, h, d = a.extensions,
                        f = a.properties,
                        v = 0;
                    this.isAvailable = function () {
                        if (void 0 === h) {
                            var a = d.get("OVR_multiview2");
                            if (h = null !== a && !1 === b.getContextAttributes().antialias)
                                for (v = b.getParameter(a.MAX_VIEWS_OVR), g = new Ue(0, 0, 2), p = new n, o = [], r = [], l = [], a = 0; a < v; a++) o[a] = new m, r[a] = new c
                        }
                        return h
                    }, this.attachCamera = function (b) {
                        if (!1 !== function (a) {
                                if (void 0 === a.isArrayCamera) return !0;
                                if ((a = a.cameras).length > v) return !1;
                                for (var b = 1, t = a.length; b < t; b++)
                                    if (a[0].viewport.z !== a[b].viewport.z || a[0].viewport.w !== a[b].viewport.w) return !1;
                                return !0
                            }(b)) {
                            if ((e = a.getRenderTarget()) ? p.set(e.width, e.height) : a.getDrawingBufferSize(p), b.isArrayCamera) {
                                var t = b.cameras[0].viewport;
                                g.setSize(t.z, t.w), g.setNumViews(b.cameras.length)
                            } else g.setSize(p.x, p.y), g.setNumViews(2);
                            a.setRenderTarget(g)
                        }
                    }, this.detachCamera = function (t) {
                        if (g === a.getRenderTarget()) {
                            a.setRenderTarget(e);
                            var n = g,
                                r = n.numViews,
                                o = f.get(n).__webglViewFramebuffers,
                                c = n.width;
                            if (n = n.height, t.isArrayCamera)
                                for (var l = 0; l < r; l++) {
                                    var h = t.cameras[l].viewport,
                                        q = h.x,
                                        d = h.y,
                                        m = q + h.z;
                                    h = d + h.w, b.bindFramebuffer(36008, o[l]), b.blitFramebuffer(0, 0, c, n, q, d, m, h, 16384, 9728)
                                } else b.bindFramebuffer(36008, o[0]), b.blitFramebuffer(0, 0, c, n, 0, 0, p.x, p.y, 16384, 9728)
                        }
                    }, this.updateCameraProjectionMatricesUniform = function (a, e) {
                        a = t(a);
                        for (var n = 0; n < a.length; n++) o[n].copy(a[n].projectionMatrix);
                        e.setValue(b, "projectionMatrices", o)
                    }, this.updateCameraViewMatricesUniform = function (a, e) {
                        a = t(a);
                        for (var n = 0; n < a.length; n++) o[n].copy(a[n].matrixWorldInverse);
                        e.setValue(b, "viewMatrices", o)
                    }, this.updateObjectMatricesUniforms = function (a, e, n) {
                        e = t(e);
                        for (var c = 0; c < e.length; c++) o[c].multiplyMatrices(e[c].matrixWorldInverse, a.matrixWorld), r[c].getNormalMatrix(o[c]);
                        n.setValue(b, "modelViewMatrices", o), n.setValue(b, "normalMatrices", r)
                    }
                }

                function Ge(a) {
                    it.call(this), this.cameras = a || []
                }

                function Ve() {
                    _.call(this), this.type = "Group"
                }

                function je(a, b) {
                    function t(a) {
                        var b = v.get(a.inputSource);
                        b && b.dispatchEvent({
                            type: a.type
                        })
                    }

                    function e() {
                        v.forEach((function (a, b) {
                            a.dispatchEvent({
                                type: "disconnected",
                                data: b
                            }), a.visible = !1
                        })), v.clear(), a.setFramebuffer(null), a.setRenderTarget(a.getRenderTarget()), E.stop(), c.dispatchEvent({
                            type: "sessionend"
                        }), c.isPresenting = !1
                    }

                    function n(a) {
                        d = a, E.setContext(l), E.start(), c.dispatchEvent({
                            type: "sessionstart"
                        }), c.isPresenting = !0
                    }

                    function r(a) {
                        for (var b = l.inputSources, t = 0; t < m.length; t++) v.set(b[t], m[t]);
                        for (t = 0; t < a.removed.length; t++) {
                            b = a.removed[t];
                            var e = v.get(b);
                            e && (e.dispatchEvent({
                                type: "disconnected",
                                data: b
                            }), v.delete(b))
                        }
                        for (t = 0; t < a.added.length; t++) b = a.added[t], (e = v.get(b)) && e.dispatchEvent({
                            type: "connected",
                            data: b
                        })
                    }

                    function g(a, b) {
                        null === b ? a.matrixWorld.copy(a.matrix) : a.matrixWorld.multiplyMatrices(b.matrixWorld, a.matrix), a.matrixWorldInverse.getInverse(a.matrixWorld)
                    }
                    var c = this,
                        l = null,
                        d = null,
                        f = "local-floor",
                        p = null,
                        m = [],
                        v = new Map,
                        y = new it;
                    y.layers.enable(1), y.viewport = new h;
                    var u = new it;
                    u.layers.enable(2), u.viewport = new h;
                    var _ = new Ge([y, u]);
                    _.layers.enable(1), _.layers.enable(2), this.isPresenting = this.enabled = !1, this.getController = function (a) {
                        var b = m[a];
                        return void 0 === b && ((b = new Ve).matrixAutoUpdate = !1, b.visible = !1, m[a] = b), b
                    }, this.setFramebufferScaleFactor = function () {}, this.setReferenceSpaceType = function (a) {
                        f = a
                    }, this.getReferenceSpace = function () {
                        return d
                    }, this.getSession = function () {
                        return l
                    }, this.setSession = function (a) {
                        null !== (l = a) && (l.addEventListener("select", t), l.addEventListener("selectstart", t), l.addEventListener("selectend", t), l.addEventListener("squeeze", t), l.addEventListener("squeezestart", t), l.addEventListener("squeezeend", t), l.addEventListener("end", e), a = b.getContextAttributes(), a = new XRWebGLLayer(l, b, {
                            antialias: a.antialias,
                            alpha: a.alpha,
                            depth: a.depth,
                            stencil: a.stencil
                        }), l.updateRenderState({
                            baseLayer: a
                        }), l.requestReferenceSpace(f).then(n), l.addEventListener("inputsourceschange", r))
                    };
                    var x = new o,
                        w = new o;
                    this.getCamera = function (a) {
                        var b = a.parent,
                            t = _.cameras;
                        g(_, b);
                        for (var e = 0; e < t.length; e++) g(t[e], b);
                        for (a.matrixWorld.copy(_.matrixWorld), e = 0, b = (a = a.children).length; e < b; e++) a[e].updateMatrixWorld(!0);
                        x.setFromMatrixPosition(y.matrixWorld), w.setFromMatrixPosition(u.matrixWorld), e = x.distanceTo(w);
                        var n = y.projectionMatrix.elements,
                            r = u.projectionMatrix.elements,
                            o = n[14] / (n[10] - 1);
                        a = n[14] / (n[10] + 1), b = (n[9] + 1) / n[5], t = (n[9] - 1) / n[5];
                        var c = (n[8] - 1) / n[0],
                            l = (r[8] + 1) / r[0];
                        return r = o * c, n = o * l, c = (l = e / (-c + l)) * -c, y.matrixWorld.decompose(_.position, _.quaternion, _.scale), _.translateX(c), _.translateZ(l), _.matrixWorld.compose(_.position, _.quaternion, _.scale), _.matrixWorldInverse.getInverse(_.matrixWorld), o += l, l = a + l, _.projectionMatrix.makePerspective(r - c, n + (e - c), b * a / l * o, t * a / l * o, o, l), _
                    };
                    var M = null,
                        E = new ct;
                    E.setAnimationLoop((function (b, t) {
                        if (null !== (p = t.getViewerPose(d))) {
                            var e = p.views,
                                n = l.renderState.baseLayer;
                            a.setFramebuffer(n.framebuffer);
                            for (var r = 0; r < e.length; r++) {
                                var g = e[r],
                                    o = n.getViewport(g),
                                    c = _.cameras[r];
                                c.matrix.fromArray(g.transform.inverse.matrix).getInverse(c.matrix), c.projectionMatrix.fromArray(g.projectionMatrix), c.viewport.set(o.x, o.y, o.width, o.height), 0 === r && _.matrix.copy(c.matrix)
                            }
                        }
                        for (e = l.inputSources, r = 0; r < m.length; r++) n = m[r], (g = e[r]) && null !== (g = t.getPose(g.targetRaySpace, d)) ? (n.matrix.fromArray(g.transform.matrix), n.matrix.decompose(n.position, n.rotation, n.scale), n.visible = !0) : n.visible = !1;
                        M && M(b, t)
                    })), this.setAnimationLoop = function (a) {
                        M = a
                    }, this.dispose = function () {}
                }

                function We(a) {
                    var b;

                    function t() {
                        P = new yt(Gt), !1 === (O = new gt(Gt, P, a)).isWebGL2 && (P.get("WEBGL_depth_texture"), P.get("OES_texture_float"), P.get("OES_texture_half_float"), P.get("OES_texture_half_float_linear"), P.get("OES_standard_derivatives"), P.get("OES_element_index_uint"), P.get("ANGLE_instanced_arrays")), P.get("OES_texture_float_linear"), Z = new ze(Gt, P, O), (F = new Be(Gt, P, O)).scissor(Dt.copy(Ft).multiplyScalar(Lt).floor()), F.viewport(Tt.copy(Ot).multiplyScalar(Lt).floor()), N = new bt(Gt), I = new Ee, B = new ke(Gt, P, F, I, O, Z, N), k = new lt(Gt), z = new _t(Gt, k, N), U = new Et(Gt, z, k, N), W = new Mt(Gt), H = new Me(J, P, O), G = new Ae, V = new Oe, j = new ft(J, F, U, D), Y = new mt(Gt, P, N, O), X = new xt(Gt, P, N, O), N.programs = H.programs, J.capabilities = O, J.extensions = P, J.properties = I, J.renderLists = G, J.state = F, J.info = N
                    }

                    function e(a) {
                        a.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), $ = !0
                    }

                    function r() {
                        console.log("THREE.WebGLRenderer: Context Restored."), $ = !1, t()
                    }

                    function c(a) {
                        (a = a.target).removeEventListener("dispose", c), g(a), I.remove(a)
                    }

                    function g(a) {
                        var b = I.get(a).program;
                        a.program = void 0, void 0 !== b && H.releaseProgram(b)
                    }

                    function l(a, b, t, e) {
                        for (var n = 0, r = a.length; n < r; n++) {
                            var g = a[n],
                                o = g.object,
                                c = g.geometry,
                                l = void 0 === e ? g.material : e;
                            if (g = g.group, t.isArrayCamera)
                                if (wt = t, Vt.enabled && jt.isAvailable()) d(o, b, t, c, l, g);
                                else
                                    for (var p = t.cameras, h = 0, q = p.length; h < q; h++) {
                                        var f = p[h];
                                        o.layers.test(f.layers) && (F.viewport(Tt.copy(f.viewport)), R.setupLights(f), d(o, b, f, c, l, g))
                                    } else wt = null, d(o, b, t, c, l, g)
                        }
                    }

                    function d(a, t, e, n, r, g) {
                        if (a.onBeforeRender(J, t, e, n, r, g), R = V.get(t, wt || e), a.modelViewMatrix.multiplyMatrices(e.matrixWorldInverse, a.matrixWorld), a.normalMatrix.getNormalMatrix(a.modelViewMatrix), a.isImmediateRenderObject) {
                            var o = f(e, t, r, a);
                            F.setMaterial(r), ot = b = null, ht = !1,
                                function (a, b) {
                                    a.render((function (a) {
                                        J.renderBufferImmediate(a, b)
                                    }))
                                }(a, o)
                        } else J.renderBufferDirect(e, t, n, r, a, g);
                        a.onAfterRender(J, t, e, n, r, g), R = V.get(t, wt || e)
                    }

                    function p(a, b, t) {
                        var e = I.get(a),
                            n = R.state.lights,
                            r = n.state.version;
                        t = H.getParameters(a, n.state, R.state.shadowsArray, b, Bt.numPlanes, Bt.numIntersection, t);
                        var o = H.getProgramCacheKey(a, t),
                            l = e.program,
                            p = !0;
                        if (void 0 === l) a.addEventListener("dispose", c);
                        else if (l.cacheKey !== o) g(a);
                        else {
                            if (e.lightsStateVersion !== r) e.lightsStateVersion = r;
                            else if (void 0 !== t.shaderID) return;
                            p = !1
                        }
                        if (p && (t.shaderID ? (o = ks[t.shaderID], e.shader = {
                                name: a.type,
                                uniforms: K(o.uniforms),
                                vertexShader: o.vertexShader,
                                fragmentShader: o.fragmentShader
                            }) : e.shader = {
                                name: a.type,
                                uniforms: a.uniforms,
                                vertexShader: a.vertexShader,
                                fragmentShader: a.fragmentShader
                            }, a.onBeforeCompile(e.shader, J), o = H.getProgramCacheKey(a, t), l = H.acquireProgram(a, e.shader, t, o), e.program = l, e.environment = a.isMeshStandardMaterial ? b.environment : null, e.outputEncoding = J.outputEncoding, a.program = l), t = l.getAttributes(), a.morphTargets)
                            for (o = a.numSupportedMorphTargets = 0; o < J.maxMorphTargets; o++) 0 <= t["morphTarget" + o] && a.numSupportedMorphTargets++;
                        if (a.morphNormals)
                            for (o = a.numSupportedMorphNormals = 0; o < J.maxMorphNormals; o++) 0 <= t["morphNormal" + o] && a.numSupportedMorphNormals++;
                        t = e.shader.uniforms, (a.isShaderMaterial || a.isRawShaderMaterial) && !0 !== a.clipping || (e.numClippingPlanes = Bt.numPlanes, e.numIntersection = Bt.numIntersection, t.clippingPlanes = Bt.uniform), e.fog = b.fog, e.needsLights = a.isMeshLambertMaterial || a.isMeshToonMaterial || a.isMeshPhongMaterial || a.isMeshStandardMaterial || a.isShadowMaterial || a.isShaderMaterial && !0 === a.lights, e.lightsStateVersion = r, e.needsLights && (t.ambientLightColor.value = n.state.ambient, t.lightProbe.value = n.state.probe, t.directionalLights.value = n.state.directional, t.spotLights.value = n.state.spot, t.rectAreaLights.value = n.state.rectArea, t.pointLights.value = n.state.point, t.hemisphereLights.value = n.state.hemi, t.directionalShadowMap.value = n.state.directionalShadowMap, t.directionalShadowMatrix.value = n.state.directionalShadowMatrix, t.spotShadowMap.value = n.state.spotShadowMap, t.spotShadowMatrix.value = n.state.spotShadowMatrix, t.pointShadowMap.value = n.state.pointShadowMap, t.pointShadowMatrix.value = n.state.pointShadowMatrix), a = e.program.getUniforms(), a = ce.seqWithValue(a.seq, t), e.uniformsList = a
                    }

                    function f(a, b, t, e) {
                        B.resetTextureUnits();
                        var n = b.fog,
                            r = t.isMeshStandardMaterial ? b.environment : null,
                            g = I.get(t),
                            o = R.state.lights;
                        kt && (zt || a !== pt) && Bt.setState(t.clippingPlanes, t.clipIntersection, t.clipShadows, a, g, a === pt && t.id === at), t.version === g.__version && (void 0 === g.program ? t.needsUpdate = !0 : t.fog && g.fog !== n ? t.needsUpdate = !0 : g.environment !== r ? t.needsUpdate = !0 : g.needsLights && g.lightsStateVersion !== o.state.version ? t.needsUpdate = !0 : void 0 === g.numClippingPlanes || g.numClippingPlanes === Bt.numPlanes && g.numIntersection === Bt.numIntersection ? g.outputEncoding !== J.outputEncoding && (t.needsUpdate = !0) : t.needsUpdate = !0), t.version !== g.__version && (p(t, b, e), g.__version = t.version);
                        var c = !1,
                            l = !1,
                            h = !1;
                        o = (b = g.program).getUniforms();
                        var d = g.shader.uniforms;
                        if (F.useProgram(b.program) && (h = l = c = !0), t.id !== at && (at = t.id, l = !0), (c || pt !== a) && (0 < b.numMultiviewViews ? jt.updateCameraProjectionMatricesUniform(a, o) : o.setValue(Gt, "projectionMatrix", a.projectionMatrix), O.logarithmicDepthBuffer && o.setValue(Gt, "logDepthBufFC", 2 / (Math.log(a.far + 1) / Math.LN2)), pt !== a && (pt = a, h = l = !0), (t.isShaderMaterial || t.isMeshPhongMaterial || t.isMeshToonMaterial || t.isMeshStandardMaterial || t.envMap) && void 0 !== (c = o.map.cameraPosition) && c.setValue(Gt, Ht.setFromMatrixPosition(a.matrixWorld)), (t.isMeshPhongMaterial || t.isMeshToonMaterial || t.isMeshLambertMaterial || t.isMeshBasicMaterial || t.isMeshStandardMaterial || t.isShaderMaterial) && o.setValue(Gt, "isOrthographic", !0 === a.isOrthographicCamera), (t.isMeshPhongMaterial || t.isMeshToonMaterial || t.isMeshLambertMaterial || t.isMeshBasicMaterial || t.isMeshStandardMaterial || t.isShaderMaterial || t.skinning) && (0 < b.numMultiviewViews ? jt.updateCameraViewMatricesUniform(a, o) : o.setValue(Gt, "viewMatrix", a.matrixWorldInverse))), t.skinning && (o.setOptional(Gt, e, "bindMatrix"), o.setOptional(Gt, e, "bindMatrixInverse"), c = e.skeleton)) {
                            var q = c.bones;
                            if (O.floatVertexTextures) {
                                if (void 0 === c.boneTexture) {
                                    q = Math.sqrt(4 * q.length), q = Va.ceilPowerOfTwo(q), q = Math.max(q, 4);
                                    var f = new Float32Array(q * q * 4);
                                    f.set(c.boneMatrices);
                                    var u = new st(f, q, q, 1023, 1015);
                                    c.boneMatrices = f, c.boneTexture = u, c.boneTextureSize = q
                                }
                                o.setValue(Gt, "boneTexture", c.boneTexture, B), o.setValue(Gt, "boneTextureSize", c.boneTextureSize)
                            } else o.setOptional(Gt, c, "boneMatrices")
                        }
                        if ((l || g.receiveShadow !== e.receiveShadow) && (g.receiveShadow = e.receiveShadow, o.setValue(Gt, "receiveShadow", e.receiveShadow)), l) {
                            if (o.setValue(Gt, "toneMappingExposure", J.toneMappingExposure), o.setValue(Gt, "toneMappingWhitePoint", J.toneMappingWhitePoint), g.needsLights && (l = h, d.ambientLightColor.needsUpdate = l, d.lightProbe.needsUpdate = l, d.directionalLights.needsUpdate = l, d.pointLights.needsUpdate = l, d.spotLights.needsUpdate = l, d.rectAreaLights.needsUpdate = l, d.hemisphereLights.needsUpdate = l), n && t.fog && (d.fogColor.value.copy(n.color), n.isFog ? (d.fogNear.value = n.near, d.fogFar.value = n.far) : n.isFogExp2 && (d.fogDensity.value = n.density)), t.isMeshBasicMaterial) v(d, t);
                            else if (t.isMeshLambertMaterial) v(d, t), t.emissiveMap && (d.emissiveMap.value = t.emissiveMap);
                            else if (t.isMeshToonMaterial) v(d, t), d.specular.value.copy(t.specular), d.shininess.value = Math.max(t.shininess, 1e-4), t.gradientMap && (d.gradientMap.value = t.gradientMap), t.emissiveMap && (d.emissiveMap.value = t.emissiveMap), t.bumpMap && (d.bumpMap.value = t.bumpMap, d.bumpScale.value = t.bumpScale, 1 === t.side && (d.bumpScale.value *= -1)), t.normalMap && (d.normalMap.value = t.normalMap, d.normalScale.value.copy(t.normalScale), 1 === t.side && d.normalScale.value.negate()), t.displacementMap && (d.displacementMap.value = t.displacementMap, d.displacementScale.value = t.displacementScale, d.displacementBias.value = t.displacementBias);
                            else if (t.isMeshPhongMaterial) v(d, t), d.specular.value.copy(t.specular), d.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (d.emissiveMap.value = t.emissiveMap), t.bumpMap && (d.bumpMap.value = t.bumpMap, d.bumpScale.value = t.bumpScale, 1 === t.side && (d.bumpScale.value *= -1)), t.normalMap && (d.normalMap.value = t.normalMap, d.normalScale.value.copy(t.normalScale), 1 === t.side && d.normalScale.value.negate()), t.displacementMap && (d.displacementMap.value = t.displacementMap, d.displacementScale.value = t.displacementScale, d.displacementBias.value = t.displacementBias);
                            else if (t.isMeshStandardMaterial) v(d, t, r), t.isMeshPhysicalMaterial ? (y(d, t, r), d.reflectivity.value = t.reflectivity, d.clearcoat.value = t.clearcoat, d.clearcoatRoughness.value = t.clearcoatRoughness, t.sheen && d.sheen.value.copy(t.sheen), t.clearcoatNormalMap && (d.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), d.clearcoatNormalMap.value = t.clearcoatNormalMap, 1 === t.side && d.clearcoatNormalScale.value.negate()), d.transparency.value = t.transparency) : y(d, t, r);
                            else if (t.isMeshMatcapMaterial) v(d, t), t.matcap && (d.matcap.value = t.matcap), t.bumpMap && (d.bumpMap.value = t.bumpMap, d.bumpScale.value = t.bumpScale, 1 === t.side && (d.bumpScale.value *= -1)), t.normalMap && (d.normalMap.value = t.normalMap, d.normalScale.value.copy(t.normalScale), 1 === t.side && d.normalScale.value.negate()), t.displacementMap && (d.displacementMap.value = t.displacementMap, d.displacementScale.value = t.displacementScale, d.displacementBias.value = t.displacementBias);
                            else if (t.isMeshDepthMaterial) v(d, t), t.displacementMap && (d.displacementMap.value = t.displacementMap, d.displacementScale.value = t.displacementScale, d.displacementBias.value = t.displacementBias);
                            else if (t.isMeshDistanceMaterial) v(d, t), t.displacementMap && (d.displacementMap.value = t.displacementMap, d.displacementScale.value = t.displacementScale, d.displacementBias.value = t.displacementBias), d.referencePosition.value.copy(t.referencePosition), d.nearDistance.value = t.nearDistance, d.farDistance.value = t.farDistance;
                            else if (t.isMeshNormalMaterial) v(d, t), t.bumpMap && (d.bumpMap.value = t.bumpMap, d.bumpScale.value = t.bumpScale, 1 === t.side && (d.bumpScale.value *= -1)), t.normalMap && (d.normalMap.value = t.normalMap, d.normalScale.value.copy(t.normalScale), 1 === t.side && d.normalScale.value.negate()), t.displacementMap && (d.displacementMap.value = t.displacementMap, d.displacementScale.value = t.displacementScale, d.displacementBias.value = t.displacementBias);
                            else if (t.isLineBasicMaterial) d.diffuse.value.copy(t.color), d.opacity.value = t.opacity, t.isLineDashedMaterial && (d.dashSize.value = t.dashSize, d.totalSize.value = t.dashSize + t.gapSize, d.scale.value = t.scale);
                            else if (t.isPointsMaterial) {
                                if (d.diffuse.value.copy(t.color), d.opacity.value = t.opacity, d.size.value = t.size * Lt, d.scale.value = .5 * Ct, t.map && (d.map.value = t.map), t.alphaMap && (d.alphaMap.value = t.alphaMap), t.map) var m = t.map;
                                else t.alphaMap && (m = t.alphaMap);
                                void 0 !== m && (!0 === m.matrixAutoUpdate && m.updateMatrix(), d.uvTransform.value.copy(m.matrix))
                            } else if (t.isSpriteMaterial) {
                                if (d.diffuse.value.copy(t.color), d.opacity.value = t.opacity, d.rotation.value = t.rotation, t.map && (d.map.value = t.map), t.alphaMap && (d.alphaMap.value = t.alphaMap), t.map) var _ = t.map;
                                else t.alphaMap && (_ = t.alphaMap);
                                void 0 !== _ && (!0 === _.matrixAutoUpdate && _.updateMatrix(), d.uvTransform.value.copy(_.matrix))
                            } else t.isShadowMaterial && (d.color.value.copy(t.color), d.opacity.value = t.opacity);
                            void 0 !== d.ltc_1 && (d.ltc_1.value = Bs.LTC_1), void 0 !== d.ltc_2 && (d.ltc_2.value = Bs.LTC_2), ce.upload(Gt, g.uniformsList, d, B), t.isShaderMaterial && (t.uniformsNeedUpdate = !1)
                        }
                        return t.isShaderMaterial && !0 === t.uniformsNeedUpdate && (ce.upload(Gt, g.uniformsList, d, B), t.uniformsNeedUpdate = !1), t.isSpriteMaterial && o.setValue(Gt, "center", e.center), 0 < b.numMultiviewViews ? jt.updateObjectMatricesUniforms(e, a, o) : (o.setValue(Gt, "modelViewMatrix", e.modelViewMatrix), o.setValue(Gt, "normalMatrix", e.normalMatrix)), o.setValue(Gt, "modelMatrix", e.matrixWorld), b
                    }

                    function v(a, b, t) {
                        if (a.opacity.value = b.opacity, b.color && a.diffuse.value.copy(b.color), b.emissive && a.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity), b.map && (a.map.value = b.map), b.alphaMap && (a.alphaMap.value = b.alphaMap), b.specularMap && (a.specularMap.value = b.specularMap), (t = b.envMap || t) && (a.envMap.value = t, a.flipEnvMap.value = t.isCubeTexture ? -1 : 1, a.reflectivity.value = b.reflectivity, a.refractionRatio.value = b.refractionRatio, a.maxMipLevel.value = I.get(t).__maxMipLevel), b.lightMap && (a.lightMap.value = b.lightMap, a.lightMapIntensity.value = b.lightMapIntensity), b.aoMap && (a.aoMap.value = b.aoMap, a.aoMapIntensity.value = b.aoMapIntensity), b.map) var e = b.map;
                        else b.specularMap ? e = b.specularMap : b.displacementMap ? e = b.displacementMap : b.normalMap ? e = b.normalMap : b.bumpMap ? e = b.bumpMap : b.roughnessMap ? e = b.roughnessMap : b.metalnessMap ? e = b.metalnessMap : b.alphaMap ? e = b.alphaMap : b.emissiveMap && (e = b.emissiveMap);
                        if (void 0 !== e && (e.isWebGLRenderTarget && (e = e.texture), !0 === e.matrixAutoUpdate && e.updateMatrix(), a.uvTransform.value.copy(e.matrix)), b.aoMap) var n = b.aoMap;
                        else b.lightMap && (n = b.lightMap);
                        void 0 !== n && (n.isWebGLRenderTarget && (n = n.texture), !0 === n.matrixAutoUpdate && n.updateMatrix(), a.uv2Transform.value.copy(n.matrix))
                    }

                    function y(a, b, t) {
                        a.roughness.value = b.roughness, a.metalness.value = b.metalness, b.roughnessMap && (a.roughnessMap.value = b.roughnessMap), b.metalnessMap && (a.metalnessMap.value = b.metalnessMap), b.emissiveMap && (a.emissiveMap.value = b.emissiveMap), b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale, 1 === b.side && (a.bumpScale.value *= -1)), b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale), 1 === b.side && a.normalScale.value.negate()), b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias), (b.envMap || t) && (a.envMapIntensity.value = b.envMapIntensity)
                    }
                    var u = void 0 !== (a = a || {}).canvas ? a.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                        _ = void 0 !== a.context ? a.context : null,
                        w = void 0 !== a.alpha && a.alpha,
                        M = void 0 === a.depth || a.depth,
                        E = void 0 === a.stencil || a.stencil,
                        T = void 0 !== a.antialias && a.antialias,
                        D = void 0 === a.premultipliedAlpha || a.premultipliedAlpha,
                        S = void 0 !== a.preserveDrawingBuffer && a.preserveDrawingBuffer,
                        A = void 0 !== a.powerPreference ? a.powerPreference : "default",
                        C = void 0 !== a.failIfMajorPerformanceCaveat && a.failIfMajorPerformanceCaveat,
                        L = null,
                        R = null;
                    this.domElement = u, this.debug = {
                        checkShaderErrors: !0
                    }, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = 3e3, this.physicallyCorrectLights = !1, this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
                    var P, O, F, N, I, B, k, z, U, H, G, V, j, W, Y, X, Z, J = this,
                        $ = !1,
                        Q = null,
                        tt = 0,
                        et = 0,
                        nt = null,
                        it = null,
                        at = -1,
                        ot = b = null,
                        ht = !1,
                        pt = null,
                        wt = null,
                        Tt = new h,
                        Dt = new h,
                        St = null,
                        At = u.width,
                        Ct = u.height,
                        Lt = 1,
                        Rt = null,
                        Pt = null,
                        Ot = new h(0, 0, At, Ct),
                        Ft = new h(0, 0, At, Ct),
                        Nt = !1,
                        It = new ut,
                        Bt = new vt,
                        kt = !1,
                        zt = !1,
                        Ut = new m,
                        Ht = new o;
                    try {
                        w = {
                            alpha: w,
                            depth: M,
                            stencil: E,
                            antialias: T,
                            premultipliedAlpha: D,
                            preserveDrawingBuffer: S,
                            powerPreference: A,
                            failIfMajorPerformanceCaveat: C,
                            xrCompatible: !0
                        }, u.addEventListener("webglcontextlost", e, !1), u.addEventListener("webglcontextrestored", r, !1);
                        var Gt = _ || u.getContext("webgl", w) || u.getContext("experimental-webgl", w);
                        if (null === Gt) {
                            if (null !== u.getContext("webgl")) throw Error("Error creating WebGL context with your selected attributes.");
                            throw Error("Error creating WebGL context.")
                        }
                        void 0 === Gt.getShaderPrecisionFormat && (Gt.getShaderPrecisionFormat = function () {
                            return {
                                rangeMin: 1,
                                rangeMax: 1,
                                precision: 1
                            }
                        })
                    } catch (t) {
                        throw console.error("THREE.WebGLRenderer: " + t.message), t
                    }
                    t();
                    var Vt = new je(J, Gt);
                    this.xr = Vt;
                    var jt = new He(J, Gt),
                        Wt = new Ie(J, U, O.maxTextureSize);
                    this.shadowMap = Wt, this.getContext = function () {
                        return Gt
                    }, this.getContextAttributes = function () {
                        return Gt.getContextAttributes()
                    }, this.forceContextLoss = function () {
                        var a = P.get("WEBGL_lose_context");
                        a && a.loseContext()
                    }, this.forceContextRestore = function () {
                        var a = P.get("WEBGL_lose_context");
                        a && a.restoreContext()
                    }, this.getPixelRatio = function () {
                        return Lt
                    }, this.setPixelRatio = function (a) {
                        void 0 !== a && (Lt = a, this.setSize(At, Ct, !1))
                    }, this.getSize = function (a) {
                        return void 0 === a && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), a = new n), a.set(At, Ct)
                    }, this.setSize = function (a, b, t) {
                        Vt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (At = a, Ct = b, u.width = Math.floor(a * Lt), u.height = Math.floor(b * Lt), !1 !== t && (u.style.width = a + "px", u.style.height = b + "px"), this.setViewport(0, 0, a, b))
                    }, this.getDrawingBufferSize = function (a) {
                        return void 0 === a && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), a = new n), a.set(At * Lt, Ct * Lt).floor()
                    }, this.setDrawingBufferSize = function (a, b, t) {
                        At = a, Ct = b, Lt = t, u.width = Math.floor(a * t), u.height = Math.floor(b * t), this.setViewport(0, 0, a, b)
                    }, this.getCurrentViewport = function (a) {
                        return void 0 === a && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), a = new h), a.copy(Tt)
                    }, this.getViewport = function (a) {
                        return a.copy(Ot)
                    }, this.setViewport = function (a, b, t, e) {
                        a.isVector4 ? Ot.set(a.x, a.y, a.z, a.w) : Ot.set(a, b, t, e), F.viewport(Tt.copy(Ot).multiplyScalar(Lt).floor())
                    }, this.getScissor = function (a) {
                        return a.copy(Ft)
                    }, this.setScissor = function (a, b, t, e) {
                        a.isVector4 ? Ft.set(a.x, a.y, a.z, a.w) : Ft.set(a, b, t, e), F.scissor(Dt.copy(Ft).multiplyScalar(Lt).floor())
                    }, this.getScissorTest = function () {
                        return Nt
                    }, this.setScissorTest = function (a) {
                        F.setScissorTest(Nt = a)
                    }, this.setOpaqueSort = function (a) {
                        Rt = a
                    }, this.setTransparentSort = function (a) {
                        Pt = a
                    }, this.getClearColor = function () {
                        return j.getClearColor()
                    }, this.setClearColor = function () {
                        j.setClearColor.apply(j, arguments)
                    }, this.getClearAlpha = function () {
                        return j.getClearAlpha()
                    }, this.setClearAlpha = function () {
                        j.setClearAlpha.apply(j, arguments)
                    }, this.clear = function (a, b, t) {
                        var e = 0;
                        (void 0 === a || a) && (e |= 16384), (void 0 === b || b) && (e |= 256), (void 0 === t || t) && (e |= 1024), Gt.clear(e)
                    }, this.clearColor = function () {
                        this.clear(!0, !1, !1)
                    }, this.clearDepth = function () {
                        this.clear(!1, !0, !1)
                    }, this.clearStencil = function () {
                        this.clear(!1, !1, !0)
                    }, this.dispose = function () {
                        u.removeEventListener("webglcontextlost", e, !1), u.removeEventListener("webglcontextrestored", r, !1), G.dispose(), V.dispose(), I.dispose(), U.dispose(), Vt.dispose(), Xt.stop()
                    }, this.renderBufferImmediate = function (a, b) {
                        F.initAttributes();
                        var t = I.get(a);
                        a.hasPositions && !t.position && (t.position = Gt.createBuffer()), a.hasNormals && !t.normal && (t.normal = Gt.createBuffer()), a.hasUvs && !t.uv && (t.uv = Gt.createBuffer()), a.hasColors && !t.color && (t.color = Gt.createBuffer()), b = b.getAttributes(), a.hasPositions && (Gt.bindBuffer(34962, t.position), Gt.bufferData(34962, a.positionArray, 35048), F.enableAttribute(b.position), Gt.vertexAttribPointer(b.position, 3, 5126, !1, 0, 0)), a.hasNormals && (Gt.bindBuffer(34962, t.normal), Gt.bufferData(34962, a.normalArray, 35048), F.enableAttribute(b.normal), Gt.vertexAttribPointer(b.normal, 3, 5126, !1, 0, 0)), a.hasUvs && (Gt.bindBuffer(34962, t.uv), Gt.bufferData(34962, a.uvArray, 35048), F.enableAttribute(b.uv), Gt.vertexAttribPointer(b.uv, 2, 5126, !1, 0, 0)), a.hasColors && (Gt.bindBuffer(34962, t.color), Gt.bufferData(34962, a.colorArray, 35048), F.enableAttribute(b.color), Gt.vertexAttribPointer(b.color, 3, 5126, !1, 0, 0)), F.disableUnusedAttributes(), Gt.drawArrays(4, 0, a.count), a.count = 0
                    };
                    var Yt = new x;
                    this.renderBufferDirect = function (a, t, e, n, r, g) {
                        null === t && (t = Yt);
                        var o = r.isMesh && 0 > r.matrixWorld.determinant(),
                            c = f(a, t, n, r);
                        F.setMaterial(n, o);
                        var l = !1;
                        if (b === e.id && ot === c.id && ht === (!0 === n.wireframe) || (b = e.id, ot = c.id, ht = !0 === n.wireframe, l = !0), (n.morphTargets || n.morphNormals) && (W.update(r, e, n, c), l = !0), a = e.index, t = e.attributes.position, null === a) {
                            if (void 0 === t || 0 === t.count) return
                        } else if (0 === a.count) return;
                        var p = 1;
                        if (!0 === n.wireframe && (a = z.getWireframeAttribute(e), p = 2), o = Y, null !== a) {
                            var h = k.get(a);
                            (o = X).setIndex(h)
                        }
                        if (l) {
                            if (!1 !== O.isWebGL2 || !r.isInstancedMesh && !e.isInstancedBufferGeometry || null !== P.get("ANGLE_instanced_arrays")) {
                                F.initAttributes(), l = e.attributes, c = c.getAttributes();
                                var q = n.defaultAttributeValues;
                                for (E in c) {
                                    var d = c[E];
                                    if (0 <= d) {
                                        var m = l[E];
                                        if (void 0 !== m) {
                                            var v = m.normalized,
                                                u = m.itemSize,
                                                y = k.get(m);
                                            if (void 0 !== y) {
                                                var _ = y.buffer,
                                                    x = y.type;
                                                if (y = y.bytesPerElement, m.isInterleavedBufferAttribute) {
                                                    var w = m.data,
                                                        M = w.stride;
                                                    m = m.offset, w && w.isInstancedInterleavedBuffer ? (F.enableAttributeAndDivisor(d, w.meshPerAttribute), void 0 === e.maxInstancedCount && (e.maxInstancedCount = w.meshPerAttribute * w.count)) : F.enableAttribute(d), Gt.bindBuffer(34962, _), Gt.vertexAttribPointer(d, u, x, v, M * y, m * y)
                                                } else m.isInstancedBufferAttribute ? (F.enableAttributeAndDivisor(d, m.meshPerAttribute), void 0 === e.maxInstancedCount && (e.maxInstancedCount = m.meshPerAttribute * m.count)) : F.enableAttribute(d), Gt.bindBuffer(34962, _), Gt.vertexAttribPointer(d, u, x, v, 0, 0)
                                            }
                                        } else if ("instanceMatrix" === E) void 0 !== (y = k.get(r.instanceMatrix)) && (_ = y.buffer, x = y.type, F.enableAttributeAndDivisor(d + 0, 1), F.enableAttributeAndDivisor(d + 1, 1), F.enableAttributeAndDivisor(d + 2, 1), F.enableAttributeAndDivisor(d + 3, 1), Gt.bindBuffer(34962, _), Gt.vertexAttribPointer(d + 0, 4, x, !1, 64, 0), Gt.vertexAttribPointer(d + 1, 4, x, !1, 64, 16), Gt.vertexAttribPointer(d + 2, 4, x, !1, 64, 32), Gt.vertexAttribPointer(d + 3, 4, x, !1, 64, 48));
                                        else if (void 0 !== q && void 0 !== (v = q[E])) switch (v.length) {
                                            case 2:
                                                Gt.vertexAttrib2fv(d, v);
                                                break;
                                            case 3:
                                                Gt.vertexAttrib3fv(d, v);
                                                break;
                                            case 4:
                                                Gt.vertexAttrib4fv(d, v);
                                                break;
                                            default:
                                                Gt.vertexAttrib1fv(d, v)
                                        }
                                    }
                                }
                                F.disableUnusedAttributes()
                            }
                            null !== a && Gt.bindBuffer(34963, h.buffer)
                        }
                        var E = e.drawRange.start * p;
                        l = null !== g ? g.start * p : 0, h = Math.max(E, l), 0 !== (g = Math.max(0, Math.min(null !== a ? a.count : t.count, E + e.drawRange.count * p, l + (null !== g ? g.count * p : 1 / 0)) - 1 - h + 1)) && (r.isMesh ? !0 === n.wireframe ? (F.setLineWidth(n.wireframeLinewidth * (null === nt ? Lt : 1)), o.setMode(1)) : o.setMode(4) : r.isLine ? (void 0 === (n = n.linewidth) && (n = 1), F.setLineWidth(n * (null === nt ? Lt : 1)), r.isLineSegments ? o.setMode(1) : r.isLineLoop ? o.setMode(2) : o.setMode(3)) : r.isPoints ? o.setMode(0) : r.isSprite && o.setMode(4), r.isInstancedMesh ? o.renderInstances(e, h, g, r.count) : e.isInstancedBufferGeometry ? o.renderInstances(e, h, g, e.maxInstancedCount) : o.render(h, g))
                    }, this.compile = function (a, b) {
                        (R = V.get(a, b)).init(), a.traverse((function (a) {
                            a.isLight && (R.pushLight(a), a.castShadow && R.pushShadow(a))
                        })), R.setupLights(b), a.traverse((function (b) {
                            if (b.material)
                                if (Array.isArray(b.material))
                                    for (var t = 0; t < b.material.length; t++) p(b.material[t], a, b);
                                else p(b.material, a, b)
                        }))
                    };
                    var qt = null,
                        Xt = new ct;
                    Xt.setAnimationLoop((function (a) {
                        Vt.isPresenting || qt && qt(a)
                    })), "undefined" != typeof window && Xt.setContext(window), this.setAnimationLoop = function (a) {
                        qt = a, Vt.setAnimationLoop(a), Xt.start()
                    }, this.render = function (a, t, e, n) {
                        if (void 0 !== e) {
                            console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
                            var r = e
                        }
                        if (void 0 !== n) {
                            console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
                            var g = n
                        }
                        t && t.isCamera ? $ || (ot = b = null, ht = !1, at = -1, pt = null, !0 === a.autoUpdate && a.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), Vt.enabled && Vt.isPresenting && (t = Vt.getCamera(t)), (R = V.get(a, t)).init(), a.onBeforeRender(J, a, t, r || nt), Ut.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), It.setFromMatrix(Ut), zt = this.localClippingEnabled, kt = Bt.init(this.clippingPlanes, zt, t), (L = G.get(a, t)).init(), function t(a, b, e, n) {
                            if (!1 !== a.visible) {
                                if (a.layers.test(b.layers))
                                    if (a.isGroup) e = a.renderOrder;
                                    else if (a.isLOD) !0 === a.autoUpdate && a.update(b);
                                else if (a.isLight) R.pushLight(a), a.castShadow && R.pushShadow(a);
                                else if (a.isSprite) {
                                    if (!a.frustumCulled || It.intersectsSprite(a)) {
                                        n && Ht.setFromMatrixPosition(a.matrixWorld).applyMatrix4(Ut);
                                        var r = U.update(a),
                                            o = a.material;
                                        o.visible && L.push(a, r, o, e, Ht.z, null)
                                    }
                                } else if (a.isImmediateRenderObject) n && Ht.setFromMatrixPosition(a.matrixWorld).applyMatrix4(Ut), L.push(a, null, a.material, e, Ht.z, null);
                                else if ((a.isMesh || a.isLine || a.isPoints) && (a.isSkinnedMesh && a.skeleton.frame !== N.render.frame && (a.skeleton.update(), a.skeleton.frame = N.render.frame), !a.frustumCulled || It.intersectsObject(a)))
                                    if (n && Ht.setFromMatrixPosition(a.matrixWorld).applyMatrix4(Ut), r = U.update(a), o = a.material, Array.isArray(o))
                                        for (var g = r.groups, c = 0, l = g.length; c < l; c++) {
                                            var p = g[c],
                                                h = o[p.materialIndex];
                                            h && h.visible && L.push(a, r, h, e, Ht.z, p)
                                        } else o.visible && L.push(a, r, o, e, Ht.z, null);
                                for (c = 0, l = (a = a.children).length; c < l; c++) t(a[c], b, e, n)
                            }
                        }(a, t, 0, J.sortObjects), !0 === J.sortObjects && L.sort(Rt, Pt), kt && Bt.beginShadows(), Wt.render(R.state.shadowsArray, a, t), R.setupLights(t), kt && Bt.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== r && this.setRenderTarget(r), Vt.enabled && jt.isAvailable() && jt.attachCamera(t), j.render(L, a, t, g), e = L.opaque, n = L.transparent, a.overrideMaterial ? (r = a.overrideMaterial, e.length && l(e, a, t, r), n.length && l(n, a, t, r)) : (e.length && l(e, a, t), n.length && l(n, a, t)), a.onAfterRender(J, a, t), null !== nt && (B.updateRenderTargetMipmap(nt), B.updateMultisampleRenderTarget(nt)), F.buffers.depth.setTest(!0), F.buffers.depth.setMask(!0), F.buffers.color.setMask(!0), F.setPolygonOffset(!1), Vt.enabled && jt.isAvailable() && jt.detachCamera(t), R = L = null) : console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
                    }, this.setFramebuffer = function (a) {
                        Q !== a && null === nt && Gt.bindFramebuffer(36160, a), Q = a
                    }, this.getActiveCubeFace = function () {
                        return tt
                    }, this.getActiveMipmapLevel = function () {
                        return et
                    }, this.getRenderTarget = function () {
                        return nt
                    }, this.setRenderTarget = function (a, b, t) {
                        nt = a, tt = b, et = t, a && void 0 === I.get(a).__webglFramebuffer && B.setupRenderTarget(a);
                        var e = Q,
                            n = !1;
                        a ? (e = I.get(a).__webglFramebuffer, a.isWebGLRenderTargetCube ? (e = e[b || 0], n = !0) : e = a.isWebGLMultisampleRenderTarget ? I.get(a).__webglMultisampledFramebuffer : e, Tt.copy(a.viewport), Dt.copy(a.scissor), St = a.scissorTest) : (Tt.copy(Ot).multiplyScalar(Lt).floor(), Dt.copy(Ft).multiplyScalar(Lt).floor(), St = Nt), it !== e && (Gt.bindFramebuffer(36160, e), it = e), F.viewport(Tt), F.scissor(Dt), F.setScissorTest(St), n && (a = I.get(a.texture), Gt.framebufferTexture2D(36160, 36064, 34069 + (b || 0), a.__webglTexture, t || 0))
                    }, this.readRenderTargetPixels = function (a, b, t, e, n, r, g) {
                        if (a && a.isWebGLRenderTarget) {
                            var o = I.get(a).__webglFramebuffer;
                            if (a.isWebGLRenderTargetCube && void 0 !== g && (o = o[g]), o) {
                                g = !1, o !== it && (Gt.bindFramebuffer(36160, o), g = !0);
                                try {
                                    var c = a.texture,
                                        l = c.format,
                                        h = c.type;
                                    1023 !== l && Z.convert(l) !== Gt.getParameter(35739) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === h || Z.convert(h) === Gt.getParameter(35738) || 1015 === h && (O.isWebGL2 || P.get("OES_texture_float") || P.get("WEBGL_color_buffer_float")) || 1016 === h && (O.isWebGL2 ? P.get("EXT_color_buffer_float") : P.get("EXT_color_buffer_half_float")) ? 36053 === Gt.checkFramebufferStatus(36160) ? 0 <= b && b <= a.width - e && 0 <= t && t <= a.height - n && Gt.readPixels(b, t, e, n, Z.convert(l), Z.convert(h), r) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")
                                } finally {
                                    g && Gt.bindFramebuffer(36160, it)
                                }
                            }
                        } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
                    }, this.copyFramebufferToTexture = function (a, b, t) {
                        void 0 === t && (t = 0);
                        var e = Math.pow(2, -t),
                            n = Math.floor(b.image.width * e);
                        e = Math.floor(b.image.height * e);
                        var r = Z.convert(b.format);
                        B.setTexture2D(b, 0), Gt.copyTexImage2D(3553, t, r, a.x, a.y, n, e, 0), F.unbindTexture()
                    }, this.copyTextureToTexture = function (a, b, t, e) {
                        var n = b.image.width,
                            r = b.image.height,
                            g = Z.convert(t.format),
                            o = Z.convert(t.type);
                        B.setTexture2D(t, 0), b.isDataTexture ? Gt.texSubImage2D(3553, e || 0, a.x, a.y, n, r, g, o, b.image.data) : Gt.texSubImage2D(3553, e || 0, a.x, a.y, g, o, b.image), F.unbindTexture()
                    }, this.initTexture = function (a) {
                        B.setTexture2D(a, 0), F.unbindTexture()
                    }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                        detail: this
                    }))
                }

                function Ye(a, b) {
                    this.name = "", this.color = new A(a), this.density = void 0 !== b ? b : 25e-5
                }

                function qe(a, b, t) {
                    this.name = "", this.color = new A(a), this.near = void 0 !== b ? b : 1, this.far = void 0 !== t ? t : 1e3
                }

                function Xe(a, b) {
                    this.array = a, this.stride = b, this.count = void 0 !== a ? a.length / b : 0, this.usage = 35044, this.updateRange = {
                        offset: 0,
                        count: -1
                    }, this.version = 0
                }

                function Ze(a, b, t, e) {
                    this.data = a, this.itemSize = b, this.offset = t, this.normalized = !0 === e
                }

                function Je(a) {
                    O.call(this), this.type = "SpriteMaterial", this.color = new A(16777215), this.alphaMap = this.map = null, this.rotation = 0, this.transparent = this.sizeAttenuation = !0, this.setValues(a)
                }

                function $e(a) {
                    if (_.call(this), this.type = "Sprite", void 0 === tu) {
                        tu = new X;
                        var b = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]);
                        b = new Xe(b, 5), tu.setIndex([0, 1, 2, 0, 2, 3]), tu.setAttribute("position", new Ze(b, 3, 0, !1)), tu.setAttribute("uv", new Ze(b, 2, 3, !1))
                    }
                    this.geometry = tu, this.material = void 0 !== a ? a : new Je, this.center = new n(.5, .5)
                }

                function Qe(a, b, t, e, n, r) {
                    ru.subVectors(a, t).addScalar(.5).multiply(e), void 0 !== n ? (au.x = r * ru.x - n * ru.y, au.y = n * ru.x + r * ru.y) : au.copy(ru), a.copy(b), a.x += au.x, a.y += au.y, a.applyMatrix4(ou)
                }

                function Ke() {
                    _.call(this), this.type = "LOD", Object.defineProperties(this, {
                        levels: {
                            enumerable: !0,
                            value: []
                        }
                    }), this.autoUpdate = !0
                }

                function tn(a, b) {
                    a && a.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), Z.call(this, a, b), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new m, this.bindMatrixInverse = new m
                }

                function en(a, b) {
                    if (a = a || [], this.bones = a.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), this.frame = -1, void 0 === b) this.calculateInverses();
                    else if (this.bones.length === b.length) this.boneInverses = b.slice(0);
                    else
                        for (console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [], a = 0, b = this.bones.length; a < b; a++) this.boneInverses.push(new m)
                }

                function nn() {
                    _.call(this), this.type = "Bone"
                }

                function rn(a, b, t) {
                    Z.call(this, a, b), this.instanceMatrix = new N(new Float32Array(16 * t), 16), this.count = t
                }

                function an(a) {
                    O.call(this), this.type = "LineBasicMaterial", this.color = new A(16777215), this.linewidth = 1, this.linejoin = this.linecap = "round", this.setValues(a)
                }

                function on(a, b, t) {
                    1 === t && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), _.call(this), this.type = "Line", this.geometry = void 0 !== a ? a : new X, this.material = void 0 !== b ? b : new an({
                        color: 16777215 * Math.random()
                    })
                }

                function sn(a, b) {
                    on.call(this, a, b), this.type = "LineSegments"
                }

                function un(a, b) {
                    on.call(this, a, b), this.type = "LineLoop"
                }

                function cn(a) {
                    O.call(this), this.type = "PointsMaterial", this.color = new A(16777215), this.alphaMap = this.map = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(a)
                }

                function ln(a, b) {
                    _.call(this), this.type = "Points", this.geometry = void 0 !== a ? a : new X, this.material = void 0 !== b ? b : new cn({
                        color: 16777215 * Math.random()
                    }), this.updateMorphTargets()
                }

                function hn(a, b, t, e, n, r, g) {
                    var c = Cu.distanceSqToPoint(a);
                    c < t && (t = new o, Cu.closestPointToPoint(a, t), t.applyMatrix4(e), (a = n.ray.origin.distanceTo(t)) < n.near || a > n.far || r.push({
                        distance: a,
                        distanceToRay: Math.sqrt(c),
                        point: t,
                        index: b,
                        face: null,
                        object: g
                    }))
                }

                function dn(a, b, t, e, n, r, g, o, c) {
                    l.call(this, a, b, t, e, n, r, g, o, c), this.format = void 0 !== g ? g : 1022, this.minFilter = void 0 !== r ? r : 1006, this.magFilter = void 0 !== n ? n : 1006, this.generateMipmaps = !1
                }

                function pn(a, b, t, e, n, r, g, o, c, h, d, p) {
                    l.call(this, null, r, g, o, c, h, e, n, d, p), this.image = {
                        width: b,
                        height: t
                    }, this.mipmaps = a, this.generateMipmaps = this.flipY = !1
                }

                function fn(a, b, t, e, n, r, g, o, c) {
                    l.call(this, a, b, t, e, n, r, g, o, c), this.needsUpdate = !0
                }

                function mn(a, b, t, e, n, r, g, o, c, h) {
                    if (1026 !== (h = void 0 !== h ? h : 1026) && 1027 !== h) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                    void 0 === t && 1026 === h && (t = 1012), void 0 === t && 1027 === h && (t = 1020), l.call(this, null, e, n, r, g, o, h, t, c), this.image = {
                        width: a,
                        height: b
                    }, this.magFilter = void 0 !== g ? g : 1003, this.minFilter = void 0 !== o ? o : 1003, this.generateMipmaps = this.flipY = !1
                }

                function gn(a) {
                    X.call(this), this.type = "WireframeGeometry";
                    var t, e, n, b = [],
                        r = [0, 0],
                        g = {},
                        c = ["a", "b", "c"];
                    if (a && a.isGeometry) {
                        var l = a.faces,
                            h = 0;
                        for (e = l.length; h < e; h++) {
                            var d = l[h];
                            for (t = 0; 3 > t; t++) {
                                var p = d[c[t]],
                                    q = d[c[(t + 1) % 3]];
                                r[0] = Math.min(p, q), r[1] = Math.max(p, q), void 0 === g[p = r[0] + "," + r[1]] && (g[p] = {
                                    index1: r[0],
                                    index2: r[1]
                                })
                            }
                        }
                        for (p in g) h = g[p], c = a.vertices[h.index1], b.push(c.x, c.y, c.z), c = a.vertices[h.index2], b.push(c.x, c.y, c.z)
                    } else if (a && a.isBufferGeometry)
                        if (c = new o, null !== a.index) {
                            l = a.attributes.position, d = a.index;
                            var f = a.groups;
                            for (0 === f.length && (f = [{
                                    start: 0,
                                    count: d.count,
                                    materialIndex: 0
                                }]), a = 0, n = f.length; a < n; ++a)
                                for (t = (h = f[a]).start, e = h.count, h = t, e = t + e; h < e; h += 3)
                                    for (t = 0; 3 > t; t++) p = d.getX(h + t), q = d.getX(h + (t + 1) % 3), r[0] = Math.min(p, q), r[1] = Math.max(p, q), void 0 === g[p = r[0] + "," + r[1]] && (g[p] = {
                                        index1: r[0],
                                        index2: r[1]
                                    });
                            for (p in g) h = g[p], c.fromBufferAttribute(l, h.index1), b.push(c.x, c.y, c.z), c.fromBufferAttribute(l, h.index2), b.push(c.x, c.y, c.z)
                        } else
                            for (h = 0, e = (l = a.attributes.position).count / 3; h < e; h++)
                                for (t = 0; 3 > t; t++) g = 3 * h + t, c.fromBufferAttribute(l, g), b.push(c.x, c.y, c.z), g = 3 * h + (t + 1) % 3, c.fromBufferAttribute(l, g), b.push(c.x, c.y, c.z);
                    this.setAttribute("position", new V(b, 3))
                }

                function vn(a, b, t) {
                    Q.call(this), this.type = "ParametricGeometry", this.parameters = {
                        func: a,
                        slices: b,
                        stacks: t
                    }, this.fromBufferGeometry(new yn(a, b, t)), this.mergeVertices()
                }

                function yn(a, b, t) {
                    X.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
                        func: a,
                        slices: b,
                        stacks: t
                    };
                    var q, e, n = [],
                        r = [],
                        c = [],
                        g = [],
                        l = new o,
                        h = new o,
                        d = new o,
                        f = new o,
                        p = new o;
                    3 > a.length && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
                    var m = b + 1;
                    for (q = 0; q <= t; q++) {
                        var u = q / t;
                        for (e = 0; e <= b; e++) {
                            var v = e / b;
                            a(v, u, h), r.push(h.x, h.y, h.z), 0 <= v - 1e-5 ? (a(v - 1e-5, u, d), f.subVectors(h, d)) : (a(v + 1e-5, u, d), f.subVectors(d, h)), 0 <= u - 1e-5 ? (a(v, u - 1e-5, d), p.subVectors(h, d)) : (a(v, u + 1e-5, d), p.subVectors(d, h)), l.crossVectors(f, p).normalize(), c.push(l.x, l.y, l.z), g.push(v, u)
                        }
                    }
                    for (q = 0; q < t; q++)
                        for (e = 0; e < b; e++) a = q * m + e + 1, l = (q + 1) * m + e + 1, h = (q + 1) * m + e, n.push(q * m + e, a, h), n.push(a, l, h);
                    this.setIndex(n), this.setAttribute("position", new V(r, 3)), this.setAttribute("normal", new V(c, 3)), this.setAttribute("uv", new V(g, 2))
                }

                function _n(a, b, t, e) {
                    Q.call(this), this.type = "PolyhedronGeometry", this.parameters = {
                        vertices: a,
                        indices: b,
                        radius: t,
                        detail: e
                    }, this.fromBufferGeometry(new xn(a, b, t, e)), this.mergeVertices()
                }

                function xn(a, b, t, e) {
                    function r(a) {
                        l.push(a.x, a.y, a.z)
                    }

                    function c(b, t) {
                        b *= 3, t.x = a[b + 0], t.y = a[b + 1], t.z = a[b + 2]
                    }

                    function g(a, b, t, e) {
                        0 > e && 1 === a.x && (h[b] = a.x - 1), 0 === t.x && 0 === t.z && (h[b] = e / 2 / Math.PI + .5)
                    }
                    X.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
                        vertices: a,
                        indices: b,
                        radius: t,
                        detail: e
                    }, t = t || 1;
                    var l = [],
                        h = [];
                    ! function (a) {
                        for (var t = new o, e = new o, g = new o, n = 0; n < b.length; n += 3) {
                            c(b[n + 0], t), c(b[n + 1], e), c(b[n + 2], g);
                            var l, h, d = t,
                                f = e,
                                m = g,
                                v = Math.pow(2, a),
                                y = [];
                            for (h = 0; h <= v; h++) {
                                y[h] = [];
                                var _ = d.clone().lerp(m, h / v),
                                    x = f.clone().lerp(m, h / v),
                                    w = v - h;
                                for (l = 0; l <= w; l++) y[h][l] = 0 === l && h === v ? _ : _.clone().lerp(x, l / w)
                            }
                            for (h = 0; h < v; h++)
                                for (l = 0; l < 2 * (v - h) - 1; l++) d = Math.floor(l / 2), 0 == l % 2 ? (r(y[h][d + 1]), r(y[h + 1][d]), r(y[h][d])) : (r(y[h][d + 1]), r(y[h + 1][d + 1]), r(y[h + 1][d]))
                        }
                    }(e = e || 0),
                    function (a) {
                        for (var b = new o, t = 0; t < l.length; t += 3) b.x = l[t + 0], b.y = l[t + 1], b.z = l[t + 2], b.normalize().multiplyScalar(a), l[t + 0] = b.x, l[t + 1] = b.y, l[t + 2] = b.z
                    }(t),
                    function () {
                        for (var a = new o, b = 0; b < l.length; b += 3) a.x = l[b + 0], a.y = l[b + 1], a.z = l[b + 2], h.push(Math.atan2(a.z, -a.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5));
                        a = new o, b = new o;
                        for (var t = new o, e = new o, r = new n, c = new n, d = new n, f = 0, m = 0; f < l.length; f += 9, m += 6) {
                            a.set(l[f + 0], l[f + 1], l[f + 2]), b.set(l[f + 3], l[f + 4], l[f + 5]), t.set(l[f + 6], l[f + 7], l[f + 8]), r.set(h[m + 0], h[m + 1]), c.set(h[m + 2], h[m + 3]), d.set(h[m + 4], h[m + 5]), e.copy(a).add(b).add(t).divideScalar(3);
                            var v = Math.atan2(e.z, -e.x);
                            g(r, m + 0, a, v), g(c, m + 2, b, v), g(d, m + 4, t, v)
                        }
                        for (a = 0; a < h.length; a += 6) b = h[a + 0], t = h[a + 2], e = h[a + 4], r = Math.min(b, t, e), .9 < Math.max(b, t, e) && .1 > r && (.2 > b && (h[a + 0] += 1), .2 > t && (h[a + 2] += 1), .2 > e && (h[a + 4] += 1))
                    }(), this.setAttribute("position", new V(l, 3)), this.setAttribute("normal", new V(l.slice(), 3)), this.setAttribute("uv", new V(h, 2)), 0 === e ? this.computeVertexNormals() : this.normalizeNormals()
                }

                function bn(a, b) {
                    Q.call(this), this.type = "TetrahedronGeometry", this.parameters = {
                        radius: a,
                        detail: b
                    }, this.fromBufferGeometry(new wn(a, b)), this.mergeVertices()
                }

                function wn(a, b) {
                    xn.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], a, b), this.type = "TetrahedronBufferGeometry", this.parameters = {
                        radius: a,
                        detail: b
                    }
                }

                function Mn(a, b) {
                    Q.call(this), this.type = "OctahedronGeometry", this.parameters = {
                        radius: a,
                        detail: b
                    }, this.fromBufferGeometry(new En(a, b)), this.mergeVertices()
                }

                function En(a, b) {
                    xn.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], a, b), this.type = "OctahedronBufferGeometry", this.parameters = {
                        radius: a,
                        detail: b
                    }
                }

                function Tn(a, b) {
                    Q.call(this), this.type = "IcosahedronGeometry", this.parameters = {
                        radius: a,
                        detail: b
                    }, this.fromBufferGeometry(new Dn(a, b)), this.mergeVertices()
                }

                function Dn(a, b) {
                    var t = (1 + Math.sqrt(5)) / 2;
                    xn.call(this, [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], a, b), this.type = "IcosahedronBufferGeometry", this.parameters = {
                        radius: a,
                        detail: b
                    }
                }

                function Sn(a, b) {
                    Q.call(this), this.type = "DodecahedronGeometry", this.parameters = {
                        radius: a,
                        detail: b
                    }, this.fromBufferGeometry(new An(a, b)), this.mergeVertices()
                }

                function An(a, b) {
                    var t = (1 + Math.sqrt(5)) / 2,
                        e = 1 / t;
                    xn.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -e, -t, 0, -e, t, 0, e, -t, 0, e, t, -e, -t, 0, -e, t, 0, e, -t, 0, e, t, 0, -t, 0, -e, t, 0, -e, -t, 0, e, t, 0, e], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], a, b), this.type = "DodecahedronBufferGeometry", this.parameters = {
                        radius: a,
                        detail: b
                    }
                }

                function Cn(a, b, t, e, n, r) {
                    Q.call(this), this.type = "TubeGeometry", this.parameters = {
                        path: a,
                        tubularSegments: b,
                        radius: t,
                        radialSegments: e,
                        closed: n
                    }, void 0 !== r && console.warn("THREE.TubeGeometry: taper has been removed."), a = new Ln(a, b, t, e, n), this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals, this.fromBufferGeometry(a), this.mergeVertices()
                }

                function Ln(a, b, t, e, r) {
                    function c(n) {
                        f = a.getPointAt(n / b, f);
                        var r = g.normals[n];
                        for (n = g.binormals[n], q = 0; q <= e; q++) {
                            var o = q / e * Math.PI * 2,
                                p = Math.sin(o);
                            o = -Math.cos(o), h.x = o * r.x + p * n.x, h.y = o * r.y + p * n.y, h.z = o * r.z + p * n.z, h.normalize(), v.push(h.x, h.y, h.z), l.x = f.x + t * h.x, l.y = f.y + t * h.y, l.z = f.z + t * h.z, m.push(l.x, l.y, l.z)
                        }
                    }
                    X.call(this), this.type = "TubeBufferGeometry", this.parameters = {
                        path: a,
                        tubularSegments: b,
                        radius: t,
                        radialSegments: e,
                        closed: r
                    }, b = b || 64, t = t || 1, e = e || 8, r = r || !1;
                    var g = a.computeFrenetFrames(b, r);
                    this.tangents = g.tangents, this.normals = g.normals, this.binormals = g.binormals;
                    var p, q, l = new o,
                        h = new o,
                        d = new n,
                        f = new o,
                        m = [],
                        v = [],
                        u = [],
                        y = [];
                    for (p = 0; p < b; p++) c(p);
                    for (c(!1 === r ? b : 0), p = 0; p <= b; p++)
                        for (q = 0; q <= e; q++) d.x = p / b, d.y = q / e, u.push(d.x, d.y);
                    ! function () {
                        for (q = 1; q <= b; q++)
                            for (p = 1; p <= e; p++) {
                                var a = (e + 1) * q + (p - 1),
                                    t = (e + 1) * q + p,
                                    n = (e + 1) * (q - 1) + p;
                                y.push((e + 1) * (q - 1) + (p - 1), a, n), y.push(a, t, n)
                            }
                    }(), this.setIndex(y), this.setAttribute("position", new V(m, 3)), this.setAttribute("normal", new V(v, 3)), this.setAttribute("uv", new V(u, 2))
                }

                function Rn(a, b, t, e, n, r, g) {
                    Q.call(this), this.type = "TorusKnotGeometry", this.parameters = {
                        radius: a,
                        tube: b,
                        tubularSegments: t,
                        radialSegments: e,
                        p: n,
                        q: r
                    }, void 0 !== g && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new Pn(a, b, t, e, n, r)), this.mergeVertices()
                }

                function Pn(a, b, t, e, n, r) {
                    function g(a, b, t, e, n) {
                        var r = Math.sin(a);
                        b = t / b * a, t = Math.cos(b), n.x = e * (2 + t) * .5 * Math.cos(a), n.y = e * (2 + t) * r * .5, n.z = e * Math.sin(b) * .5
                    }
                    X.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
                        radius: a,
                        tube: b,
                        tubularSegments: t,
                        radialSegments: e,
                        p: n,
                        q: r
                    }, a = a || 1, b = b || .4, t = Math.floor(t) || 64, e = Math.floor(e) || 8, n = n || 2, r = r || 3;
                    var p, c = [],
                        l = [],
                        h = [],
                        d = [],
                        q = new o,
                        f = new o,
                        m = new o,
                        u = new o,
                        v = new o,
                        y = new o,
                        _ = new o;
                    for (p = 0; p <= t; ++p) {
                        var x = p / t * n * Math.PI * 2;
                        for (g(x, n, r, a, m), g(x + .01, n, r, a, u), y.subVectors(u, m), _.addVectors(u, m), v.crossVectors(y, _), _.crossVectors(v, y), v.normalize(), _.normalize(), x = 0; x <= e; ++x) {
                            var w = x / e * Math.PI * 2,
                                M = -b * Math.cos(w);
                            w = b * Math.sin(w), q.x = m.x + (M * _.x + w * v.x), q.y = m.y + (M * _.y + w * v.y), q.z = m.z + (M * _.z + w * v.z), l.push(q.x, q.y, q.z), f.subVectors(q, m).normalize(), h.push(f.x, f.y, f.z), d.push(p / t), d.push(x / e)
                        }
                    }
                    for (x = 1; x <= t; x++)
                        for (p = 1; p <= e; p++) a = (e + 1) * x + (p - 1), b = (e + 1) * x + p, n = (e + 1) * (x - 1) + p, c.push((e + 1) * (x - 1) + (p - 1), a, n), c.push(a, b, n);
                    this.setIndex(c), this.setAttribute("position", new V(l, 3)), this.setAttribute("normal", new V(h, 3)), this.setAttribute("uv", new V(d, 2))
                }

                function On(a, b, t, e, n) {
                    Q.call(this), this.type = "TorusGeometry", this.parameters = {
                        radius: a,
                        tube: b,
                        radialSegments: t,
                        tubularSegments: e,
                        arc: n
                    }, this.fromBufferGeometry(new Fn(a, b, t, e, n)), this.mergeVertices()
                }

                function Fn(a, b, t, e, n) {
                    X.call(this), this.type = "TorusBufferGeometry", this.parameters = {
                        radius: a,
                        tube: b,
                        radialSegments: t,
                        tubularSegments: e,
                        arc: n
                    }, a = a || 1, b = b || .4, t = Math.floor(t) || 8, e = Math.floor(e) || 6, n = n || 2 * Math.PI;
                    var q, r, c = [],
                        g = [],
                        l = [],
                        h = [],
                        d = new o,
                        f = new o,
                        p = new o;
                    for (q = 0; q <= t; q++)
                        for (r = 0; r <= e; r++) {
                            var m = r / e * n,
                                u = q / t * Math.PI * 2;
                            f.x = (a + b * Math.cos(u)) * Math.cos(m), f.y = (a + b * Math.cos(u)) * Math.sin(m), f.z = b * Math.sin(u), g.push(f.x, f.y, f.z), d.x = a * Math.cos(m), d.y = a * Math.sin(m), p.subVectors(f, d).normalize(), l.push(p.x, p.y, p.z), h.push(r / e), h.push(q / t)
                        }
                    for (q = 1; q <= t; q++)
                        for (r = 1; r <= e; r++) a = (e + 1) * (q - 1) + r - 1, b = (e + 1) * (q - 1) + r, n = (e + 1) * q + r, c.push((e + 1) * q + r - 1, a, n), c.push(a, b, n);
                    this.setIndex(c), this.setAttribute("position", new V(g, 3)), this.setAttribute("normal", new V(l, 3)), this.setAttribute("uv", new V(h, 2))
                }

                function Nn(a, b, t, e, n) {
                    for (var r, g = 0, o = b, c = t - e; o < t; o += e) g += (a[c] - a[o]) * (a[o + 1] + a[c + 1]), c = o;
                    if (n === 0 < g)
                        for (n = b; n < t; n += e) r = Xn(n, a[n], a[n + 1], r);
                    else
                        for (n = t - e; n >= b; n -= e) r = Xn(n, a[n], a[n + 1], r);
                    return r && jn(r, r.next) && (Zn(r), r = r.next), r
                }

                function In(a, b) {
                    if (!a) return a;
                    b || (b = a);
                    do {
                        var t = !1;
                        if (a.steiner || !jn(a, a.next) && 0 !== Vn(a.prev, a, a.next)) a = a.next;
                        else {
                            if (Zn(a), (a = b = a.prev) === a.next) break;
                            t = !0
                        }
                    } while (t || a !== b);
                    return b
                }

                function Bn(a, b, t, e) {
                    var n = a.prev,
                        r = a.next;
                    if (0 <= Vn(n, a, r)) return !1;
                    var g = n.x > a.x ? n.x > r.x ? n.x : r.x : a.x > r.x ? a.x : r.x,
                        o = n.y > a.y ? n.y > r.y ? n.y : r.y : a.y > r.y ? a.y : r.y,
                        c = Un(n.x < a.x ? n.x < r.x ? n.x : r.x : a.x < r.x ? a.x : r.x, n.y < a.y ? n.y < r.y ? n.y : r.y : a.y < r.y ? a.y : r.y, b, t, e);
                    for (b = Un(g, o, b, t, e), t = a.prevZ, e = a.nextZ; t && t.z >= c && e && e.z <= b;) {
                        if (t !== a.prev && t !== a.next && Gn(n.x, n.y, a.x, a.y, r.x, r.y, t.x, t.y) && 0 <= Vn(t.prev, t, t.next)) return !1;
                        if (t = t.prevZ, e !== a.prev && e !== a.next && Gn(n.x, n.y, a.x, a.y, r.x, r.y, e.x, e.y) && 0 <= Vn(e.prev, e, e.next)) return !1;
                        e = e.nextZ
                    }
                    for (; t && t.z >= c;) {
                        if (t !== a.prev && t !== a.next && Gn(n.x, n.y, a.x, a.y, r.x, r.y, t.x, t.y) && 0 <= Vn(t.prev, t, t.next)) return !1;
                        t = t.prevZ
                    }
                    for (; e && e.z <= b;) {
                        if (e !== a.prev && e !== a.next && Gn(n.x, n.y, a.x, a.y, r.x, r.y, e.x, e.y) && 0 <= Vn(e.prev, e, e.next)) return !1;
                        e = e.nextZ
                    }
                    return !0
                }

                function kn(a, b) {
                    return a.x - b.x
                }

                function zn(a, b) {
                    var t = b,
                        e = a.x,
                        n = a.y,
                        r = -1 / 0;
                    do {
                        if (n <= t.y && n >= t.next.y && t.next.y !== t.y) {
                            var g = t.x + (n - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
                            if (g <= e && g > r) {
                                if (r = g, g === e) {
                                    if (n === t.y) return t;
                                    if (n === t.next.y) return t.next
                                }
                                var o = t.x < t.next.x ? t : t.next
                            }
                        }
                        t = t.next
                    } while (t !== b);
                    if (!o) return null;
                    if (e === r) return o.prev;
                    b = o, g = o.x;
                    var c = o.y,
                        l = 1 / 0;
                    for (t = o.next; t !== b;) {
                        if (e >= t.x && t.x >= g && e !== t.x && Gn(n < c ? e : r, n, g, c, n < c ? r : e, n, t.x, t.y)) {
                            var h = Math.abs(n - t.y) / (e - t.x);
                            (h < l || h === l && t.x > o.x) && Yn(t, a) && (o = t, l = h)
                        }
                        t = t.next
                    }
                    return o
                }

                function Un(a, b, t, e, n) {
                    return 1431655765 & ((a = 858993459 & ((a = 252645135 & ((a = 16711935 & ((a = 32767 * (a - t) * n) | a << 8)) | a << 4)) | a << 2)) | a << 1) | (1431655765 & ((b = 858993459 & ((b = 252645135 & ((b = 16711935 & ((b = 32767 * (b - e) * n) | b << 8)) | b << 4)) | b << 2)) | b << 1)) << 1
                }

                function Hn(a) {
                    var b = a,
                        t = a;
                    do {
                        (b.x < t.x || b.x === t.x && b.y < t.y) && (t = b), b = b.next
                    } while (b !== a);
                    return t
                }

                function Gn(a, b, t, e, n, r, g, o) {
                    return 0 <= (n - g) * (b - o) - (a - g) * (r - o) && 0 <= (a - g) * (e - o) - (t - g) * (b - o) && 0 <= (t - g) * (r - o) - (n - g) * (e - o)
                }

                function Vn(a, b, t) {
                    return (b.y - a.y) * (t.x - b.x) - (b.x - a.x) * (t.y - b.y)
                }

                function jn(a, b) {
                    return a.x === b.x && a.y === b.y
                }

                function Wn(a, b, t, e) {
                    return !!(jn(a, t) && jn(b, e) || jn(a, e) && jn(t, b)) || 0 < Vn(a, b, t) != 0 < Vn(a, b, e) && 0 < Vn(t, e, a) != 0 < Vn(t, e, b)
                }

                function Yn(a, b) {
                    return 0 > Vn(a.prev, a, a.next) ? 0 <= Vn(a, b, a.next) && 0 <= Vn(a, a.prev, b) : 0 > Vn(a, b, a.prev) || 0 > Vn(a, a.next, b)
                }

                function qn(a, b) {
                    var t = new Jn(a.i, a.x, a.y),
                        e = new Jn(b.i, b.x, b.y),
                        n = a.next,
                        r = b.prev;
                    return a.next = b, b.prev = a, t.next = n, n.prev = t, e.next = t, t.prev = e, r.next = e, e.prev = r, e
                }

                function Xn(a, b, t, e) {
                    return a = new Jn(a, b, t), e ? (a.next = e.next, a.prev = e, e.next.prev = a, e.next = a) : (a.prev = a, a.next = a), a
                }

                function Zn(a) {
                    a.next.prev = a.prev, a.prev.next = a.next, a.prevZ && (a.prevZ.nextZ = a.nextZ), a.nextZ && (a.nextZ.prevZ = a.prevZ)
                }

                function Jn(a, b, t) {
                    this.i = a, this.x = b, this.y = t, this.nextZ = this.prevZ = this.z = this.next = this.prev = null, this.steiner = !1
                }

                function $n(a) {
                    var b = a.length;
                    2 < b && a[b - 1].equals(a[0]) && a.pop()
                }

                function Qn(a, b) {
                    for (var t = 0; t < b.length; t++) a.push(b[t].x), a.push(b[t].y)
                }

                function Kn(a, b) {
                    Q.call(this), this.type = "ExtrudeGeometry", this.parameters = {
                        shapes: a,
                        options: b
                    }, this.fromBufferGeometry(new ti(a, b)), this.mergeVertices()
                }

                function ti(a, b) {
                    function t(a) {
                        function t(a, b, t) {
                            return b || console.error("THREE.ExtrudeGeometry: vec does not exist"), b.clone().multiplyScalar(t).add(a)
                        }

                        function g(a, b, t) {
                            var e = a.x - b.x,
                                r = a.y - b.y,
                                o = t.x - a.x,
                                g = t.y - a.y,
                                c = e * e + r * r;
                            if (Math.abs(e * g - r * o) > Number.EPSILON) {
                                var l = Math.sqrt(c),
                                    h = Math.sqrt(o * o + g * g);
                                if (c = b.x - r / l, b = b.y + e / l, 2 >= (r = (o = c + e * (g = ((t.x - g / h - c) * g - (t.y + o / h - b) * o) / (e * g - r * o)) - a.x) * o + (e = b + r * g - a.y) * e)) return new n(o, e);
                                r = Math.sqrt(r / 2)
                            } else a = !1, e > Number.EPSILON ? o > Number.EPSILON && (a = !0) : e < -Number.EPSILON ? o < -Number.EPSILON && (a = !0) : Math.sign(r) === Math.sign(g) && (a = !0), a ? (o = -r, r = Math.sqrt(c)) : (o = e, e = r, r = Math.sqrt(c / 2));
                            return new n(o / r, e / r)
                        }

                        function l(a, b) {
                            for (j = a.length; 0 <= --j;) {
                                var t = j,
                                    n = j - 1;
                                0 > n && (n = a.length - 1);
                                var g, o = y + 2 * T;
                                for (g = 0; g < o; g++) {
                                    var c = G * g,
                                        l = G * (g + 1),
                                        h = b + n + c,
                                        p = b + n + l;
                                    l = b + t + l, f(b + t + c), f(h), f(l), f(h), f(p), f(l), c = r.length / 3, u((c = S.generateSideWallUV(e, r, c - 6, c - 3, c - 2, c - 1))[0]), u(c[1]), u(c[3]), u(c[1]), u(c[2]), u(c[3])
                                }
                            }
                        }

                        function h(a, b, t) {
                            m.push(a), m.push(b), m.push(t)
                        }

                        function d(a, b, t) {
                            f(a), f(b), f(t), a = r.length / 3, u((a = S.generateTopUV(e, r, a - 3, a - 2, a - 1))[0]), u(a[1]), u(a[2])
                        }

                        function f(a) {
                            r.push(m[3 * a]), r.push(m[3 * a + 1]), r.push(m[3 * a + 2])
                        }

                        function u(a) {
                            c.push(a.x), c.push(a.y)
                        }
                        var m = [],
                            v = void 0 !== b.curveSegments ? b.curveSegments : 12,
                            y = void 0 !== b.steps ? b.steps : 1,
                            _ = void 0 !== b.depth ? b.depth : 100,
                            x = void 0 === b.bevelEnabled || b.bevelEnabled,
                            w = void 0 !== b.bevelThickness ? b.bevelThickness : 6,
                            M = void 0 !== b.bevelSize ? b.bevelSize : w - 2,
                            E = void 0 !== b.bevelOffset ? b.bevelOffset : 0,
                            T = void 0 !== b.bevelSegments ? b.bevelSegments : 3,
                            D = b.extrudePath,
                            S = void 0 !== b.UVGenerator ? b.UVGenerator : Fu;
                        void 0 !== b.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), _ = b.amount);
                        var A, C = !1;
                        if (D) {
                            var L = D.getSpacedPoints(y);
                            C = !0, x = !1;
                            var R = D.computeFrenetFrames(y, !1),
                                P = new o,
                                O = new o,
                                F = new o
                        }
                        x || (E = M = w = T = 0), v = a.extractPoints(v), a = v.shape;
                        var N = v.holes;
                        if (!Ou.isClockWise(a)) {
                            a = a.reverse();
                            var I = 0;
                            for (A = N.length; I < A; I++) {
                                var B = N[I];
                                Ou.isClockWise(B) && (N[I] = B.reverse())
                            }
                        }
                        var k = Ou.triangulateShape(a, N),
                            z = a;
                        for (I = 0, A = N.length; I < A; I++) B = N[I], a = a.concat(B);
                        var U, H, G = a.length,
                            V = k.length;
                        v = [];
                        var j = 0,
                            W = z.length,
                            Y = W - 1;
                        for (U = j + 1; j < W; j++, Y++, U++) Y === W && (Y = 0), U === W && (U = 0), v[j] = g(z[j], z[Y], z[U]);
                        D = [];
                        var X = v.concat();
                        for (I = 0, A = N.length; I < A; I++) {
                            B = N[I];
                            var Z = [];
                            for (j = 0, Y = (W = B.length) - 1, U = j + 1; j < W; j++, Y++, U++) Y === W && (Y = 0), U === W && (U = 0), Z[j] = g(B[j], B[Y], B[U]);
                            D.push(Z), X = X.concat(Z)
                        }
                        for (Y = 0; Y < T; Y++) {
                            W = Y / T;
                            var J = w * Math.cos(W * Math.PI / 2);
                            for (U = M * Math.sin(W * Math.PI / 2) + E, j = 0, W = z.length; j < W; j++) {
                                var $ = t(z[j], v[j], U);
                                h($.x, $.y, -J)
                            }
                            for (I = 0, A = N.length; I < A; I++)
                                for (B = N[I], Z = D[I], j = 0, W = B.length; j < W; j++) h(($ = t(B[j], Z[j], U)).x, $.y, -J)
                        }
                        for (U = M + E, j = 0; j < G; j++) $ = x ? t(a[j], X[j], U) : a[j], C ? (O.copy(R.normals[0]).multiplyScalar($.x), P.copy(R.binormals[0]).multiplyScalar($.y), F.copy(L[0]).add(O).add(P), h(F.x, F.y, F.z)) : h($.x, $.y, 0);
                        for (W = 1; W <= y; W++)
                            for (j = 0; j < G; j++) $ = x ? t(a[j], X[j], U) : a[j], C ? (O.copy(R.normals[W]).multiplyScalar($.x), P.copy(R.binormals[W]).multiplyScalar($.y), F.copy(L[W]).add(O).add(P), h(F.x, F.y, F.z)) : h($.x, $.y, _ / y * W);
                        for (Y = T - 1; 0 <= Y; Y--) {
                            for (W = Y / T, J = w * Math.cos(W * Math.PI / 2), U = M * Math.sin(W * Math.PI / 2) + E, j = 0, W = z.length; j < W; j++) h(($ = t(z[j], v[j], U)).x, $.y, _ + J);
                            for (I = 0, A = N.length; I < A; I++)
                                for (B = N[I], Z = D[I], j = 0, W = B.length; j < W; j++) $ = t(B[j], Z[j], U), C ? h($.x, $.y + L[y - 1].y, L[y - 1].x + J) : h($.x, $.y, _ + J)
                        }! function () {
                            var a = r.length / 3;
                            if (x) {
                                var b = 0 * G;
                                for (j = 0; j < V; j++) d((H = k[j])[2] + b, H[1] + b, H[0] + b);
                                for (b = G * (y + 2 * T), j = 0; j < V; j++) d((H = k[j])[0] + b, H[1] + b, H[2] + b)
                            } else {
                                for (j = 0; j < V; j++) d((H = k[j])[2], H[1], H[0]);
                                for (j = 0; j < V; j++) d((H = k[j])[0] + G * y, H[1] + G * y, H[2] + G * y)
                            }
                            e.addGroup(a, r.length / 3 - a, 0)
                        }(),
                        function () {
                            var a = r.length / 3,
                                b = 0;
                            for (l(z, b), b += z.length, I = 0, A = N.length; I < A; I++) l(B = N[I], b), b += B.length;
                            e.addGroup(a, r.length / 3 - a, 1)
                        }()
                    }
                    X.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
                        shapes: a,
                        options: b
                    }, a = Array.isArray(a) ? a : [a];
                    for (var e = this, r = [], c = [], g = 0, l = a.length; g < l; g++) t(a[g]);
                    this.setAttribute("position", new V(r, 3)), this.setAttribute("uv", new V(c, 2)), this.computeVertexNormals()
                }

                function ei(a, b, t) {
                    if (t.shapes = [], Array.isArray(a))
                        for (var e = 0, n = a.length; e < n; e++) t.shapes.push(a[e].uuid);
                    else t.shapes.push(a.uuid);
                    return void 0 !== b.extrudePath && (t.options.extrudePath = b.extrudePath.toJSON()), t
                }

                function ni(a, b) {
                    Q.call(this), this.type = "TextGeometry", this.parameters = {
                        text: a,
                        parameters: b
                    }, this.fromBufferGeometry(new ii(a, b)), this.mergeVertices()
                }

                function ii(a, b) {
                    var t = (b = b || {}).font;
                    if (!t || !t.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new Q;
                    a = t.generateShapes(a, b.size), b.depth = void 0 !== b.height ? b.height : 50, void 0 === b.bevelThickness && (b.bevelThickness = 10), void 0 === b.bevelSize && (b.bevelSize = 8), void 0 === b.bevelEnabled && (b.bevelEnabled = !1), ti.call(this, a, b), this.type = "TextBufferGeometry"
                }

                function ri(a, b, t, e, n, r, g) {
                    Q.call(this), this.type = "SphereGeometry", this.parameters = {
                        radius: a,
                        widthSegments: b,
                        heightSegments: t,
                        phiStart: e,
                        phiLength: n,
                        thetaStart: r,
                        thetaLength: g
                    }, this.fromBufferGeometry(new ai(a, b, t, e, n, r, g)), this.mergeVertices()
                }

                function ai(a, b, t, e, n, r, g) {
                    X.call(this), this.type = "SphereBufferGeometry", this.parameters = {
                        radius: a,
                        widthSegments: b,
                        heightSegments: t,
                        phiStart: e,
                        phiLength: n,
                        thetaStart: r,
                        thetaLength: g
                    }, a = a || 1, b = Math.max(3, Math.floor(b) || 8), t = Math.max(2, Math.floor(t) || 6), e = void 0 !== e ? e : 0, n = void 0 !== n ? n : 2 * Math.PI, r = void 0 !== r ? r : 0, g = void 0 !== g ? g : Math.PI;
                    var c, l, h = Math.min(r + g, Math.PI),
                        d = 0,
                        p = [],
                        q = new o,
                        f = new o,
                        m = [],
                        u = [],
                        v = [],
                        y = [];
                    for (l = 0; l <= t; l++) {
                        var _ = [],
                            x = l / t,
                            w = 0;
                        for (0 == l && 0 == r ? w = .5 / b : l == t && h == Math.PI && (w = -.5 / b), c = 0; c <= b; c++) {
                            var M = c / b;
                            q.x = -a * Math.cos(e + M * n) * Math.sin(r + x * g), q.y = a * Math.cos(r + x * g), q.z = a * Math.sin(e + M * n) * Math.sin(r + x * g), u.push(q.x, q.y, q.z), f.copy(q).normalize(), v.push(f.x, f.y, f.z), y.push(M + w, 1 - x), _.push(d++)
                        }
                        p.push(_)
                    }
                    for (l = 0; l < t; l++)
                        for (c = 0; c < b; c++) a = p[l][c + 1], e = p[l][c], n = p[l + 1][c], g = p[l + 1][c + 1], (0 !== l || 0 < r) && m.push(a, e, g), (l !== t - 1 || h < Math.PI) && m.push(e, n, g);
                    this.setIndex(m), this.setAttribute("position", new V(u, 3)), this.setAttribute("normal", new V(v, 3)), this.setAttribute("uv", new V(y, 2))
                }

                function oi(a, b, t, e, n, r) {
                    Q.call(this), this.type = "RingGeometry", this.parameters = {
                        innerRadius: a,
                        outerRadius: b,
                        thetaSegments: t,
                        phiSegments: e,
                        thetaStart: n,
                        thetaLength: r
                    }, this.fromBufferGeometry(new si(a, b, t, e, n, r)), this.mergeVertices()
                }

                function si(a, b, t, e, r, c) {
                    X.call(this), this.type = "RingBufferGeometry", this.parameters = {
                        innerRadius: a,
                        outerRadius: b,
                        thetaSegments: t,
                        phiSegments: e,
                        thetaStart: r,
                        thetaLength: c
                    }, a = a || .5, b = b || 1, r = void 0 !== r ? r : 0, c = void 0 !== c ? c : 2 * Math.PI, t = void 0 !== t ? Math.max(3, t) : 8;
                    var l, u, g = [],
                        h = [],
                        d = [],
                        f = [],
                        m = a,
                        p = (b - a) / (e = void 0 !== e ? Math.max(1, e) : 1),
                        q = new o,
                        v = new n;
                    for (l = 0; l <= e; l++) {
                        for (u = 0; u <= t; u++) a = r + u / t * c, q.x = m * Math.cos(a), q.y = m * Math.sin(a), h.push(q.x, q.y, q.z), d.push(0, 0, 1), v.x = (q.x / b + 1) / 2, v.y = (q.y / b + 1) / 2, f.push(v.x, v.y);
                        m += p
                    }
                    for (l = 0; l < e; l++)
                        for (b = l * (t + 1), u = 0; u < t; u++) r = (a = u + b) + t + 1, c = a + t + 2, m = a + 1, g.push(a, r, m), g.push(r, c, m);
                    this.setIndex(g), this.setAttribute("position", new V(h, 3)), this.setAttribute("normal", new V(d, 3)), this.setAttribute("uv", new V(f, 2))
                }

                function ui(a, b, t, e) {
                    Q.call(this), this.type = "LatheGeometry", this.parameters = {
                        points: a,
                        segments: b,
                        phiStart: t,
                        phiLength: e
                    }, this.fromBufferGeometry(new ci(a, b, t, e)), this.mergeVertices()
                }

                function ci(a, b, t, e) {
                    X.call(this), this.type = "LatheBufferGeometry", this.parameters = {
                        points: a,
                        segments: b,
                        phiStart: t,
                        phiLength: e
                    }, b = Math.floor(b) || 12, t = t || 0, e = e || 2 * Math.PI, e = Va.clamp(e, 0, 2 * Math.PI);
                    var r, c = [],
                        l = [],
                        g = [],
                        h = 1 / b,
                        d = new o,
                        f = new n;
                    for (r = 0; r <= b; r++) {
                        var p = t + r * h * e,
                            q = Math.sin(p),
                            m = Math.cos(p);
                        for (p = 0; p <= a.length - 1; p++) d.x = a[p].x * q, d.y = a[p].y, d.z = a[p].x * m, l.push(d.x, d.y, d.z), f.x = r / b, f.y = p / (a.length - 1), g.push(f.x, f.y)
                    }
                    for (r = 0; r < b; r++)
                        for (p = 0; p < a.length - 1; p++) h = (t = p + r * a.length) + a.length, d = t + a.length + 1, f = t + 1, c.push(t, h, f), c.push(h, d, f);
                    if (this.setIndex(c), this.setAttribute("position", new V(l, 3)), this.setAttribute("uv", new V(g, 2)), this.computeVertexNormals(), e === 2 * Math.PI)
                        for (e = this.attributes.normal.array, c = new o, l = new o, g = new o, t = b * a.length * 3, p = r = 0; r < a.length; r++, p += 3) c.x = e[p + 0], c.y = e[p + 1], c.z = e[p + 2], l.x = e[t + p + 0], l.y = e[t + p + 1], l.z = e[t + p + 2], g.addVectors(c, l).normalize(), e[p + 0] = e[t + p + 0] = g.x, e[p + 1] = e[t + p + 1] = g.y, e[p + 2] = e[t + p + 2] = g.z
                }

                function hi(a, b) {
                    Q.call(this), this.type = "ShapeGeometry", "object" == typeof b && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), b = b.curveSegments), this.parameters = {
                        shapes: a,
                        curveSegments: b
                    }, this.fromBufferGeometry(new di(a, b)), this.mergeVertices()
                }

                function di(a, b) {
                    function t(a) {
                        var t, o = n.length / 3,
                            l = (a = a.extractPoints(b)).shape,
                            h = a.holes;
                        for (!1 === Ou.isClockWise(l) && (l = l.reverse()), a = 0, t = h.length; a < t; a++) {
                            var d = h[a];
                            !0 === Ou.isClockWise(d) && (h[a] = d.reverse())
                        }
                        var f = Ou.triangulateShape(l, h);
                        for (a = 0, t = h.length; a < t; a++) d = h[a], l = l.concat(d);
                        for (a = 0, t = l.length; a < t; a++) d = l[a], n.push(d.x, d.y, 0), r.push(0, 0, 1), g.push(d.x, d.y);
                        for (a = 0, t = f.length; a < t; a++) l = f[a], e.push(l[0] + o, l[1] + o, l[2] + o), c += 3
                    }
                    X.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
                        shapes: a,
                        curveSegments: b
                    }, b = b || 12;
                    var e = [],
                        n = [],
                        r = [],
                        g = [],
                        o = 0,
                        c = 0;
                    if (!1 === Array.isArray(a)) t(a);
                    else
                        for (var l = 0; l < a.length; l++) t(a[l]), this.addGroup(o, c, l), o += c, c = 0;
                    this.setIndex(e), this.setAttribute("position", new V(n, 3)), this.setAttribute("normal", new V(r, 3)), this.setAttribute("uv", new V(g, 2))
                }

                function pi(a, b) {
                    if (b.shapes = [], Array.isArray(a))
                        for (var t = 0, e = a.length; t < e; t++) b.shapes.push(a[t].uuid);
                    else b.shapes.push(a.uuid);
                    return b
                }

                function fi(a, b) {
                    X.call(this), this.type = "EdgesGeometry", this.parameters = {
                        thresholdAngle: b
                    };
                    var t = [];
                    b = Math.cos(Va.DEG2RAD * (void 0 !== b ? b : 1));
                    var e = [0, 0],
                        n = {},
                        r = ["a", "b", "c"];
                    if (a.isBufferGeometry) {
                        var g = new Q;
                        g.fromBufferGeometry(a)
                    } else g = a.clone();
                    g.mergeVertices(), g.computeFaceNormals(), a = g.vertices;
                    for (var o = 0, c = (g = g.faces).length; o < c; o++)
                        for (var l = g[o], h = 0; 3 > h; h++) {
                            var p = l[r[h]],
                                q = l[r[(h + 1) % 3]];
                            e[0] = Math.min(p, q), e[1] = Math.max(p, q), void 0 === n[p = e[0] + "," + e[1]] ? n[p] = {
                                index1: e[0],
                                index2: e[1],
                                face1: o,
                                face2: void 0
                            } : n[p].face2 = o
                        }
                    for (p in n)(void 0 === (e = n[p]).face2 || g[e.face1].normal.dot(g[e.face2].normal) <= b) && (r = a[e.index1], t.push(r.x, r.y, r.z), r = a[e.index2], t.push(r.x, r.y, r.z));
                    this.setAttribute("position", new V(t, 3))
                }

                function mi(a, b, t, e, n, r, g, o) {
                    Q.call(this), this.type = "CylinderGeometry", this.parameters = {
                        radiusTop: a,
                        radiusBottom: b,
                        height: t,
                        radialSegments: e,
                        heightSegments: n,
                        openEnded: r,
                        thetaStart: g,
                        thetaLength: o
                    }, this.fromBufferGeometry(new gi(a, b, t, e, n, r, g, o)), this.mergeVertices()
                }

                function gi(a, b, t, e, r, c, g, l) {
                    function h(t) {
                        var r, c = new n,
                            h = new o,
                            x = 0,
                            u = !0 === t ? a : b,
                            w = !0 === t ? 1 : -1,
                            M = v;
                        for (r = 1; r <= e; r++) p.push(0, y * w, 0), q.push(0, w, 0), m.push(.5, .5), v++;
                        var E = v;
                        for (r = 0; r <= e; r++) {
                            var T = r / e * l + g,
                                D = Math.cos(T);
                            T = Math.sin(T), h.x = u * T, h.y = y * w, h.z = u * D, p.push(h.x, h.y, h.z), q.push(0, w, 0), c.x = .5 * D + .5, c.y = .5 * T * w + .5, m.push(c.x, c.y), v++
                        }
                        for (r = 0; r < e; r++) c = M + r, h = E + r, !0 === t ? f.push(h, h + 1, c) : f.push(h + 1, h, c), x += 3;
                        d.addGroup(_, x, !0 === t ? 1 : 2), _ += x
                    }
                    X.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
                        radiusTop: a,
                        radiusBottom: b,
                        height: t,
                        radialSegments: e,
                        heightSegments: r,
                        openEnded: c,
                        thetaStart: g,
                        thetaLength: l
                    };
                    var d = this;
                    a = void 0 !== a ? a : 1, b = void 0 !== b ? b : 1, t = t || 1, e = Math.floor(e) || 8, r = Math.floor(r) || 1, c = void 0 !== c && c, g = void 0 !== g ? g : 0, l = void 0 !== l ? l : 2 * Math.PI;
                    var f = [],
                        p = [],
                        q = [],
                        m = [],
                        v = 0,
                        u = [],
                        y = t / 2,
                        _ = 0;
                    ! function () {
                        var n, c, h = new o,
                            x = new o,
                            w = 0,
                            M = (b - a) / t;
                        for (c = 0; c <= r; c++) {
                            var E = [],
                                T = c / r,
                                D = T * (b - a) + a;
                            for (n = 0; n <= e; n++) {
                                var S = n / e,
                                    A = S * l + g,
                                    C = Math.sin(A);
                                A = Math.cos(A), x.x = D * C, x.y = -T * t + y, x.z = D * A, p.push(x.x, x.y, x.z), h.set(C, M, A).normalize(), q.push(h.x, h.y, h.z), m.push(S, 1 - T), E.push(v++)
                            }
                            u.push(E)
                        }
                        for (n = 0; n < e; n++)
                            for (c = 0; c < r; c++) h = u[c + 1][n], x = u[c + 1][n + 1], M = u[c][n + 1], f.push(u[c][n], h, M), f.push(h, x, M), w += 6;
                        d.addGroup(_, w, 0), _ += w
                    }(), !1 === c && (0 < a && h(!0), 0 < b && h(!1)), this.setIndex(f), this.setAttribute("position", new V(p, 3)), this.setAttribute("normal", new V(q, 3)), this.setAttribute("uv", new V(m, 2))
                }

                function vi(a, b, t, e, n, r, g) {
                    mi.call(this, 0, a, b, t, e, n, r, g), this.type = "ConeGeometry", this.parameters = {
                        radius: a,
                        height: b,
                        radialSegments: t,
                        heightSegments: e,
                        openEnded: n,
                        thetaStart: r,
                        thetaLength: g
                    }
                }

                function yi(a, b, t, e, n, r, g) {
                    gi.call(this, 0, a, b, t, e, n, r, g), this.type = "ConeBufferGeometry", this.parameters = {
                        radius: a,
                        height: b,
                        radialSegments: t,
                        heightSegments: e,
                        openEnded: n,
                        thetaStart: r,
                        thetaLength: g
                    }
                }

                function _i(a, b, t, e) {
                    Q.call(this), this.type = "CircleGeometry", this.parameters = {
                        radius: a,
                        segments: b,
                        thetaStart: t,
                        thetaLength: e
                    }, this.fromBufferGeometry(new xi(a, b, t, e)), this.mergeVertices()
                }

                function xi(a, b, t, e) {
                    X.call(this), this.type = "CircleBufferGeometry", this.parameters = {
                        radius: a,
                        segments: b,
                        thetaStart: t,
                        thetaLength: e
                    }, a = a || 1, b = void 0 !== b ? Math.max(3, b) : 8, t = void 0 !== t ? t : 0, e = void 0 !== e ? e : 2 * Math.PI;
                    var r, c = [],
                        l = [],
                        g = [],
                        h = [],
                        d = new o,
                        f = new n;
                    l.push(0, 0, 0), g.push(0, 0, 1), h.push(.5, .5);
                    var p = 0;
                    for (r = 3; p <= b; p++, r += 3) {
                        var q = t + p / b * e;
                        d.x = a * Math.cos(q), d.y = a * Math.sin(q), l.push(d.x, d.y, d.z), g.push(0, 0, 1), f.x = (l[r] / a + 1) / 2, f.y = (l[r + 1] / a + 1) / 2, h.push(f.x, f.y)
                    }
                    for (r = 1; r <= b; r++) c.push(r, r + 1, 0);
                    this.setIndex(c), this.setAttribute("position", new V(l, 3)), this.setAttribute("normal", new V(g, 3)), this.setAttribute("uv", new V(h, 2))
                }

                function bi(a) {
                    O.call(this), this.type = "ShadowMaterial", this.color = new A(0), this.transparent = !0, this.setValues(a)
                }

                function wi(a) {
                    et.call(this, a), this.type = "RawShaderMaterial"
                }

                function Mi(a) {
                    O.call(this), this.defines = {
                        STANDARD: ""
                    }, this.type = "MeshStandardMaterial", this.color = new A(16777215), this.roughness = 1, this.metalness = 0, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new A(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(a)
                }

                function Ei(a) {
                    Mi.call(this), this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearcoatRoughness = this.clearcoat = 0, this.sheen = null, this.clearcoatNormalScale = new n(1, 1), this.clearcoatNormalMap = null, this.transparency = 0, this.setValues(a)
                }

                function Ti(a) {
                    O.call(this), this.type = "MeshPhongMaterial", this.color = new A(16777215), this.specular = new A(1118481), this.shininess = 30, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new A(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(a)
                }

                function Di(a) {
                    O.call(this), this.defines = {
                        TOON: ""
                    }, this.type = "MeshToonMaterial", this.color = new A(16777215), this.specular = new A(1118481), this.shininess = 30, this.lightMap = this.gradientMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new A(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = this.specularMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(a)
                }

                function Si(a) {
                    O.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.fog = !1, this.setValues(a)
                }

                function Ai(a) {
                    O.call(this), this.type = "MeshLambertMaterial", this.color = new A(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new A(0), this.emissiveIntensity = 1, this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(a)
                }

                function Ci(a) {
                    O.call(this), this.defines = {
                        MATCAP: ""
                    }, this.type = "MeshMatcapMaterial", this.color = new A(16777215), this.bumpMap = this.map = this.matcap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(a)
                }

                function Li(a) {
                    an.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(a)
                }

                function Ri(a, b, t, e) {
                    this.parameterPositions = a, this._cachedIndex = 0, this.resultBuffer = void 0 !== e ? e : new b.constructor(t), this.sampleValues = b, this.valueSize = t
                }

                function Pi(a, b, t, e) {
                    Ri.call(this, a, b, t, e), this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0
                }

                function Oi(a, b, t, e) {
                    Ri.call(this, a, b, t, e)
                }

                function Fi(a, b, t, e) {
                    Ri.call(this, a, b, t, e)
                }

                function Ni(a, b, t, e) {
                    if (void 0 === a) throw Error("THREE.KeyframeTrack: track name is undefined");
                    if (void 0 === b || 0 === b.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + a);
                    this.name = a, this.times = Bu.convertArray(b, this.TimeBufferType), this.values = Bu.convertArray(t, this.ValueBufferType), this.setInterpolation(e || this.DefaultInterpolation)
                }

                function Ii(a, b, t) {
                    Ni.call(this, a, b, t)
                }

                function Bi(a, b, t, e) {
                    Ni.call(this, a, b, t, e)
                }

                function ki(a, b, t, e) {
                    Ni.call(this, a, b, t, e)
                }

                function zi(a, b, t, e) {
                    Ri.call(this, a, b, t, e)
                }

                function Ui(a, b, t, e) {
                    Ni.call(this, a, b, t, e)
                }

                function Hi(a, b, t, e) {
                    Ni.call(this, a, b, t, e)
                }

                function dd(a, b, t, e) {
                    Ni.call(this, a, b, t, e)
                }

                function Gi(a, b, t) {
                    this.name = a, this.tracks = t, this.duration = void 0 !== b ? b : -1, this.uuid = Va.generateUUID(), 0 > this.duration && this.resetDuration()
                }

                function Vi(a) {
                    if (void 0 === a.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
                    var b = function (a) {
                        switch (a.toLowerCase()) {
                            case "scalar":
                            case "double":
                            case "float":
                            case "number":
                            case "integer":
                                return ki;
                            case "vector":
                            case "vector2":
                            case "vector3":
                            case "vector4":
                                return dd;
                            case "color":
                                return Bi;
                            case "quaternion":
                                return Ui;
                            case "bool":
                            case "boolean":
                                return Ii;
                            case "string":
                                return Hi
                        }
                        throw Error("THREE.KeyframeTrack: Unsupported typeName: " + a)
                    }(a.type);
                    if (void 0 === a.times) {
                        var t = [],
                            e = [];
                        Bu.flattenJSON(a.keys, t, e, "value"), a.times = t, a.values = e
                    }
                    return void 0 !== b.parse ? b.parse(a) : new b(a.name, a.times, a.values, a.interpolation)
                }

                function ji(a, b, t) {
                    var e = this,
                        n = !1,
                        r = 0,
                        g = 0,
                        o = void 0,
                        c = [];
                    this.onStart = void 0, this.onLoad = a, this.onProgress = b, this.onError = t, this.itemStart = function (a) {
                        g++, !1 === n && void 0 !== e.onStart && e.onStart(a, r, g), n = !0
                    }, this.itemEnd = function (a) {
                        r++, void 0 !== e.onProgress && e.onProgress(a, r, g), r === g && (n = !1, void 0 !== e.onLoad) && e.onLoad()
                    }, this.itemError = function (a) {
                        void 0 !== e.onError && e.onError(a)
                    }, this.resolveURL = function (a) {
                        return o ? o(a) : a
                    }, this.setURLModifier = function (a) {
                        return o = a, this
                    }, this.addHandler = function (a, b) {
                        return c.push(a, b), this
                    }, this.removeHandler = function (a) {
                        return -1 !== (a = c.indexOf(a)) && c.splice(a, 2), this
                    }, this.getHandler = function (a) {
                        for (var b = 0, t = c.length; b < t; b += 2) {
                            var e = c[b],
                                n = c[b + 1];
                            if (e.global && (e.lastIndex = 0), e.test(a)) return n
                        }
                        return null
                    }
                }

                function Wi(a) {
                    this.manager = void 0 !== a ? a : zu, this.crossOrigin = "anonymous", this.resourcePath = this.path = ""
                }

                function Yi(a) {
                    Wi.call(this, a)
                }

                function qi(a) {
                    Wi.call(this, a)
                }

                function Xi(a) {
                    Wi.call(this, a)
                }

                function Zi(a) {
                    Wi.call(this, a)
                }

                function Ji(a) {
                    Wi.call(this, a)
                }

                function $i(a) {
                    Wi.call(this, a)
                }

                function Qi(a) {
                    Wi.call(this, a)
                }

                function Ki() {
                    this.type = "Curve", this.arcLengthDivisions = 200
                }

                function er(a, b, t, e, n, r, g, o) {
                    Ki.call(this), this.type = "EllipseCurve", this.aX = a || 0, this.aY = b || 0, this.xRadius = t || 1, this.yRadius = e || 1, this.aStartAngle = n || 0, this.aEndAngle = r || 2 * Math.PI, this.aClockwise = g || !1, this.aRotation = o || 0
                }

                function nr(a, b, t, e, n, r) {
                    er.call(this, a, b, t, t, e, n, r), this.type = "ArcCurve"
                }

                function ir() {
                    var a = 0,
                        b = 0,
                        t = 0,
                        e = 0;
                    return {
                        initCatmullRom: function (n, r, g, o, c) {
                            a = r, b = n = c * (g - n), t = -3 * r + 3 * g - 2 * n - (o = c * (o - r)), e = 2 * r - 2 * g + n + o
                        },
                        initNonuniformCatmullRom: function (n, r, g, o, c, l, h) {
                            a = r, b = n = ((r - n) / c - (g - n) / (c + l) + (g - r) / l) * l, t = -3 * r + 3 * g - 2 * n - (o = ((g - r) / l - (o - r) / (l + h) + (o - g) / h) * l), e = 2 * r - 2 * g + n + o
                        },
                        calc: function (n) {
                            var r = n * n;
                            return a + b * n + t * r + e * r * n
                        }
                    }
                }

                function rr(a, b, t, e) {
                    Ki.call(this), this.type = "CatmullRomCurve3", this.points = a || [], this.closed = b || !1, this.curveType = t || "centripetal", this.tension = e || .5
                }

                function ar(a, b, t, e, n) {
                    var r = a * a;
                    return (2 * t - 2 * e + (b = .5 * (e - b)) + (n = .5 * (n - t))) * a * r + (-3 * t + 3 * e - 2 * b - n) * r + b * a + t
                }

                function or(a, b, t, e) {
                    var n = 1 - a;
                    return n * n * b + 2 * (1 - a) * a * t + a * a * e
                }

                function sr(a, b, t, e, n) {
                    var r = 1 - a,
                        g = 1 - a;
                    return r * r * r * b + 3 * g * g * a * t + 3 * (1 - a) * a * a * e + a * a * a * n
                }

                function ur(a, b, t, e) {
                    Ki.call(this), this.type = "CubicBezierCurve", this.v0 = a || new n, this.v1 = b || new n, this.v2 = t || new n, this.v3 = e || new n
                }

                function cr(a, b, t, e) {
                    Ki.call(this), this.type = "CubicBezierCurve3", this.v0 = a || new o, this.v1 = b || new o, this.v2 = t || new o, this.v3 = e || new o
                }

                function lr(a, b) {
                    Ki.call(this), this.type = "LineCurve", this.v1 = a || new n, this.v2 = b || new n
                }

                function dr(a, b) {
                    Ki.call(this), this.type = "LineCurve3", this.v1 = a || new o, this.v2 = b || new o
                }

                function pr(a, b, t) {
                    Ki.call(this), this.type = "QuadraticBezierCurve", this.v0 = a || new n, this.v1 = b || new n, this.v2 = t || new n
                }

                function fr(a, b, t) {
                    Ki.call(this), this.type = "QuadraticBezierCurve3", this.v0 = a || new o, this.v1 = b || new o, this.v2 = t || new o
                }

                function mr(a) {
                    Ki.call(this), this.type = "SplineCurve", this.points = a || []
                }

                function gr() {
                    Ki.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
                }

                function vr(a) {
                    gr.call(this), this.type = "Path", this.currentPoint = new n, a && this.setFromPoints(a)
                }

                function yr(a) {
                    vr.call(this, a), this.uuid = Va.generateUUID(), this.type = "Shape", this.holes = []
                }

                function _r(a, b) {
                    _.call(this), this.type = "Light", this.color = new A(a), this.intensity = void 0 !== b ? b : 1, this.receiveShadow = void 0
                }

                function xr(a, b, t) {
                    _r.call(this, a, t), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(_.DefaultUp), this.updateMatrix(), this.groundColor = new A(b)
                }

                function wr(a) {
                    this.camera = a, this.bias = 0, this.radius = 1, this.mapSize = new n(512, 512), this.mapPass = this.map = null, this.matrix = new m, this._frustum = new ut, this._frameExtents = new n(1, 1), this._viewportCount = 1, this._viewports = [new h(0, 0, 1, 1)]
                }

                function Mr() {
                    wr.call(this, new it(50, 1, .5, 500))
                }

                function Er(a, b, t, e, n, r) {
                    _r.call(this, a, b), this.type = "SpotLight", this.position.copy(_.DefaultUp), this.updateMatrix(), this.target = new _, Object.defineProperty(this, "power", {
                        get: function () {
                            return this.intensity * Math.PI
                        },
                        set: function (a) {
                            this.intensity = a / Math.PI
                        }
                    }), this.distance = void 0 !== t ? t : 0, this.angle = void 0 !== e ? e : Math.PI / 3, this.penumbra = void 0 !== n ? n : 0, this.decay = void 0 !== r ? r : 1, this.shadow = new Mr
                }

                function Tr() {
                    wr.call(this, new it(90, 1, .5, 500)), this._frameExtents = new n(4, 2), this._viewportCount = 6, this._viewports = [new h(2, 1, 1, 1), new h(0, 1, 1, 1), new h(3, 1, 1, 1), new h(1, 1, 1, 1), new h(3, 0, 1, 1), new h(1, 0, 1, 1)], this._cubeDirections = [new o(1, 0, 0), new o(-1, 0, 0), new o(0, 0, 1), new o(0, 0, -1), new o(0, 1, 0), new o(0, -1, 0)], this._cubeUps = [new o(0, 1, 0), new o(0, 1, 0), new o(0, 1, 0), new o(0, 1, 0), new o(0, 0, 1), new o(0, 0, -1)]
                }

                function Dr(a, b, t, e) {
                    _r.call(this, a, b), this.type = "PointLight", Object.defineProperty(this, "power", {
                        get: function () {
                            return 4 * this.intensity * Math.PI
                        },
                        set: function (a) {
                            this.intensity = a / (4 * Math.PI)
                        }
                    }), this.distance = void 0 !== t ? t : 0, this.decay = void 0 !== e ? e : 1, this.shadow = new Tr
                }

                function Sr(a, b, t, e, n, r) {
                    nt.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== a ? a : -1, this.right = void 0 !== b ? b : 1, this.top = void 0 !== t ? t : 1, this.bottom = void 0 !== e ? e : -1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== r ? r : 2e3, this.updateProjectionMatrix()
                }

                function Ar() {
                    wr.call(this, new Sr(-5, 5, 5, -5, .5, 500))
                }

                function Cr(a, b) {
                    _r.call(this, a, b), this.type = "DirectionalLight", this.position.copy(_.DefaultUp), this.updateMatrix(), this.target = new _, this.shadow = new Ar
                }

                function Lr(a, b) {
                    _r.call(this, a, b), this.type = "AmbientLight", this.castShadow = void 0
                }

                function Rr(a, b, t, e) {
                    _r.call(this, a, b), this.type = "RectAreaLight", this.width = void 0 !== t ? t : 10, this.height = void 0 !== e ? e : 10
                }

                function Pr(a) {
                    Wi.call(this, a), this.textures = {}
                }

                function Or() {
                    X.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
                }

                function Fr(a, b, t, e) {
                    "number" == typeof t && (e = t, t = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), N.call(this, a, b, t), this.meshPerAttribute = e || 1
                }

                function Nr(a) {
                    Wi.call(this, a)
                }

                function Ir(a) {
                    Wi.call(this, a)
                }

                function Br(a) {
                    "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), Wi.call(this, a), this.options = void 0
                }

                function kr() {
                    this.type = "ShapePath", this.color = new A, this.subPaths = [], this.currentPath = null
                }

                function zr(a) {
                    this.type = "Font", this.data = a
                }

                function Ur(a) {
                    Wi.call(this, a)
                }

                function Hr(a) {
                    Wi.call(this, a)
                }

                function Gr() {
                    this.coefficients = [];
                    for (var a = 0; 9 > a; a++) this.coefficients.push(new o)
                }

                function Vr(a, b) {
                    _r.call(this, void 0, b), this.sh = void 0 !== a ? a : new Gr
                }

                function jr(a, b, t) {
                    Vr.call(this, void 0, t), a = (new A).set(a), t = (new A).set(b), b = new o(a.r, a.g, a.b), a = new o(t.r, t.g, t.b);
                    var e = (t = Math.sqrt(Math.PI)) * Math.sqrt(.75);
                    this.sh.coefficients[0].copy(b).add(a).multiplyScalar(t), this.sh.coefficients[1].copy(b).sub(a).multiplyScalar(e)
                }

                function Wr(a, b) {
                    Vr.call(this, void 0, b), a = (new A).set(a), this.sh.coefficients[0].set(a.r, a.g, a.b).multiplyScalar(2 * Math.sqrt(Math.PI))
                }

                function Yr() {
                    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new it, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new it, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
                        focus: null,
                        fov: null,
                        aspect: null,
                        near: null,
                        far: null,
                        zoom: null,
                        eyeSep: null
                    }
                }

                function qr(a) {
                    this.autoStart = void 0 === a || a, this.elapsedTime = this.oldTime = this.startTime = 0, this.running = !1
                }

                function Xr() {
                    _.call(this), this.type = "AudioListener", this.context = Qu.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new qr
                }

                function Zr(a) {
                    _.call(this), this.type = "Audio", this.listener = a, this.context = a.context, this.gain = this.context.createGain(), this.gain.connect(a.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.offset = this.loopEnd = this.loopStart = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this._pausedAt = this._startedAt = 0, this.filters = []
                }

                function Jr(a) {
                    Zr.call(this, a), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
                }

                function $r(a, b) {
                    this.analyser = a.context.createAnalyser(), this.analyser.fftSize = void 0 !== b ? b : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), a.getOutput().connect(this.analyser)
                }

                function Qr(a, b, t) {
                    switch (this.binding = a, this.valueSize = t, a = Float64Array, b) {
                        case "quaternion":
                            b = this._slerp;
                            break;
                        case "string":
                        case "bool":
                            a = Array, b = this._select;
                            break;
                        default:
                            b = this._lerp
                    }
                    this.buffer = new a(4 * t), this._mixBufferRegion = b, this.referenceCount = this.useCount = this.cumulativeWeight = 0
                }

                function Kr(a, b, t) {
                    t = t || ta.parseTrackName(b), this._targetGroup = a, this._bindings = a.subscribe_(b, t)
                }

                function ta(a, b, t) {
                    this.path = b, this.parsedPath = t || ta.parseTrackName(b), this.node = ta.findNode(a, this.parsedPath.nodeName) || a, this.rootNode = a
                }

                function ea() {
                    this.uuid = Va.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                    var a = {};
                    this._indicesByUUID = a;
                    for (var b = 0, t = arguments.length; b !== t; ++b) a[arguments[b].uuid] = b;
                    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                    var e = this;
                    this.stats = {
                        objects: {
                            get total() {
                                return e._objects.length
                            },
                            get inUse() {
                                return this.total - e.nCachedObjects_
                            }
                        },
                        get bindingsPerObject() {
                            return e._bindings.length
                        }
                    }
                }

                function li(a, b, t) {
                    this._mixer = a, this._clip = b, this._localRoot = t || null, b = (a = b.tracks).length, t = Array(b);
                    for (var e = {
                            endingStart: 2400,
                            endingEnd: 2400
                        }, n = 0; n !== b; ++n) {
                        var r = a[n].createInterpolant(null);
                        t[n] = r, r.settings = e
                    }
                    this._interpolantSettings = e, this._interpolants = t, this._propertyBindings = Array(b), this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0
                }

                function na(a) {
                    this._root = a, this._initMemoryManager(), this.time = this._accuIndex = 0, this.timeScale = 1
                }

                function ia(a, b) {
                    "string" == typeof a && (console.warn("THREE.Uniform: Type parameter is no longer needed."), a = b), this.value = a
                }

                function ra(a, b, t) {
                    Xe.call(this, a, b), this.meshPerAttribute = t || 1
                }

                function aa(a, b, t, e) {
                    this.ray = new T(a, b), this.near = t || 0, this.far = e || 1 / 0, this.camera = null, this.params = {
                        Mesh: {},
                        Line: {},
                        LOD: {},
                        Points: {
                            threshold: 1
                        },
                        Sprite: {}
                    }, Object.defineProperties(this.params, {
                        PointCloud: {
                            get: function () {
                                return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                            }
                        }
                    })
                }

                function oa(a, b) {
                    return a.distance - b.distance
                }

                function sa(a, b, t, e) {
                    if (!1 !== a.visible && (a.raycast(b, t), !0 === e)) {
                        e = 0;
                        for (var n = (a = a.children).length; e < n; e++) sa(a[e], b, t, !0)
                    }
                }

                function ua(a, b, t) {
                    return this.radius = void 0 !== a ? a : 1, this.phi = void 0 !== b ? b : 0, this.theta = void 0 !== t ? t : 0, this
                }

                function ca(a, b, t) {
                    return this.radius = void 0 !== a ? a : 1, this.theta = void 0 !== b ? b : 0, this.y = void 0 !== t ? t : 0, this
                }

                function la(a, b) {
                    this.min = void 0 !== a ? a : new n(1 / 0, 1 / 0), this.max = void 0 !== b ? b : new n(-1 / 0, -1 / 0)
                }

                function ha(a, b) {
                    this.start = void 0 !== a ? a : new o, this.end = void 0 !== b ? b : new o
                }

                function da(a) {
                    _.call(this), this.material = a, this.render = function () {}
                }

                function pa(a, b) {
                    _.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1, this.color = b, a = new X, b = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                    for (var t = 0, e = 1; 32 > t; t++, e++) {
                        var n = t / 32 * Math.PI * 2,
                            r = e / 32 * Math.PI * 2;
                        b.push(Math.cos(n), Math.sin(n), 1, Math.cos(r), Math.sin(r), 1)
                    }
                    a.setAttribute("position", new V(b, 3)), b = new an({
                        fog: !1
                    }), this.cone = new sn(a, b), this.add(this.cone), this.update()
                }

                function fa(a) {
                    for (var b = function t(a) {
                            var b = [];
                            a && a.isBone && b.push(a);
                            for (var e = 0; e < a.children.length; e++) b.push.apply(b, t(a.children[e]));
                            return b
                        }(a), t = new X, e = [], n = [], r = new A(0, 0, 1), g = new A(0, 1, 0), o = 0; o < b.length; o++) {
                        var c = b[o];
                        c.parent && c.parent.isBone && (e.push(0, 0, 0), e.push(0, 0, 0), n.push(r.r, r.g, r.b), n.push(g.r, g.g, g.b))
                    }
                    t.setAttribute("position", new V(e, 3)), t.setAttribute("color", new V(n, 3)), e = new an({
                        vertexColors: 2,
                        depthTest: !1,
                        depthWrite: !1,
                        transparent: !0
                    }), sn.call(this, t, e), this.root = a, this.bones = b, this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1
                }

                function ma(a, b, t) {
                    this.light = a, this.light.updateMatrixWorld(), this.color = t, a = new ai(b, 4, 2), b = new F({
                        wireframe: !0,
                        fog: !1
                    }), Z.call(this, a, b), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
                }

                function ga(a, b, t) {
                    _.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, (a = new En(b)).rotateY(.5 * Math.PI), this.material = new F({
                        wireframe: !0,
                        fog: !1
                    }), void 0 === this.color && (this.material.vertexColors = 2), b = a.getAttribute("position"), b = new Float32Array(3 * b.count), a.setAttribute("color", new N(b, 3)), this.add(new Z(a, this.material)), this.update()
                }

                function va(a, b, t, e) {
                    a = a || 10, b = b || 10, t = new A(void 0 !== t ? t : 4473924), e = new A(void 0 !== e ? e : 8947848);
                    var n = b / 2,
                        r = a / b,
                        g = a / 2;
                    a = [];
                    for (var o = [], c = 0, l = 0, h = -g; c <= b; c++, h += r) {
                        a.push(-g, 0, h, g, 0, h), a.push(h, 0, -g, h, 0, g);
                        var p = c === n ? t : e;
                        p.toArray(o, l), l += 3, p.toArray(o, l), l += 3, p.toArray(o, l), l += 3, p.toArray(o, l), l += 3
                    }(b = new X).setAttribute("position", new V(a, 3)), b.setAttribute("color", new V(o, 3)), t = new an({
                        vertexColors: 2
                    }), sn.call(this, b, t)
                }

                function ya(a, b, t, e, n, r) {
                    a = a || 10, b = b || 16, t = t || 8, e = e || 64, n = new A(void 0 !== n ? n : 4473924), r = new A(void 0 !== r ? r : 8947848);
                    var o, g = [],
                        c = [];
                    for (o = 0; o <= b; o++) {
                        var l = o / b * 2 * Math.PI,
                            h = Math.sin(l) * a;
                        l = Math.cos(l) * a, g.push(0, 0, 0), g.push(h, 0, l);
                        var p = 1 & o ? n : r;
                        c.push(p.r, p.g, p.b), c.push(p.r, p.g, p.b)
                    }
                    for (o = 0; o <= t; o++) {
                        p = 1 & o ? n : r;
                        var q = a - a / t * o;
                        for (b = 0; b < e; b++) l = b / e * 2 * Math.PI, h = Math.sin(l) * q, l = Math.cos(l) * q, g.push(h, 0, l), c.push(p.r, p.g, p.b), l = (b + 1) / e * 2 * Math.PI, h = Math.sin(l) * q, l = Math.cos(l) * q, g.push(h, 0, l), c.push(p.r, p.g, p.b)
                    }(a = new X).setAttribute("position", new V(g, 3)), a.setAttribute("color", new V(c, 3)), g = new an({
                        vertexColors: 2
                    }), sn.call(this, a, g)
                }

                function _a(a, b, t) {
                    _.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, void 0 === b && (b = 1), (a = new X).setAttribute("position", new V([-b, b, 0, b, b, 0, b, -b, 0, -b, -b, 0, -b, b, 0], 3)), b = new an({
                        fog: !1
                    }), this.lightPlane = new on(a, b), this.add(this.lightPlane), (a = new X).setAttribute("position", new V([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new on(a, b), this.add(this.targetLine), this.update()
                }

                function xa(a) {
                    function b(a, b, e) {
                        t(a, e), t(b, e)
                    }

                    function t(a, b) {
                        r.push(0, 0, 0), g.push(b.r, b.g, b.b), void 0 === o[a] && (o[a] = []), o[a].push(r.length / 3 - 1)
                    }
                    var e = new X,
                        n = new an({
                            color: 16777215,
                            vertexColors: 1
                        }),
                        r = [],
                        g = [],
                        o = {},
                        c = new A(16755200),
                        l = new A(16711680),
                        h = new A(43775),
                        p = new A(16777215),
                        q = new A(3355443);
                    b("n1", "n2", c), b("n2", "n4", c), b("n4", "n3", c), b("n3", "n1", c), b("f1", "f2", c), b("f2", "f4", c), b("f4", "f3", c), b("f3", "f1", c), b("n1", "f1", c), b("n2", "f2", c), b("n3", "f3", c), b("n4", "f4", c), b("p", "n1", l), b("p", "n2", l), b("p", "n3", l), b("p", "n4", l), b("u1", "u2", h), b("u2", "u3", h), b("u3", "u1", h), b("c", "t", p), b("p", "c", q), b("cn1", "cn2", q), b("cn3", "cn4", q), b("cf1", "cf2", q), b("cf3", "cf4", q), e.setAttribute("position", new V(r, 3)), e.setAttribute("color", new V(g, 3)), sn.call(this, e, n), this.camera = a, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update()
                }

                function ba(a, b, t, e, n, r, g) {
                    if (Ac.set(n, r, g).unproject(e), void 0 !== (a = b[a]))
                        for (t = t.getAttribute("position"), b = 0, e = a.length; b < e; b++) t.setXYZ(a[b], Ac.x, Ac.y, Ac.z)
                }

                function wa(a, b) {
                    this.object = a, void 0 === b && (b = 16776960), a = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
                    var t = new Float32Array(24),
                        e = new X;
                    e.setIndex(new N(a, 1)), e.setAttribute("position", new N(t, 3)), sn.call(this, e, new an({
                        color: b
                    })), this.matrixAutoUpdate = !1, this.update()
                }

                function Ma(a, b) {
                    this.type = "Box3Helper", this.box = a, b = b || 16776960, a = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
                    var t = new X;
                    t.setIndex(new N(a, 1)), t.setAttribute("position", new V([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), sn.call(this, t, new an({
                        color: b
                    })), this.geometry.computeBoundingSphere()
                }

                function Ea(a, b, t) {
                    this.type = "PlaneHelper", this.plane = a, this.size = void 0 === b ? 1 : b, a = void 0 !== t ? t : 16776960, (b = new X).setAttribute("position", new V([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), b.computeBoundingSphere(), on.call(this, b, new an({
                        color: a
                    })), (b = new X).setAttribute("position", new V([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), b.computeBoundingSphere(), this.add(new Z(b, new F({
                        color: a,
                        opacity: .2,
                        transparent: !0,
                        depthWrite: !1
                    })))
                }

                function Ta(a, b, t, e, n, r) {
                    _.call(this), void 0 === a && (a = new o(0, 0, 1)), void 0 === b && (b = new o(0, 0, 0)), void 0 === t && (t = 1), void 0 === e && (e = 16776960), void 0 === n && (n = .2 * t), void 0 === r && (r = .2 * n), void 0 === Rc && ((Rc = new X).setAttribute("position", new V([0, 0, 0, 0, 1, 0], 3)), (Pc = new gi(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(b), this.line = new on(Rc, new an({
                        color: e
                    })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Z(Pc, new F({
                        color: e
                    })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(a), this.setLength(t, n, r)
                }

                function Da(a) {
                    var b = [0, 0, 0, a = a || 1, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a];
                    (a = new X).setAttribute("position", new V(b, 3)), a.setAttribute("color", new V([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), b = new an({
                        vertexColors: 2
                    }), sn.call(this, a, b)
                }

                function Sa(a) {
                    qc = a, La(zc)
                }

                function Aa(a) {
                    var b = {
                            magFilter: 1003,
                            minFilter: 1003,
                            generateMipmaps: !1,
                            type: a ? a.type : 1009,
                            format: a ? a.format : 1023,
                            encoding: a ? a.encoding : 3002,
                            depthBuffer: !1,
                            stencilBuffer: !1
                        },
                        t = Ra(b);
                    return t.depthBuffer = !a, Yc = Ra(b), t
                }

                function Ca() {
                    Yc.dispose(), qc.setRenderTarget(null);
                    var a = qc.getSize(new n);
                    qc.setViewport(0, 0, a.x, a.y)
                }

                function La(a) {
                    var b = new x;
                    b.add(new Z(Vc[0], a)), qc.compile(b, kc)
                }

                function Ra(a) {
                    return (a = new d(3 * Fc, 3 * Fc, a)).texture.mapping = 306, a.texture.name = "PMREM.cubeUv", a.scissorTest = !0, a
                }

                function Pa(a, b, t, e) {
                    var n = 1 / qc.getPixelRatio();
                    a *= n, b *= n, t *= n, e *= n, qc.setViewport(a, b, t, e), qc.setScissor(a, b, t, e)
                }

                function Oa(a) {
                    var b = qc.autoClear;
                    qc.autoClear = !1;
                    for (var t = 1; t < Ic; t++) Fa(a, t - 1, t, Math.sqrt(Wc[t] * Wc[t] - Wc[t - 1] * Wc[t - 1]), Jc[(t - 1) % Jc.length]);
                    qc.autoClear = b
                }

                function Fa(a, b, t, e, n) {
                    Na(a, Yc, b, t, e, "latitudinal", n), Na(Yc, a, t, t, e, "longitudinal", n)
                }

                function Na(a, b, t, e, n, r, g) {
                    "latitudinal" !== r && "longitudinal" !== r && console.error("blur direction must be either latitudinal or longitudinal!");
                    var o = new x;
                    o.add(new Z(Vc[e], zc));
                    var c = zc.uniforms,
                        l = jc[t] - 1,
                        h = n / (l = isFinite(n) ? Math.PI / (2 * l) : 2 * Math.PI / 39),
                        p = isFinite(n) ? 1 + Math.floor(3 * h) : 20;
                    20 < p && console.warn("sigmaRadians, " + n + ", is too large and will clip, as it requested " + p + " samples when the maximum is set to 20");
                    for (var q = [], d = 0, f = 0; 20 > f; ++f) n = f / h, n = Math.exp(-n * n / 2), q.push(n), 0 == f ? d += n : f < p && (d += 2 * n);
                    for (f = 0; f < q.length; f++) q[f] /= d;
                    c.envMap.value = a.texture, c.samples.value = p, c.weights.value = q, c.latitudinal.value = "latitudinal" === r, g && (c.poleAxis.value = g), c.dTheta.value = l, c.mipInt.value = 8 - t, c.inputEncoding.value = Bc[a.texture.encoding], c.outputEncoding.value = Bc[a.texture.encoding], a = jc[e], n = 3 * Math.max(0, Fc - 2 * a), e = (0 === e ? 0 : 2 * Fc) + 2 * a * (4 < e ? e - 8 + 4 : 0), qc.setRenderTarget(b), Pa(n, e, 3 * a, 2 * a), qc.render(o, kc)
                }

                function Ia() {
                    var a = new n(1, 1);
                    return (a = new wi({
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            texelSize: {
                                value: a
                            },
                            inputEncoding: {
                                value: Bc[3e3]
                            },
                            outputEncoding: {
                                value: Bc[3e3]
                            }
                        },
                        vertexShader: "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.x *= -1.0;\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.y *= -1.0;\n\t} else if (face == 5.0) {\n\t\tdirection.xz *= -1.0;\n\t}\n\treturn direction;\n}\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t",
                        fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n\n\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t\n\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tvec3 outputDirection = normalize(vOutputDirection);\n\tvec2 uv;\n\tuv.y = asin(clamp(outputDirection.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;\n\tuv.x = atan(outputDirection.z, outputDirection.x) * RECIPROCAL_PI2 + 0.5;\n\tvec2 f = fract(uv / texelSize - 0.5);\n\tuv -= f * texelSize;\n\tvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x += texelSize.x;\n\tvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.y += texelSize.y;\n\tvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x -= texelSize.x;\n\tvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tvec3 tm = mix(tl, tr, f.x);\n\tvec3 bm = mix(bl, br, f.x);\n\tgl_FragColor.rgb = mix(tm, bm, f.y);\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t",
                        blending: 0,
                        depthTest: !1,
                        depthWrite: !1
                    })).type = "EquirectangularToCubeUV", a
                }

                function Ba() {
                    var a = new wi({
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            inputEncoding: {
                                value: Bc[3e3]
                            },
                            outputEncoding: {
                                value: Bc[3e3]
                            }
                        },
                        vertexShader: "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.x *= -1.0;\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.y *= -1.0;\n\t} else if (face == 5.0) {\n\t\tdirection.xz *= -1.0;\n\t}\n\treturn direction;\n}\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t",
                        fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform samplerCube envMap;\n\n\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t",
                        blending: 0,
                        depthTest: !1,
                        depthWrite: !1
                    });
                    return a.type = "CubemapToCubeUV", a
                }

                function ka(a) {
                    console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), rr.call(this, a), this.type = "catmullrom", this.closed = !0
                }

                function za(a) {
                    console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), rr.call(this, a), this.type = "catmullrom"
                }

                function Ua(a) {
                    console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), rr.call(this, a), this.type = "catmullrom"
                }
                void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function (a) {
                    return "number" == typeof a && isFinite(a) && Math.floor(a) === a
                }), void 0 === Math.sign && (Math.sign = function (a) {
                    return 0 > a ? -1 : 0 < a ? 1 : +a
                }), 0 == "name" in Function.prototype && Object.defineProperty(Function.prototype, "name", {
                    get: function () {
                        return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
                    }
                }), void 0 === Object.assign && (Object.assign = function (a) {
                    if (null == a) throw new TypeError("Cannot convert undefined or null to object");
                    for (var b = Object(a), t = 1; t < arguments.length; t++) {
                        var e = arguments[t];
                        if (null != e)
                            for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (b[n] = e[n])
                    }
                    return b
                }), Object.assign(e.prototype, {
                    addEventListener: function (a, b) {
                        void 0 === this._listeners && (this._listeners = {});
                        var t = this._listeners;
                        void 0 === t[a] && (t[a] = []), -1 === t[a].indexOf(b) && t[a].push(b)
                    },
                    hasEventListener: function (a, b) {
                        if (void 0 === this._listeners) return !1;
                        var t = this._listeners;
                        return void 0 !== t[a] && -1 !== t[a].indexOf(b)
                    },
                    removeEventListener: function (a, b) {
                        void 0 !== this._listeners && void 0 !== (a = this._listeners[a]) && -1 !== (b = a.indexOf(b)) && a.splice(b, 1)
                    },
                    dispatchEvent: function (a) {
                        if (void 0 !== this._listeners) {
                            var b = this._listeners[a.type];
                            if (void 0 !== b) {
                                a.target = this;
                                for (var t = 0, e = (b = b.slice(0)).length; t < e; t++) b[t].call(this, a)
                            }
                        }
                    }
                });
                for (var Ha = [], Ga = 0; 256 > Ga; Ga++) Ha[Ga] = (16 > Ga ? "0" : "") + Ga.toString(16);
                var Va = {
                    DEG2RAD: Math.PI / 180,
                    RAD2DEG: 180 / Math.PI,
                    generateUUID: function () {
                        var a = 4294967295 * Math.random() | 0,
                            b = 4294967295 * Math.random() | 0,
                            t = 4294967295 * Math.random() | 0,
                            e = 4294967295 * Math.random() | 0;
                        return (Ha[255 & a] + Ha[a >> 8 & 255] + Ha[a >> 16 & 255] + Ha[a >> 24 & 255] + "-" + Ha[255 & b] + Ha[b >> 8 & 255] + "-" + Ha[b >> 16 & 15 | 64] + Ha[b >> 24 & 255] + "-" + Ha[63 & t | 128] + Ha[t >> 8 & 255] + "-" + Ha[t >> 16 & 255] + Ha[t >> 24 & 255] + Ha[255 & e] + Ha[e >> 8 & 255] + Ha[e >> 16 & 255] + Ha[e >> 24 & 255]).toUpperCase()
                    },
                    clamp: function (a, b, t) {
                        return Math.max(b, Math.min(t, a))
                    },
                    euclideanModulo: function (a, b) {
                        return (a % b + b) % b
                    },
                    mapLinear: function (a, b, t, e, n) {
                        return e + (a - b) * (n - e) / (t - b)
                    },
                    lerp: function (a, b, t) {
                        return (1 - t) * a + t * b
                    },
                    smoothstep: function (a, b, t) {
                        return a <= b ? 0 : a >= t ? 1 : (a = (a - b) / (t - b)) * a * (3 - 2 * a)
                    },
                    smootherstep: function (a, b, t) {
                        return a <= b ? 0 : a >= t ? 1 : (a = (a - b) / (t - b)) * a * a * (a * (6 * a - 15) + 10)
                    },
                    randInt: function (a, b) {
                        return a + Math.floor(Math.random() * (b - a + 1))
                    },
                    randFloat: function (a, b) {
                        return a + Math.random() * (b - a)
                    },
                    randFloatSpread: function (a) {
                        return a * (.5 - Math.random())
                    },
                    degToRad: function (a) {
                        return a * Va.DEG2RAD
                    },
                    radToDeg: function (a) {
                        return a * Va.RAD2DEG
                    },
                    isPowerOfTwo: function (a) {
                        return 0 == (a & a - 1) && 0 !== a
                    },
                    ceilPowerOfTwo: function (a) {
                        return Math.pow(2, Math.ceil(Math.log(a) / Math.LN2))
                    },
                    floorPowerOfTwo: function (a) {
                        return Math.pow(2, Math.floor(Math.log(a) / Math.LN2))
                    }
                };
                Object.defineProperties(n.prototype, {
                    width: {
                        get: function () {
                            return this.x
                        },
                        set: function (a) {
                            this.x = a
                        }
                    },
                    height: {
                        get: function () {
                            return this.y
                        },
                        set: function (a) {
                            this.y = a
                        }
                    }
                }), Object.assign(n.prototype, {
                    isVector2: !0,
                    set: function (a, b) {
                        return this.x = a, this.y = b, this
                    },
                    setScalar: function (a) {
                        return this.y = this.x = a, this
                    },
                    setX: function (a) {
                        return this.x = a, this
                    },
                    setY: function (a) {
                        return this.y = a, this
                    },
                    setComponent: function (a, b) {
                        switch (a) {
                            case 0:
                                this.x = b;
                                break;
                            case 1:
                                this.y = b;
                                break;
                            default:
                                throw Error("index is out of range: " + a)
                        }
                        return this
                    },
                    getComponent: function (a) {
                        switch (a) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            default:
                                throw Error("index is out of range: " + a)
                        }
                    },
                    clone: function () {
                        return new this.constructor(this.x, this.y)
                    },
                    copy: function (a) {
                        return this.x = a.x, this.y = a.y, this
                    },
                    add: function (a, b) {
                        return void 0 !== b ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this)
                    },
                    addScalar: function (a) {
                        return this.x += a, this.y += a, this
                    },
                    addVectors: function (a, b) {
                        return this.x = a.x + b.x, this.y = a.y + b.y, this
                    },
                    addScaledVector: function (a, b) {
                        return this.x += a.x * b, this.y += a.y * b, this
                    },
                    sub: function (a, b) {
                        return void 0 !== b ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this)
                    },
                    subScalar: function (a) {
                        return this.x -= a, this.y -= a, this
                    },
                    subVectors: function (a, b) {
                        return this.x = a.x - b.x, this.y = a.y - b.y, this
                    },
                    multiply: function (a) {
                        return this.x *= a.x, this.y *= a.y, this
                    },
                    multiplyScalar: function (a) {
                        return this.x *= a, this.y *= a, this
                    },
                    divide: function (a) {
                        return this.x /= a.x, this.y /= a.y, this
                    },
                    divideScalar: function (a) {
                        return this.multiplyScalar(1 / a)
                    },
                    applyMatrix3: function (a) {
                        var b = this.x,
                            t = this.y;
                        return a = a.elements, this.x = a[0] * b + a[3] * t + a[6], this.y = a[1] * b + a[4] * t + a[7], this
                    },
                    min: function (a) {
                        return this.x = Math.min(this.x, a.x), this.y = Math.min(this.y, a.y), this
                    },
                    max: function (a) {
                        return this.x = Math.max(this.x, a.x), this.y = Math.max(this.y, a.y), this
                    },
                    clamp: function (a, b) {
                        return this.x = Math.max(a.x, Math.min(b.x, this.x)), this.y = Math.max(a.y, Math.min(b.y, this.y)), this
                    },
                    clampScalar: function (a, b) {
                        return this.x = Math.max(a, Math.min(b, this.x)), this.y = Math.max(a, Math.min(b, this.y)), this
                    },
                    clampLength: function (a, b) {
                        var t = this.length();
                        return this.divideScalar(t || 1).multiplyScalar(Math.max(a, Math.min(b, t)))
                    },
                    floor: function () {
                        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                    },
                    ceil: function () {
                        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                    },
                    round: function () {
                        return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                    },
                    roundToZero: function () {
                        return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this
                    },
                    negate: function () {
                        return this.x = -this.x, this.y = -this.y, this
                    },
                    dot: function (a) {
                        return this.x * a.x + this.y * a.y
                    },
                    cross: function (a) {
                        return this.x * a.y - this.y * a.x
                    },
                    lengthSq: function () {
                        return this.x * this.x + this.y * this.y
                    },
                    length: function () {
                        return Math.sqrt(this.x * this.x + this.y * this.y)
                    },
                    manhattanLength: function () {
                        return Math.abs(this.x) + Math.abs(this.y)
                    },
                    normalize: function () {
                        return this.divideScalar(this.length() || 1)
                    },
                    angle: function () {
                        var a = Math.atan2(this.y, this.x);
                        return 0 > a && (a += 2 * Math.PI), a
                    },
                    distanceTo: function (a) {
                        return Math.sqrt(this.distanceToSquared(a))
                    },
                    distanceToSquared: function (a) {
                        var b = this.x - a.x;
                        return b * b + (a = this.y - a.y) * a
                    },
                    manhattanDistanceTo: function (a) {
                        return Math.abs(this.x - a.x) + Math.abs(this.y - a.y)
                    },
                    setLength: function (a) {
                        return this.normalize().multiplyScalar(a)
                    },
                    lerp: function (a, b) {
                        return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this
                    },
                    lerpVectors: function (a, b, t) {
                        return this.subVectors(b, a).multiplyScalar(t).add(a)
                    },
                    equals: function (a) {
                        return a.x === this.x && a.y === this.y
                    },
                    fromArray: function (a, b) {
                        return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this
                    },
                    toArray: function (a, b) {
                        return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, a
                    },
                    fromBufferAttribute: function (a, b, t) {
                        return void 0 !== t && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = a.getX(b), this.y = a.getY(b), this
                    },
                    rotateAround: function (a, b) {
                        var t = Math.cos(b);
                        b = Math.sin(b);
                        var e = this.x - a.x,
                            n = this.y - a.y;
                        return this.x = e * t - n * b + a.x, this.y = e * b + n * t + a.y, this
                    }
                }), Object.assign(r, {
                    slerp: function (a, b, t, e) {
                        return t.copy(a).slerp(b, e)
                    },
                    slerpFlat: function (a, b, t, e, n, r, g) {
                        var o = t[e + 0],
                            c = t[e + 1],
                            l = t[e + 2];
                        t = t[e + 3], e = n[r + 0];
                        var h = n[r + 1],
                            p = n[r + 2];
                        if (t !== (n = n[r + 3]) || o !== e || c !== h || l !== p) {
                            r = 1 - g;
                            var q = o * e + c * h + l * p + t * n,
                                d = 0 <= q ? 1 : -1,
                                f = 1 - q * q;
                            f > Number.EPSILON && (f = Math.sqrt(f), q = Math.atan2(f, q * d), r = Math.sin(r * q) / f, g = Math.sin(g * q) / f), o = o * r + e * (d *= g), c = c * r + h * d, l = l * r + p * d, t = t * r + n * d, r === 1 - g && (o *= g = 1 / Math.sqrt(o * o + c * c + l * l + t * t), c *= g, l *= g, t *= g)
                        }
                        a[b] = o, a[b + 1] = c, a[b + 2] = l, a[b + 3] = t
                    }
                }), Object.defineProperties(r.prototype, {
                    x: {
                        get: function () {
                            return this._x
                        },
                        set: function (a) {
                            this._x = a, this._onChangeCallback()
                        }
                    },
                    y: {
                        get: function () {
                            return this._y
                        },
                        set: function (a) {
                            this._y = a, this._onChangeCallback()
                        }
                    },
                    z: {
                        get: function () {
                            return this._z
                        },
                        set: function (a) {
                            this._z = a, this._onChangeCallback()
                        }
                    },
                    w: {
                        get: function () {
                            return this._w
                        },
                        set: function (a) {
                            this._w = a, this._onChangeCallback()
                        }
                    }
                }), Object.assign(r.prototype, {
                    isQuaternion: !0,
                    set: function (a, b, t, e) {
                        return this._x = a, this._y = b, this._z = t, this._w = e, this._onChangeCallback(), this
                    },
                    clone: function () {
                        return new this.constructor(this._x, this._y, this._z, this._w)
                    },
                    copy: function (a) {
                        return this._x = a.x, this._y = a.y, this._z = a.z, this._w = a.w, this._onChangeCallback(), this
                    },
                    setFromEuler: function (a, b) {
                        if (!a || !a.isEuler) throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                        var t = a._x,
                            e = a._y,
                            n = a._z;
                        a = a.order;
                        var r = Math.cos,
                            g = Math.sin,
                            o = r(t / 2),
                            c = r(e / 2);
                        return r = r(n / 2), t = g(t / 2), e = g(e / 2), n = g(n / 2), "XYZ" === a ? (this._x = t * c * r + o * e * n, this._y = o * e * r - t * c * n, this._z = o * c * n + t * e * r, this._w = o * c * r - t * e * n) : "YXZ" === a ? (this._x = t * c * r + o * e * n, this._y = o * e * r - t * c * n, this._z = o * c * n - t * e * r, this._w = o * c * r + t * e * n) : "ZXY" === a ? (this._x = t * c * r - o * e * n, this._y = o * e * r + t * c * n, this._z = o * c * n + t * e * r, this._w = o * c * r - t * e * n) : "ZYX" === a ? (this._x = t * c * r - o * e * n, this._y = o * e * r + t * c * n, this._z = o * c * n - t * e * r, this._w = o * c * r + t * e * n) : "YZX" === a ? (this._x = t * c * r + o * e * n, this._y = o * e * r + t * c * n, this._z = o * c * n - t * e * r, this._w = o * c * r - t * e * n) : "XZY" === a && (this._x = t * c * r - o * e * n, this._y = o * e * r - t * c * n, this._z = o * c * n + t * e * r, this._w = o * c * r + t * e * n), !1 !== b && this._onChangeCallback(), this
                    },
                    setFromAxisAngle: function (a, b) {
                        b /= 2;
                        var t = Math.sin(b);
                        return this._x = a.x * t, this._y = a.y * t, this._z = a.z * t, this._w = Math.cos(b), this._onChangeCallback(), this
                    },
                    setFromRotationMatrix: function (a) {
                        var b = a.elements,
                            t = b[0];
                        a = b[4];
                        var e = b[8],
                            n = b[1],
                            r = b[5],
                            g = b[9],
                            o = b[2],
                            c = b[6],
                            l = t + r + (b = b[10]);
                        return 0 < l ? (t = .5 / Math.sqrt(l + 1), this._w = .25 / t, this._x = (c - g) * t, this._y = (e - o) * t, this._z = (n - a) * t) : t > r && t > b ? (t = 2 * Math.sqrt(1 + t - r - b), this._w = (c - g) / t, this._x = .25 * t, this._y = (a + n) / t, this._z = (e + o) / t) : r > b ? (t = 2 * Math.sqrt(1 + r - t - b), this._w = (e - o) / t, this._x = (a + n) / t, this._y = .25 * t, this._z = (g + c) / t) : (t = 2 * Math.sqrt(1 + b - t - r), this._w = (n - a) / t, this._x = (e + o) / t, this._y = (g + c) / t, this._z = .25 * t), this._onChangeCallback(), this
                    },
                    setFromUnitVectors: function (a, b) {
                        var t = a.dot(b) + 1;
                        return 1e-6 > t ? (t = 0, Math.abs(a.x) > Math.abs(a.z) ? (this._x = -a.y, this._y = a.x, this._z = 0) : (this._x = 0, this._y = -a.z, this._z = a.y)) : (this._x = a.y * b.z - a.z * b.y, this._y = a.z * b.x - a.x * b.z, this._z = a.x * b.y - a.y * b.x), this._w = t, this.normalize()
                    },
                    angleTo: function (a) {
                        return 2 * Math.acos(Math.abs(Va.clamp(this.dot(a), -1, 1)))
                    },
                    rotateTowards: function (a, b) {
                        var t = this.angleTo(a);
                        return 0 === t ? this : (this.slerp(a, Math.min(1, b / t)), this)
                    },
                    inverse: function () {
                        return this.conjugate()
                    },
                    conjugate: function () {
                        return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                    },
                    dot: function (a) {
                        return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w
                    },
                    lengthSq: function () {
                        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                    },
                    length: function () {
                        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                    },
                    normalize: function () {
                        var a = this.length();
                        return 0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a), this._onChangeCallback(), this
                    },
                    multiply: function (a, b) {
                        return void 0 !== b ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a)
                    },
                    premultiply: function (a) {
                        return this.multiplyQuaternions(a, this)
                    },
                    multiplyQuaternions: function (a, b) {
                        var t = a._x,
                            e = a._y,
                            n = a._z;
                        a = a._w;
                        var r = b._x,
                            g = b._y,
                            o = b._z;
                        return b = b._w, this._x = t * b + a * r + e * o - n * g, this._y = e * b + a * g + n * r - t * o, this._z = n * b + a * o + t * g - e * r, this._w = a * b - t * r - e * g - n * o, this._onChangeCallback(), this
                    },
                    slerp: function (a, b) {
                        if (0 === b) return this;
                        if (1 === b) return this.copy(a);
                        var t = this._x,
                            e = this._y,
                            n = this._z,
                            r = this._w,
                            g = r * a._w + t * a._x + e * a._y + n * a._z;
                        if (0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, g = -g) : this.copy(a), 1 <= g) return this._w = r, this._x = t, this._y = e, this._z = n, this;
                        if ((a = 1 - g * g) <= Number.EPSILON) return g = 1 - b, this._w = g * r + b * this._w, this._x = g * t + b * this._x, this._y = g * e + b * this._y, this._z = g * n + b * this._z, this.normalize(), this._onChangeCallback(), this;
                        a = Math.sqrt(a);
                        var o = Math.atan2(a, g);
                        return g = Math.sin((1 - b) * o) / a, b = Math.sin(b * o) / a, this._w = r * g + this._w * b, this._x = t * g + this._x * b, this._y = e * g + this._y * b, this._z = n * g + this._z * b, this._onChangeCallback(), this
                    },
                    equals: function (a) {
                        return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w
                    },
                    fromArray: function (a, b) {
                        return void 0 === b && (b = 0), this._x = a[b], this._y = a[b + 1], this._z = a[b + 2], this._w = a[b + 3], this._onChangeCallback(), this
                    },
                    toArray: function (a, b) {
                        return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this._x, a[b + 1] = this._y, a[b + 2] = this._z, a[b + 3] = this._w, a
                    },
                    _onChange: function (a) {
                        return this._onChangeCallback = a, this
                    },
                    _onChangeCallback: function () {}
                });
                var ja = new o,
                    Wa = new r;
                Object.assign(o.prototype, {
                    isVector3: !0,
                    set: function (a, b, t) {
                        return this.x = a, this.y = b, this.z = t, this
                    },
                    setScalar: function (a) {
                        return this.z = this.y = this.x = a, this
                    },
                    setX: function (a) {
                        return this.x = a, this
                    },
                    setY: function (a) {
                        return this.y = a, this
                    },
                    setZ: function (a) {
                        return this.z = a, this
                    },
                    setComponent: function (a, b) {
                        switch (a) {
                            case 0:
                                this.x = b;
                                break;
                            case 1:
                                this.y = b;
                                break;
                            case 2:
                                this.z = b;
                                break;
                            default:
                                throw Error("index is out of range: " + a)
                        }
                        return this
                    },
                    getComponent: function (a) {
                        switch (a) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            default:
                                throw Error("index is out of range: " + a)
                        }
                    },
                    clone: function () {
                        return new this.constructor(this.x, this.y, this.z)
                    },
                    copy: function (a) {
                        return this.x = a.x, this.y = a.y, this.z = a.z, this
                    },
                    add: function (a, b) {
                        return void 0 !== b ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this.z += a.z, this)
                    },
                    addScalar: function (a) {
                        return this.x += a, this.y += a, this.z += a, this
                    },
                    addVectors: function (a, b) {
                        return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this
                    },
                    addScaledVector: function (a, b) {
                        return this.x += a.x * b, this.y += a.y * b, this.z += a.z * b, this
                    },
                    sub: function (a, b) {
                        return void 0 !== b ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this.z -= a.z, this)
                    },
                    subScalar: function (a) {
                        return this.x -= a, this.y -= a, this.z -= a, this
                    },
                    subVectors: function (a, b) {
                        return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this
                    },
                    multiply: function (a, b) {
                        return void 0 !== b ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(a, b)) : (this.x *= a.x, this.y *= a.y, this.z *= a.z, this)
                    },
                    multiplyScalar: function (a) {
                        return this.x *= a, this.y *= a, this.z *= a, this
                    },
                    multiplyVectors: function (a, b) {
                        return this.x = a.x * b.x, this.y = a.y * b.y, this.z = a.z * b.z, this
                    },
                    applyEuler: function (a) {
                        return a && a.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Wa.setFromEuler(a))
                    },
                    applyAxisAngle: function (a, b) {
                        return this.applyQuaternion(Wa.setFromAxisAngle(a, b))
                    },
                    applyMatrix3: function (a) {
                        var b = this.x,
                            t = this.y,
                            e = this.z;
                        return a = a.elements, this.x = a[0] * b + a[3] * t + a[6] * e, this.y = a[1] * b + a[4] * t + a[7] * e, this.z = a[2] * b + a[5] * t + a[8] * e, this
                    },
                    applyNormalMatrix: function (a) {
                        return this.applyMatrix3(a).normalize()
                    },
                    applyMatrix4: function (a) {
                        var b = this.x,
                            t = this.y,
                            e = this.z,
                            n = 1 / ((a = a.elements)[3] * b + a[7] * t + a[11] * e + a[15]);
                        return this.x = (a[0] * b + a[4] * t + a[8] * e + a[12]) * n, this.y = (a[1] * b + a[5] * t + a[9] * e + a[13]) * n, this.z = (a[2] * b + a[6] * t + a[10] * e + a[14]) * n, this
                    },
                    applyQuaternion: function (a) {
                        var b = this.x,
                            t = this.y,
                            e = this.z,
                            n = a.x,
                            r = a.y,
                            g = a.z,
                            o = (a = a.w) * b + r * e - g * t,
                            c = a * t + g * b - n * e,
                            l = a * e + n * t - r * b;
                        return b = -n * b - r * t - g * e, this.x = o * a + b * -n + c * -g - l * -r, this.y = c * a + b * -r + l * -n - o * -g, this.z = l * a + b * -g + o * -r - c * -n, this
                    },
                    project: function (a) {
                        return this.applyMatrix4(a.matrixWorldInverse).applyMatrix4(a.projectionMatrix)
                    },
                    unproject: function (a) {
                        return this.applyMatrix4(a.projectionMatrixInverse).applyMatrix4(a.matrixWorld)
                    },
                    transformDirection: function (a) {
                        var b = this.x,
                            t = this.y,
                            e = this.z;
                        return a = a.elements, this.x = a[0] * b + a[4] * t + a[8] * e, this.y = a[1] * b + a[5] * t + a[9] * e, this.z = a[2] * b + a[6] * t + a[10] * e, this.normalize()
                    },
                    divide: function (a) {
                        return this.x /= a.x, this.y /= a.y, this.z /= a.z, this
                    },
                    divideScalar: function (a) {
                        return this.multiplyScalar(1 / a)
                    },
                    min: function (a) {
                        return this.x = Math.min(this.x, a.x), this.y = Math.min(this.y, a.y), this.z = Math.min(this.z, a.z), this
                    },
                    max: function (a) {
                        return this.x = Math.max(this.x, a.x), this.y = Math.max(this.y, a.y), this.z = Math.max(this.z, a.z), this
                    },
                    clamp: function (a, b) {
                        return this.x = Math.max(a.x, Math.min(b.x, this.x)), this.y = Math.max(a.y, Math.min(b.y, this.y)), this.z = Math.max(a.z, Math.min(b.z, this.z)), this
                    },
                    clampScalar: function (a, b) {
                        return this.x = Math.max(a, Math.min(b, this.x)), this.y = Math.max(a, Math.min(b, this.y)), this.z = Math.max(a, Math.min(b, this.z)), this
                    },
                    clampLength: function (a, b) {
                        var t = this.length();
                        return this.divideScalar(t || 1).multiplyScalar(Math.max(a, Math.min(b, t)))
                    },
                    floor: function () {
                        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                    },
                    ceil: function () {
                        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                    },
                    round: function () {
                        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                    },
                    roundToZero: function () {
                        return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this
                    },
                    negate: function () {
                        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                    },
                    dot: function (a) {
                        return this.x * a.x + this.y * a.y + this.z * a.z
                    },
                    lengthSq: function () {
                        return this.x * this.x + this.y * this.y + this.z * this.z
                    },
                    length: function () {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                    },
                    manhattanLength: function () {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                    },
                    normalize: function () {
                        return this.divideScalar(this.length() || 1)
                    },
                    setLength: function (a) {
                        return this.normalize().multiplyScalar(a)
                    },
                    lerp: function (a, b) {
                        return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this.z += (a.z - this.z) * b, this
                    },
                    lerpVectors: function (a, b, t) {
                        return this.subVectors(b, a).multiplyScalar(t).add(a)
                    },
                    cross: function (a, b) {
                        return void 0 !== b ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(a, b)) : this.crossVectors(this, a)
                    },
                    crossVectors: function (a, b) {
                        var t = a.x,
                            e = a.y;
                        a = a.z;
                        var n = b.x,
                            r = b.y;
                        return b = b.z, this.x = e * b - a * r, this.y = a * n - t * b, this.z = t * r - e * n, this
                    },
                    projectOnVector: function (a) {
                        var b = a.dot(this) / a.lengthSq();
                        return this.copy(a).multiplyScalar(b)
                    },
                    projectOnPlane: function (a) {
                        return ja.copy(this).projectOnVector(a), this.sub(ja)
                    },
                    reflect: function (a) {
                        return this.sub(ja.copy(a).multiplyScalar(2 * this.dot(a)))
                    },
                    angleTo: function (a) {
                        var b = Math.sqrt(this.lengthSq() * a.lengthSq());
                        return 0 === b && console.error("THREE.Vector3: angleTo() can't handle zero length vectors."), a = this.dot(a) / b, Math.acos(Va.clamp(a, -1, 1))
                    },
                    distanceTo: function (a) {
                        return Math.sqrt(this.distanceToSquared(a))
                    },
                    distanceToSquared: function (a) {
                        var b = this.x - a.x,
                            t = this.y - a.y;
                        return b * b + t * t + (a = this.z - a.z) * a
                    },
                    manhattanDistanceTo: function (a) {
                        return Math.abs(this.x - a.x) + Math.abs(this.y - a.y) + Math.abs(this.z - a.z)
                    },
                    setFromSpherical: function (a) {
                        return this.setFromSphericalCoords(a.radius, a.phi, a.theta)
                    },
                    setFromSphericalCoords: function (a, b, t) {
                        var e = Math.sin(b) * a;
                        return this.x = e * Math.sin(t), this.y = Math.cos(b) * a, this.z = e * Math.cos(t), this
                    },
                    setFromCylindrical: function (a) {
                        return this.setFromCylindricalCoords(a.radius, a.theta, a.y)
                    },
                    setFromCylindricalCoords: function (a, b, t) {
                        return this.x = a * Math.sin(b), this.y = t, this.z = a * Math.cos(b), this
                    },
                    setFromMatrixPosition: function (a) {
                        return a = a.elements, this.x = a[12], this.y = a[13], this.z = a[14], this
                    },
                    setFromMatrixScale: function (a) {
                        var b = this.setFromMatrixColumn(a, 0).length(),
                            t = this.setFromMatrixColumn(a, 1).length();
                        return a = this.setFromMatrixColumn(a, 2).length(), this.x = b, this.y = t, this.z = a, this
                    },
                    setFromMatrixColumn: function (a, b) {
                        return this.fromArray(a.elements, 4 * b)
                    },
                    equals: function (a) {
                        return a.x === this.x && a.y === this.y && a.z === this.z
                    },
                    fromArray: function (a, b) {
                        return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this.z = a[b + 2], this
                    },
                    toArray: function (a, b) {
                        return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, a[b + 2] = this.z, a
                    },
                    fromBufferAttribute: function (a, b, t) {
                        return void 0 !== t && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = a.getX(b), this.y = a.getY(b), this.z = a.getZ(b), this
                    }
                });
                var Ya = new o;
                Object.assign(c.prototype, {
                    isMatrix3: !0,
                    set: function (a, b, t, e, n, r, g, o, c) {
                        var l = this.elements;
                        return l[0] = a, l[1] = e, l[2] = g, l[3] = b, l[4] = n, l[5] = o, l[6] = t, l[7] = r, l[8] = c, this
                    },
                    identity: function () {
                        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                    },
                    clone: function () {
                        return (new this.constructor).fromArray(this.elements)
                    },
                    copy: function (a) {
                        var b = this.elements;
                        return a = a.elements, b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], b[5] = a[5], b[6] = a[6], b[7] = a[7], b[8] = a[8], this
                    },
                    setFromMatrix4: function (a) {
                        return a = a.elements, this.set(a[0], a[4], a[8], a[1], a[5], a[9], a[2], a[6], a[10]), this
                    },
                    applyToBufferAttribute: function (a) {
                        for (var b = 0, t = a.count; b < t; b++) Ya.x = a.getX(b), Ya.y = a.getY(b), Ya.z = a.getZ(b), Ya.applyMatrix3(this), a.setXYZ(b, Ya.x, Ya.y, Ya.z);
                        return a
                    },
                    multiply: function (a) {
                        return this.multiplyMatrices(this, a)
                    },
                    premultiply: function (a) {
                        return this.multiplyMatrices(a, this)
                    },
                    multiplyMatrices: function (a, b) {
                        var t = a.elements,
                            e = b.elements;
                        b = this.elements, a = t[0];
                        var n = t[3],
                            r = t[6],
                            g = t[1],
                            o = t[4],
                            c = t[7],
                            l = t[2],
                            h = t[5];
                        t = t[8];
                        var p = e[0],
                            q = e[3],
                            d = e[6],
                            f = e[1],
                            u = e[4],
                            m = e[7],
                            v = e[2],
                            y = e[5];
                        return e = e[8], b[0] = a * p + n * f + r * v, b[3] = a * q + n * u + r * y, b[6] = a * d + n * m + r * e, b[1] = g * p + o * f + c * v, b[4] = g * q + o * u + c * y, b[7] = g * d + o * m + c * e, b[2] = l * p + h * f + t * v, b[5] = l * q + h * u + t * y, b[8] = l * d + h * m + t * e, this
                    },
                    multiplyScalar: function (a) {
                        var b = this.elements;
                        return b[0] *= a, b[3] *= a, b[6] *= a, b[1] *= a, b[4] *= a, b[7] *= a, b[2] *= a, b[5] *= a, b[8] *= a, this
                    },
                    determinant: function () {
                        var a = this.elements,
                            b = a[0],
                            t = a[1],
                            e = a[2],
                            n = a[3],
                            r = a[4],
                            g = a[5],
                            o = a[6],
                            c = a[7];
                        return b * r * (a = a[8]) - b * g * c - t * n * a + t * g * o + e * n * c - e * r * o
                    },
                    getInverse: function (a, b) {
                        a && a.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
                        var t = a.elements;
                        a = this.elements;
                        var e = t[0],
                            n = t[1],
                            r = t[2],
                            g = t[3],
                            o = t[4],
                            c = t[5],
                            l = t[6],
                            h = t[7],
                            p = (t = t[8]) * o - c * h,
                            q = c * l - t * g,
                            d = h * g - o * l,
                            f = e * p + n * q + r * d;
                        if (0 === f) {
                            if (!0 === b) throw Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
                            return console.warn("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"), this.identity()
                        }
                        return b = 1 / f, a[0] = p * b, a[1] = (r * h - t * n) * b, a[2] = (c * n - r * o) * b, a[3] = q * b, a[4] = (t * e - r * l) * b, a[5] = (r * g - c * e) * b, a[6] = d * b, a[7] = (n * l - h * e) * b, a[8] = (o * e - n * g) * b, this
                    },
                    transpose: function () {
                        var a = this.elements,
                            b = a[1];
                        return a[1] = a[3], a[3] = b, b = a[2], a[2] = a[6], a[6] = b, b = a[5], a[5] = a[7], a[7] = b, this
                    },
                    getNormalMatrix: function (a) {
                        return this.setFromMatrix4(a).getInverse(this).transpose()
                    },
                    transposeIntoArray: function (a) {
                        var b = this.elements;
                        return a[0] = b[0], a[1] = b[3], a[2] = b[6], a[3] = b[1], a[4] = b[4], a[5] = b[7], a[6] = b[2], a[7] = b[5], a[8] = b[8], this
                    },
                    setUvTransform: function (a, b, t, e, n, r, g) {
                        var o = Math.cos(n);
                        n = Math.sin(n), this.set(t * o, t * n, -t * (o * r + n * g) + r + a, -e * n, e * o, -e * (-n * r + o * g) + g + b, 0, 0, 1)
                    },
                    scale: function (a, b) {
                        var t = this.elements;
                        return t[0] *= a, t[3] *= a, t[6] *= a, t[1] *= b, t[4] *= b, t[7] *= b, this
                    },
                    rotate: function (a) {
                        var b = Math.cos(a);
                        a = Math.sin(a);
                        var t = this.elements,
                            e = t[0],
                            n = t[3],
                            r = t[6],
                            g = t[1],
                            o = t[4],
                            c = t[7];
                        return t[0] = b * e + a * g, t[3] = b * n + a * o, t[6] = b * r + a * c, t[1] = -a * e + b * g, t[4] = -a * n + b * o, t[7] = -a * r + b * c, this
                    },
                    translate: function (a, b) {
                        var t = this.elements;
                        return t[0] += a * t[2], t[3] += a * t[5], t[6] += a * t[8], t[1] += b * t[2], t[4] += b * t[5], t[7] += b * t[8], this
                    },
                    equals: function (a) {
                        var b = this.elements;
                        a = a.elements;
                        for (var t = 0; 9 > t; t++)
                            if (b[t] !== a[t]) return !1;
                        return !0
                    },
                    fromArray: function (a, b) {
                        void 0 === b && (b = 0);
                        for (var t = 0; 9 > t; t++) this.elements[t] = a[t + b];
                        return this
                    },
                    toArray: function (a, b) {
                        void 0 === a && (a = []), void 0 === b && (b = 0);
                        var t = this.elements;
                        return a[b] = t[0], a[b + 1] = t[1], a[b + 2] = t[2], a[b + 3] = t[3], a[b + 4] = t[4], a[b + 5] = t[5], a[b + 6] = t[6], a[b + 7] = t[7], a[b + 8] = t[8], a
                    }
                });
                var qa, Xa = {
                        getDataURL: function (a) {
                            if ("undefined" == typeof HTMLCanvasElement) return a.src;
                            if (!(a instanceof HTMLCanvasElement)) {
                                void 0 === qa && (qa = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), qa.width = a.width, qa.height = a.height;
                                var b = qa.getContext("2d");
                                a instanceof ImageData ? b.putImageData(a, 0, 0) : b.drawImage(a, 0, 0, a.width, a.height), a = qa
                            }
                            return 2048 < a.width || 2048 < a.height ? a.toDataURL("image/jpeg", .6) : a.toDataURL("image/png")
                        }
                    },
                    Za = 0;
                l.DEFAULT_IMAGE = void 0, l.DEFAULT_MAPPING = 300, l.prototype = Object.assign(Object.create(e.prototype), {
                    constructor: l,
                    isTexture: !0,
                    updateMatrix: function () {
                        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                    },
                    clone: function () {
                        return (new this.constructor).copy(this)
                    },
                    copy: function (a) {
                        return this.name = a.name, this.image = a.image, this.mipmaps = a.mipmaps.slice(0), this.mapping = a.mapping, this.wrapS = a.wrapS, this.wrapT = a.wrapT, this.magFilter = a.magFilter, this.minFilter = a.minFilter, this.anisotropy = a.anisotropy, this.format = a.format, this.internalFormat = a.internalFormat, this.type = a.type, this.offset.copy(a.offset), this.repeat.copy(a.repeat), this.center.copy(a.center), this.rotation = a.rotation, this.matrixAutoUpdate = a.matrixAutoUpdate, this.matrix.copy(a.matrix), this.generateMipmaps = a.generateMipmaps, this.premultiplyAlpha = a.premultiplyAlpha, this.flipY = a.flipY, this.unpackAlignment = a.unpackAlignment, this.encoding = a.encoding, this
                    },
                    toJSON: function (a) {
                        var b = void 0 === a || "string" == typeof a;
                        if (!b && void 0 !== a.textures[this.uuid]) return a.textures[this.uuid];
                        var t = {
                            metadata: {
                                version: 4.5,
                                type: "Texture",
                                generator: "Texture.toJSON"
                            },
                            uuid: this.uuid,
                            name: this.name,
                            mapping: this.mapping,
                            repeat: [this.repeat.x, this.repeat.y],
                            offset: [this.offset.x, this.offset.y],
                            center: [this.center.x, this.center.y],
                            rotation: this.rotation,
                            wrap: [this.wrapS, this.wrapT],
                            format: this.format,
                            type: this.type,
                            encoding: this.encoding,
                            minFilter: this.minFilter,
                            magFilter: this.magFilter,
                            anisotropy: this.anisotropy,
                            flipY: this.flipY,
                            premultiplyAlpha: this.premultiplyAlpha,
                            unpackAlignment: this.unpackAlignment
                        };
                        if (void 0 !== this.image) {
                            var e = this.image;
                            if (void 0 === e.uuid && (e.uuid = Va.generateUUID()), !b && void 0 === a.images[e.uuid]) {
                                if (Array.isArray(e))
                                    for (var n = [], r = 0, g = e.length; r < g; r++) n.push(Xa.getDataURL(e[r]));
                                else n = Xa.getDataURL(e);
                                a.images[e.uuid] = {
                                    uuid: e.uuid,
                                    url: n
                                }
                            }
                            t.image = e.uuid
                        }
                        return b || (a.textures[this.uuid] = t), t
                    },
                    dispose: function () {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    },
                    transformUv: function (a) {
                        if (300 !== this.mapping) return a;
                        if (a.applyMatrix3(this.matrix), 0 > a.x || 1 < a.x) switch (this.wrapS) {
                            case 1e3:
                                a.x -= Math.floor(a.x);
                                break;
                            case 1001:
                                a.x = 0 > a.x ? 0 : 1;
                                break;
                            case 1002:
                                a.x = 1 === Math.abs(Math.floor(a.x) % 2) ? Math.ceil(a.x) - a.x : a.x - Math.floor(a.x)
                        }
                        if (0 > a.y || 1 < a.y) switch (this.wrapT) {
                            case 1e3:
                                a.y -= Math.floor(a.y);
                                break;
                            case 1001:
                                a.y = 0 > a.y ? 0 : 1;
                                break;
                            case 1002:
                                a.y = 1 === Math.abs(Math.floor(a.y) % 2) ? Math.ceil(a.y) - a.y : a.y - Math.floor(a.y)
                        }
                        return this.flipY && (a.y = 1 - a.y), a
                    }
                }), Object.defineProperty(l.prototype, "needsUpdate", {
                    set: function (a) {
                        !0 === a && this.version++
                    }
                }), Object.defineProperties(h.prototype, {
                    width: {
                        get: function () {
                            return this.z
                        },
                        set: function (a) {
                            this.z = a
                        }
                    },
                    height: {
                        get: function () {
                            return this.w
                        },
                        set: function (a) {
                            this.w = a
                        }
                    }
                }), Object.assign(h.prototype, {
                    isVector4: !0,
                    set: function (a, b, t, e) {
                        return this.x = a, this.y = b, this.z = t, this.w = e, this
                    },
                    setScalar: function (a) {
                        return this.w = this.z = this.y = this.x = a, this
                    },
                    setX: function (a) {
                        return this.x = a, this
                    },
                    setY: function (a) {
                        return this.y = a, this
                    },
                    setZ: function (a) {
                        return this.z = a, this
                    },
                    setW: function (a) {
                        return this.w = a, this
                    },
                    setComponent: function (a, b) {
                        switch (a) {
                            case 0:
                                this.x = b;
                                break;
                            case 1:
                                this.y = b;
                                break;
                            case 2:
                                this.z = b;
                                break;
                            case 3:
                                this.w = b;
                                break;
                            default:
                                throw Error("index is out of range: " + a)
                        }
                        return this
                    },
                    getComponent: function (a) {
                        switch (a) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            case 3:
                                return this.w;
                            default:
                                throw Error("index is out of range: " + a)
                        }
                    },
                    clone: function () {
                        return new this.constructor(this.x, this.y, this.z, this.w)
                    },
                    copy: function (a) {
                        return this.x = a.x, this.y = a.y, this.z = a.z, this.w = void 0 !== a.w ? a.w : 1, this
                    },
                    add: function (a, b) {
                        return void 0 !== b ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this.z += a.z, this.w += a.w, this)
                    },
                    addScalar: function (a) {
                        return this.x += a, this.y += a, this.z += a, this.w += a, this
                    },
                    addVectors: function (a, b) {
                        return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this.w = a.w + b.w, this
                    },
                    addScaledVector: function (a, b) {
                        return this.x += a.x * b, this.y += a.y * b, this.z += a.z * b, this.w += a.w * b, this
                    },
                    sub: function (a, b) {
                        return void 0 !== b ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this.z -= a.z, this.w -= a.w, this)
                    },
                    subScalar: function (a) {
                        return this.x -= a, this.y -= a, this.z -= a, this.w -= a, this
                    },
                    subVectors: function (a, b) {
                        return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this.w = a.w - b.w, this
                    },
                    multiplyScalar: function (a) {
                        return this.x *= a, this.y *= a, this.z *= a, this.w *= a, this
                    },
                    applyMatrix4: function (a) {
                        var b = this.x,
                            t = this.y,
                            e = this.z,
                            n = this.w;
                        return a = a.elements, this.x = a[0] * b + a[4] * t + a[8] * e + a[12] * n, this.y = a[1] * b + a[5] * t + a[9] * e + a[13] * n, this.z = a[2] * b + a[6] * t + a[10] * e + a[14] * n, this.w = a[3] * b + a[7] * t + a[11] * e + a[15] * n, this
                    },
                    divideScalar: function (a) {
                        return this.multiplyScalar(1 / a)
                    },
                    setAxisAngleFromQuaternion: function (a) {
                        this.w = 2 * Math.acos(a.w);
                        var b = Math.sqrt(1 - a.w * a.w);
                        return 1e-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b), this
                    },
                    setAxisAngleFromRotationMatrix: function (a) {
                        var b = (a = a.elements)[0],
                            t = a[4],
                            e = a[8],
                            n = a[1],
                            r = a[5],
                            g = a[9],
                            o = a[2],
                            c = a[6],
                            l = a[10];
                        return .01 > Math.abs(t - n) && .01 > Math.abs(e - o) && .01 > Math.abs(g - c) ? .1 > Math.abs(t + n) && .1 > Math.abs(e + o) && .1 > Math.abs(g + c) && .1 > Math.abs(b + r + l - 3) ? (this.set(1, 0, 0, 0), this) : (a = Math.PI, l = (l + 1) / 2, t = (t + n) / 4, e = (e + o) / 4, g = (g + c) / 4, (b = (b + 1) / 2) > (r = (r + 1) / 2) && b > l ? .01 > b ? (c = 0, t = o = .707106781) : (o = t / (c = Math.sqrt(b)), t = e / c) : r > l ? .01 > r ? (c = .707106781, o = 0, t = .707106781) : (c = t / (o = Math.sqrt(r)), t = g / o) : .01 > l ? (o = c = .707106781, t = 0) : (c = e / (t = Math.sqrt(l)), o = g / t), this.set(c, o, t, a), this) : (a = Math.sqrt((c - g) * (c - g) + (e - o) * (e - o) + (n - t) * (n - t)), .001 > Math.abs(a) && (a = 1), this.x = (c - g) / a, this.y = (e - o) / a, this.z = (n - t) / a, this.w = Math.acos((b + r + l - 1) / 2), this)
                    },
                    min: function (a) {
                        return this.x = Math.min(this.x, a.x), this.y = Math.min(this.y, a.y), this.z = Math.min(this.z, a.z), this.w = Math.min(this.w, a.w), this
                    },
                    max: function (a) {
                        return this.x = Math.max(this.x, a.x), this.y = Math.max(this.y, a.y), this.z = Math.max(this.z, a.z), this.w = Math.max(this.w, a.w), this
                    },
                    clamp: function (a, b) {
                        return this.x = Math.max(a.x, Math.min(b.x, this.x)), this.y = Math.max(a.y, Math.min(b.y, this.y)), this.z = Math.max(a.z, Math.min(b.z, this.z)), this.w = Math.max(a.w, Math.min(b.w, this.w)), this
                    },
                    clampScalar: function (a, b) {
                        return this.x = Math.max(a, Math.min(b, this.x)), this.y = Math.max(a, Math.min(b, this.y)), this.z = Math.max(a, Math.min(b, this.z)), this.w = Math.max(a, Math.min(b, this.w)), this
                    },
                    clampLength: function (a, b) {
                        var t = this.length();
                        return this.divideScalar(t || 1).multiplyScalar(Math.max(a, Math.min(b, t)))
                    },
                    floor: function () {
                        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                    },
                    ceil: function () {
                        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                    },
                    round: function () {
                        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                    },
                    roundToZero: function () {
                        return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), this
                    },
                    negate: function () {
                        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                    },
                    dot: function (a) {
                        return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
                    },
                    lengthSq: function () {
                        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                    },
                    length: function () {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                    },
                    manhattanLength: function () {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                    },
                    normalize: function () {
                        return this.divideScalar(this.length() || 1)
                    },
                    setLength: function (a) {
                        return this.normalize().multiplyScalar(a)
                    },
                    lerp: function (a, b) {
                        return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this.z += (a.z - this.z) * b, this.w += (a.w - this.w) * b, this
                    },
                    lerpVectors: function (a, b, t) {
                        return this.subVectors(b, a).multiplyScalar(t).add(a)
                    },
                    equals: function (a) {
                        return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w
                    },
                    fromArray: function (a, b) {
                        return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this.z = a[b + 2], this.w = a[b + 3], this
                    },
                    toArray: function (a, b) {
                        return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, a[b + 2] = this.z, a[b + 3] = this.w, a
                    },
                    fromBufferAttribute: function (a, b, t) {
                        return void 0 !== t && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = a.getX(b), this.y = a.getY(b), this.z = a.getZ(b), this.w = a.getW(b), this
                    }
                }), d.prototype = Object.assign(Object.create(e.prototype), {
                    constructor: d,
                    isWebGLRenderTarget: !0,
                    setSize: function (a, b) {
                        this.width === a && this.height === b || (this.width = a, this.height = b, this.texture.image.width = a, this.texture.image.height = b, this.dispose()), this.viewport.set(0, 0, a, b), this.scissor.set(0, 0, a, b)
                    },
                    clone: function () {
                        return (new this.constructor).copy(this)
                    },
                    copy: function (a) {
                        return this.width = a.width, this.height = a.height, this.viewport.copy(a.viewport), this.texture = a.texture.clone(), this.depthBuffer = a.depthBuffer, this.stencilBuffer = a.stencilBuffer, this.depthTexture = a.depthTexture, this
                    },
                    dispose: function () {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }), f.prototype = Object.assign(Object.create(d.prototype), {
                    constructor: f,
                    isWebGLMultisampleRenderTarget: !0,
                    copy: function (a) {
                        return d.prototype.copy.call(this, a), this.samples = a.samples, this
                    }
                });
                var Ja = new o,
                    $a = new m,
                    Qa = new o(0, 0, 0),
                    Ka = new o(1, 1, 1),
                    to = new o,
                    eo = new o,
                    no = new o;
                Object.assign(m.prototype, {
                    isMatrix4: !0,
                    set: function (a, b, t, e, n, r, g, o, c, l, h, p, q, d, f, u) {
                        var m = this.elements;
                        return m[0] = a, m[4] = b, m[8] = t, m[12] = e, m[1] = n, m[5] = r, m[9] = g, m[13] = o, m[2] = c, m[6] = l, m[10] = h, m[14] = p, m[3] = q, m[7] = d, m[11] = f, m[15] = u, this
                    },
                    identity: function () {
                        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                    },
                    clone: function () {
                        return (new m).fromArray(this.elements)
                    },
                    copy: function (a) {
                        var b = this.elements;
                        return a = a.elements, b[0] = a[0], b[1] = a[1], b[2] = a[2], b[3] = a[3], b[4] = a[4], b[5] = a[5], b[6] = a[6], b[7] = a[7], b[8] = a[8], b[9] = a[9], b[10] = a[10], b[11] = a[11], b[12] = a[12], b[13] = a[13], b[14] = a[14], b[15] = a[15], this
                    },
                    copyPosition: function (a) {
                        var b = this.elements;
                        return a = a.elements, b[12] = a[12], b[13] = a[13], b[14] = a[14], this
                    },
                    extractBasis: function (a, b, t) {
                        return a.setFromMatrixColumn(this, 0), b.setFromMatrixColumn(this, 1), t.setFromMatrixColumn(this, 2), this
                    },
                    makeBasis: function (a, b, t) {
                        return this.set(a.x, b.x, t.x, 0, a.y, b.y, t.y, 0, a.z, b.z, t.z, 0, 0, 0, 0, 1), this
                    },
                    extractRotation: function (a) {
                        var b = this.elements,
                            t = a.elements,
                            e = 1 / Ja.setFromMatrixColumn(a, 0).length(),
                            n = 1 / Ja.setFromMatrixColumn(a, 1).length();
                        return a = 1 / Ja.setFromMatrixColumn(a, 2).length(), b[0] = t[0] * e, b[1] = t[1] * e, b[2] = t[2] * e, b[3] = 0, b[4] = t[4] * n, b[5] = t[5] * n, b[6] = t[6] * n, b[7] = 0, b[8] = t[8] * a, b[9] = t[9] * a, b[10] = t[10] * a, b[11] = 0, b[12] = 0, b[13] = 0, b[14] = 0, b[15] = 1, this
                    },
                    makeRotationFromEuler: function (a) {
                        a && a.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                        var b = this.elements,
                            t = a.x,
                            e = a.y,
                            n = a.z,
                            r = Math.cos(t);
                        t = Math.sin(t);
                        var g = Math.cos(e);
                        e = Math.sin(e);
                        var o = Math.cos(n);
                        if (n = Math.sin(n), "XYZ" === a.order) {
                            a = r * o;
                            var c = r * n,
                                l = t * o,
                                h = t * n;
                            b[0] = g * o, b[4] = -g * n, b[8] = e, b[1] = c + l * e, b[5] = a - h * e, b[9] = -t * g, b[2] = h - a * e, b[6] = l + c * e, b[10] = r * g
                        } else "YXZ" === a.order ? (a = g * o, c = g * n, l = e * o, h = e * n, b[0] = a + h * t, b[4] = l * t - c, b[8] = r * e, b[1] = r * n, b[5] = r * o, b[9] = -t, b[2] = c * t - l, b[6] = h + a * t, b[10] = r * g) : "ZXY" === a.order ? (a = g * o, c = g * n, l = e * o, h = e * n, b[0] = a - h * t, b[4] = -r * n, b[8] = l + c * t, b[1] = c + l * t, b[5] = r * o, b[9] = h - a * t, b[2] = -r * e, b[6] = t, b[10] = r * g) : "ZYX" === a.order ? (a = r * o, c = r * n, l = t * o, h = t * n, b[0] = g * o, b[4] = l * e - c, b[8] = a * e + h, b[1] = g * n, b[5] = h * e + a, b[9] = c * e - l, b[2] = -e, b[6] = t * g, b[10] = r * g) : "YZX" === a.order ? (a = r * g, c = r * e, l = t * g, h = t * e, b[0] = g * o, b[4] = h - a * n, b[8] = l * n + c, b[1] = n, b[5] = r * o, b[9] = -t * o, b[2] = -e * o, b[6] = c * n + l, b[10] = a - h * n) : "XZY" === a.order && (a = r * g, c = r * e, l = t * g, h = t * e, b[0] = g * o, b[4] = -n, b[8] = e * o, b[1] = a * n + h, b[5] = r * o, b[9] = c * n - l, b[2] = l * n - c, b[6] = t * o, b[10] = h * n + a);
                        return b[3] = 0, b[7] = 0, b[11] = 0, b[12] = 0, b[13] = 0, b[14] = 0, b[15] = 1, this
                    },
                    makeRotationFromQuaternion: function (a) {
                        return this.compose(Qa, a, Ka)
                    },
                    lookAt: function (a, b, t) {
                        var e = this.elements;
                        return no.subVectors(a, b), 0 === no.lengthSq() && (no.z = 1), no.normalize(), to.crossVectors(t, no), 0 === to.lengthSq() && (1 === Math.abs(t.z) ? no.x += 1e-4 : no.z += 1e-4, no.normalize(), to.crossVectors(t, no)), to.normalize(), eo.crossVectors(no, to), e[0] = to.x, e[4] = eo.x, e[8] = no.x, e[1] = to.y, e[5] = eo.y, e[9] = no.y, e[2] = to.z, e[6] = eo.z, e[10] = no.z, this
                    },
                    multiply: function (a, b) {
                        return void 0 !== b ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a)
                    },
                    premultiply: function (a) {
                        return this.multiplyMatrices(a, this)
                    },
                    multiplyMatrices: function (a, b) {
                        var t = a.elements,
                            e = b.elements;
                        b = this.elements, a = t[0];
                        var n = t[4],
                            r = t[8],
                            g = t[12],
                            o = t[1],
                            c = t[5],
                            l = t[9],
                            h = t[13],
                            p = t[2],
                            q = t[6],
                            d = t[10],
                            f = t[14],
                            u = t[3],
                            m = t[7],
                            v = t[11];
                        t = t[15];
                        var y = e[0],
                            _ = e[4],
                            x = e[8],
                            w = e[12],
                            M = e[1],
                            E = e[5],
                            T = e[9],
                            D = e[13],
                            S = e[2],
                            A = e[6],
                            C = e[10],
                            L = e[14],
                            R = e[3],
                            P = e[7],
                            O = e[11];
                        return e = e[15], b[0] = a * y + n * M + r * S + g * R, b[4] = a * _ + n * E + r * A + g * P, b[8] = a * x + n * T + r * C + g * O, b[12] = a * w + n * D + r * L + g * e, b[1] = o * y + c * M + l * S + h * R, b[5] = o * _ + c * E + l * A + h * P, b[9] = o * x + c * T + l * C + h * O, b[13] = o * w + c * D + l * L + h * e, b[2] = p * y + q * M + d * S + f * R, b[6] = p * _ + q * E + d * A + f * P, b[10] = p * x + q * T + d * C + f * O, b[14] = p * w + q * D + d * L + f * e, b[3] = u * y + m * M + v * S + t * R, b[7] = u * _ + m * E + v * A + t * P, b[11] = u * x + m * T + v * C + t * O, b[15] = u * w + m * D + v * L + t * e, this
                    },
                    multiplyScalar: function (a) {
                        var b = this.elements;
                        return b[0] *= a, b[4] *= a, b[8] *= a, b[12] *= a, b[1] *= a, b[5] *= a, b[9] *= a, b[13] *= a, b[2] *= a, b[6] *= a, b[10] *= a, b[14] *= a, b[3] *= a, b[7] *= a, b[11] *= a, b[15] *= a, this
                    },
                    applyToBufferAttribute: function (a) {
                        for (var b = 0, t = a.count; b < t; b++) Ja.x = a.getX(b), Ja.y = a.getY(b), Ja.z = a.getZ(b), Ja.applyMatrix4(this), a.setXYZ(b, Ja.x, Ja.y, Ja.z);
                        return a
                    },
                    determinant: function () {
                        var a = this.elements,
                            b = a[0],
                            t = a[4],
                            e = a[8],
                            n = a[12],
                            r = a[1],
                            g = a[5],
                            o = a[9],
                            c = a[13],
                            l = a[2],
                            h = a[6],
                            p = a[10],
                            q = a[14];
                        return a[3] * (+n * o * h - e * c * h - n * g * p + t * c * p + e * g * q - t * o * q) + a[7] * (+b * o * q - b * c * p + n * r * p - e * r * q + e * c * l - n * o * l) + a[11] * (+b * c * h - b * g * q - n * r * h + t * r * q + n * g * l - t * c * l) + a[15] * (-e * g * l - b * o * h + b * g * p + e * r * h - t * r * p + t * o * l)
                    },
                    transpose: function () {
                        var a = this.elements,
                            b = a[1];
                        return a[1] = a[4], a[4] = b, b = a[2], a[2] = a[8], a[8] = b, b = a[6], a[6] = a[9], a[9] = b, b = a[3], a[3] = a[12], a[12] = b, b = a[7], a[7] = a[13], a[13] = b, b = a[11], a[11] = a[14], a[14] = b, this
                    },
                    setPosition: function (a, b, t) {
                        var e = this.elements;
                        return a.isVector3 ? (e[12] = a.x, e[13] = a.y, e[14] = a.z) : (e[12] = a, e[13] = b, e[14] = t), this
                    },
                    getInverse: function (a, b) {
                        var t = this.elements,
                            e = a.elements;
                        a = e[0];
                        var n = e[1],
                            r = e[2],
                            g = e[3],
                            o = e[4],
                            c = e[5],
                            l = e[6],
                            h = e[7],
                            p = e[8],
                            q = e[9],
                            d = e[10],
                            f = e[11],
                            u = e[12],
                            m = e[13],
                            v = e[14],
                            y = q * v * h - m * d * h + m * l * f - c * v * f - q * l * (e = e[15]) + c * d * e,
                            _ = u * d * h - p * v * h - u * l * f + o * v * f + p * l * e - o * d * e,
                            x = p * m * h - u * q * h + u * c * f - o * m * f - p * c * e + o * q * e,
                            w = u * q * l - p * m * l - u * c * d + o * m * d + p * c * v - o * q * v,
                            M = a * y + n * _ + r * x + g * w;
                        if (0 === M) {
                            if (!0 === b) throw Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
                            return console.warn("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"), this.identity()
                        }
                        return b = 1 / M, t[0] = y * b, t[1] = (m * d * g - q * v * g - m * r * f + n * v * f + q * r * e - n * d * e) * b, t[2] = (c * v * g - m * l * g + m * r * h - n * v * h - c * r * e + n * l * e) * b, t[3] = (q * l * g - c * d * g - q * r * h + n * d * h + c * r * f - n * l * f) * b, t[4] = _ * b, t[5] = (p * v * g - u * d * g + u * r * f - a * v * f - p * r * e + a * d * e) * b, t[6] = (u * l * g - o * v * g - u * r * h + a * v * h + o * r * e - a * l * e) * b, t[7] = (o * d * g - p * l * g + p * r * h - a * d * h - o * r * f + a * l * f) * b, t[8] = x * b, t[9] = (u * q * g - p * m * g - u * n * f + a * m * f + p * n * e - a * q * e) * b, t[10] = (o * m * g - u * c * g + u * n * h - a * m * h - o * n * e + a * c * e) * b, t[11] = (p * c * g - o * q * g - p * n * h + a * q * h + o * n * f - a * c * f) * b, t[12] = w * b, t[13] = (p * m * r - u * q * r + u * n * d - a * m * d - p * n * v + a * q * v) * b, t[14] = (u * c * r - o * m * r - u * n * l + a * m * l + o * n * v - a * c * v) * b, t[15] = (o * q * r - p * c * r + p * n * l - a * q * l - o * n * d + a * c * d) * b, this
                    },
                    scale: function (a) {
                        var b = this.elements,
                            t = a.x,
                            e = a.y;
                        return a = a.z, b[0] *= t, b[4] *= e, b[8] *= a, b[1] *= t, b[5] *= e, b[9] *= a, b[2] *= t, b[6] *= e, b[10] *= a, b[3] *= t, b[7] *= e, b[11] *= a, this
                    },
                    getMaxScaleOnAxis: function () {
                        var a = this.elements;
                        return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10]))
                    },
                    makeTranslation: function (a, b, t) {
                        return this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, t, 0, 0, 0, 1), this
                    },
                    makeRotationX: function (a) {
                        var b = Math.cos(a);
                        return a = Math.sin(a), this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1), this
                    },
                    makeRotationY: function (a) {
                        var b = Math.cos(a);
                        return a = Math.sin(a), this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1), this
                    },
                    makeRotationZ: function (a) {
                        var b = Math.cos(a);
                        return a = Math.sin(a), this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                    },
                    makeRotationAxis: function (a, b) {
                        var t = Math.cos(b);
                        b = Math.sin(b);
                        var e = 1 - t,
                            n = a.x,
                            r = a.y;
                        a = a.z;
                        var g = e * n,
                            o = e * r;
                        return this.set(g * n + t, g * r - b * a, g * a + b * r, 0, g * r + b * a, o * r + t, o * a - b * n, 0, g * a - b * r, o * a + b * n, e * a * a + t, 0, 0, 0, 0, 1), this
                    },
                    makeScale: function (a, b, t) {
                        return this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, t, 0, 0, 0, 0, 1), this
                    },
                    makeShear: function (a, b, t) {
                        return this.set(1, b, t, 0, a, 1, t, 0, a, b, 1, 0, 0, 0, 0, 1), this
                    },
                    compose: function (a, b, t) {
                        var e = this.elements,
                            n = b._x,
                            r = b._y,
                            g = b._z,
                            o = b._w,
                            c = n + n,
                            l = r + r,
                            h = g + g;
                        b = n * c;
                        var p = n * l;
                        n *= h;
                        var q = r * l;
                        r *= h, g *= h, c *= o, l *= o, o *= h, h = t.x;
                        var d = t.y;
                        return t = t.z, e[0] = (1 - (q + g)) * h, e[1] = (p + o) * h, e[2] = (n - l) * h, e[3] = 0, e[4] = (p - o) * d, e[5] = (1 - (b + g)) * d, e[6] = (r + c) * d, e[7] = 0, e[8] = (n + l) * t, e[9] = (r - c) * t, e[10] = (1 - (b + q)) * t, e[11] = 0, e[12] = a.x, e[13] = a.y, e[14] = a.z, e[15] = 1, this
                    },
                    decompose: function (a, b, t) {
                        var e = this.elements,
                            n = Ja.set(e[0], e[1], e[2]).length(),
                            r = Ja.set(e[4], e[5], e[6]).length(),
                            g = Ja.set(e[8], e[9], e[10]).length();
                        0 > this.determinant() && (n = -n), a.x = e[12], a.y = e[13], a.z = e[14], $a.copy(this), a = 1 / n, e = 1 / r;
                        var o = 1 / g;
                        return $a.elements[0] *= a, $a.elements[1] *= a, $a.elements[2] *= a, $a.elements[4] *= e, $a.elements[5] *= e, $a.elements[6] *= e, $a.elements[8] *= o, $a.elements[9] *= o, $a.elements[10] *= o, b.setFromRotationMatrix($a), t.x = n, t.y = r, t.z = g, this
                    },
                    makePerspective: function (a, b, t, e, n, r) {
                        void 0 === r && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                        var g = this.elements;
                        return g[0] = 2 * n / (b - a), g[4] = 0, g[8] = (b + a) / (b - a), g[12] = 0, g[1] = 0, g[5] = 2 * n / (t - e), g[9] = (t + e) / (t - e), g[13] = 0, g[2] = 0, g[6] = 0, g[10] = -(r + n) / (r - n), g[14] = -2 * r * n / (r - n), g[3] = 0, g[7] = 0, g[11] = -1, g[15] = 0, this
                    },
                    makeOrthographic: function (a, b, t, e, n, r) {
                        var g = this.elements,
                            o = 1 / (b - a),
                            c = 1 / (t - e),
                            l = 1 / (r - n);
                        return g[0] = 2 * o, g[4] = 0, g[8] = 0, g[12] = -(b + a) * o, g[1] = 0, g[5] = 2 * c, g[9] = 0, g[13] = -(t + e) * c, g[2] = 0, g[6] = 0, g[10] = -2 * l, g[14] = -(r + n) * l, g[3] = 0, g[7] = 0, g[11] = 0, g[15] = 1, this
                    },
                    equals: function (a) {
                        var b = this.elements;
                        a = a.elements;
                        for (var t = 0; 16 > t; t++)
                            if (b[t] !== a[t]) return !1;
                        return !0
                    },
                    fromArray: function (a, b) {
                        void 0 === b && (b = 0);
                        for (var t = 0; 16 > t; t++) this.elements[t] = a[t + b];
                        return this
                    },
                    toArray: function (a, b) {
                        void 0 === a && (a = []), void 0 === b && (b = 0);
                        var t = this.elements;
                        return a[b] = t[0], a[b + 1] = t[1], a[b + 2] = t[2], a[b + 3] = t[3], a[b + 4] = t[4], a[b + 5] = t[5], a[b + 6] = t[6], a[b + 7] = t[7], a[b + 8] = t[8], a[b + 9] = t[9], a[b + 10] = t[10], a[b + 11] = t[11], a[b + 12] = t[12], a[b + 13] = t[13], a[b + 14] = t[14], a[b + 15] = t[15], a
                    }
                });
                var io = new m,
                    ro = new r;
                v.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), v.DefaultOrder = "XYZ", Object.defineProperties(v.prototype, {
                    x: {
                        get: function () {
                            return this._x
                        },
                        set: function (a) {
                            this._x = a, this._onChangeCallback()
                        }
                    },
                    y: {
                        get: function () {
                            return this._y
                        },
                        set: function (a) {
                            this._y = a, this._onChangeCallback()
                        }
                    },
                    z: {
                        get: function () {
                            return this._z
                        },
                        set: function (a) {
                            this._z = a, this._onChangeCallback()
                        }
                    },
                    order: {
                        get: function () {
                            return this._order
                        },
                        set: function (a) {
                            this._order = a, this._onChangeCallback()
                        }
                    }
                }), Object.assign(v.prototype, {
                    isEuler: !0,
                    set: function (a, b, t, e) {
                        return this._x = a, this._y = b, this._z = t, this._order = e || this._order, this._onChangeCallback(), this
                    },
                    clone: function () {
                        return new this.constructor(this._x, this._y, this._z, this._order)
                    },
                    copy: function (a) {
                        return this._x = a._x, this._y = a._y, this._z = a._z, this._order = a._order, this._onChangeCallback(), this
                    },
                    setFromRotationMatrix: function (a, b, t) {
                        var e = Va.clamp,
                            n = a.elements;
                        a = n[0];
                        var r = n[4],
                            g = n[8],
                            o = n[1],
                            c = n[5],
                            l = n[9],
                            h = n[2],
                            p = n[6];
                        return n = n[10], "XYZ" === (b = b || this._order) ? (this._y = Math.asin(e(g, -1, 1)), .9999999 > Math.abs(g) ? (this._x = Math.atan2(-l, n), this._z = Math.atan2(-r, a)) : (this._x = Math.atan2(p, c), this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-e(l, -1, 1)), .9999999 > Math.abs(l) ? (this._y = Math.atan2(g, n), this._z = Math.atan2(o, c)) : (this._y = Math.atan2(-h, a), this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(e(p, -1, 1)), .9999999 > Math.abs(p) ? (this._y = Math.atan2(-h, n), this._z = Math.atan2(-r, c)) : (this._y = 0, this._z = Math.atan2(o, a))) : "ZYX" === b ? (this._y = Math.asin(-e(h, -1, 1)), .9999999 > Math.abs(h) ? (this._x = Math.atan2(p, n), this._z = Math.atan2(o, a)) : (this._x = 0, this._z = Math.atan2(-r, c))) : "YZX" === b ? (this._z = Math.asin(e(o, -1, 1)), .9999999 > Math.abs(o) ? (this._x = Math.atan2(-l, c), this._y = Math.atan2(-h, a)) : (this._x = 0, this._y = Math.atan2(g, n))) : "XZY" === b ? (this._z = Math.asin(-e(r, -1, 1)), .9999999 > Math.abs(r) ? (this._x = Math.atan2(p, c), this._y = Math.atan2(g, a)) : (this._x = Math.atan2(-l, n), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + b), this._order = b, !1 !== t && this._onChangeCallback(), this
                    },
                    setFromQuaternion: function (a, b, t) {
                        return io.makeRotationFromQuaternion(a), this.setFromRotationMatrix(io, b, t)
                    },
                    setFromVector3: function (a, b) {
                        return this.set(a.x, a.y, a.z, b || this._order)
                    },
                    reorder: function (a) {
                        return ro.setFromEuler(this), this.setFromQuaternion(ro, a)
                    },
                    equals: function (a) {
                        return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order
                    },
                    fromArray: function (a) {
                        return this._x = a[0], this._y = a[1], this._z = a[2], void 0 !== a[3] && (this._order = a[3]), this._onChangeCallback(), this
                    },
                    toArray: function (a, b) {
                        return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this._x, a[b + 1] = this._y, a[b + 2] = this._z, a[b + 3] = this._order, a
                    },
                    toVector3: function (a) {
                        return a ? a.set(this._x, this._y, this._z) : new o(this._x, this._y, this._z)
                    },
                    _onChange: function (a) {
                        return this._onChangeCallback = a, this
                    },
                    _onChangeCallback: function () {}
                }), Object.assign(y.prototype, {
                    set: function (a) {
                        this.mask = 1 << a | 0
                    },
                    enable: function (a) {
                        this.mask = this.mask | 1 << a | 0
                    },
                    enableAll: function () {
                        this.mask = -1
                    },
                    toggle: function (a) {
                        this.mask ^= 1 << a | 0
                    },
                    disable: function (a) {
                        this.mask &= ~(1 << a | 0)
                    },
                    disableAll: function () {
                        this.mask = 0
                    },
                    test: function (a) {
                        return 0 != (this.mask & a.mask)
                    }
                });
                var ao = 0,
                    oo = new o,
                    so = new r,
                    uo = new m,
                    co = new o,
                    lo = new o,
                    ho = new o,
                    po = new r,
                    fo = new o(1, 0, 0),
                    mo = new o(0, 1, 0),
                    go = new o(0, 0, 1),
                    vo = {
                        type: "added"
                    },
                    yo = {
                        type: "removed"
                    };
                _.DefaultUp = new o(0, 1, 0), _.DefaultMatrixAutoUpdate = !0, _.prototype = Object.assign(Object.create(e.prototype), {
                    constructor: _,
                    isObject3D: !0,
                    onBeforeRender: function () {},
                    onAfterRender: function () {},
                    applyMatrix: function (a) {
                        this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(a), this.matrix.decompose(this.position, this.quaternion, this.scale)
                    },
                    applyQuaternion: function (a) {
                        return this.quaternion.premultiply(a), this
                    },
                    setRotationFromAxisAngle: function (a, b) {
                        this.quaternion.setFromAxisAngle(a, b)
                    },
                    setRotationFromEuler: function (a) {
                        this.quaternion.setFromEuler(a, !0)
                    },
                    setRotationFromMatrix: function (a) {
                        this.quaternion.setFromRotationMatrix(a)
                    },
                    setRotationFromQuaternion: function (a) {
                        this.quaternion.copy(a)
                    },
                    rotateOnAxis: function (a, b) {
                        return so.setFromAxisAngle(a, b), this.quaternion.multiply(so), this
                    },
                    rotateOnWorldAxis: function (a, b) {
                        return so.setFromAxisAngle(a, b), this.quaternion.premultiply(so), this
                    },
                    rotateX: function (a) {
                        return this.rotateOnAxis(fo, a)
                    },
                    rotateY: function (a) {
                        return this.rotateOnAxis(mo, a)
                    },
                    rotateZ: function (a) {
                        return this.rotateOnAxis(go, a)
                    },
                    translateOnAxis: function (a, b) {
                        return oo.copy(a).applyQuaternion(this.quaternion), this.position.add(oo.multiplyScalar(b)), this
                    },
                    translateX: function (a) {
                        return this.translateOnAxis(fo, a)
                    },
                    translateY: function (a) {
                        return this.translateOnAxis(mo, a)
                    },
                    translateZ: function (a) {
                        return this.translateOnAxis(go, a)
                    },
                    localToWorld: function (a) {
                        return a.applyMatrix4(this.matrixWorld)
                    },
                    worldToLocal: function (a) {
                        return a.applyMatrix4(uo.getInverse(this.matrixWorld))
                    },
                    lookAt: function (a, b, t) {
                        a.isVector3 ? co.copy(a) : co.set(a, b, t), a = this.parent, this.updateWorldMatrix(!0, !1), lo.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? uo.lookAt(lo, co, this.up) : uo.lookAt(co, lo, this.up), this.quaternion.setFromRotationMatrix(uo), a && (uo.extractRotation(a.matrixWorld), so.setFromRotationMatrix(uo), this.quaternion.premultiply(so.inverse()))
                    },
                    add: function (a) {
                        if (1 < arguments.length) {
                            for (var b = 0; b < arguments.length; b++) this.add(arguments[b]);
                            return this
                        }
                        return a === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", a), this) : (a && a.isObject3D ? (null !== a.parent && a.parent.remove(a), a.parent = this, this.children.push(a), a.dispatchEvent(vo)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a), this)
                    },
                    remove: function (a) {
                        if (1 < arguments.length) {
                            for (var b = 0; b < arguments.length; b++) this.remove(arguments[b]);
                            return this
                        }
                        return -1 !== (b = this.children.indexOf(a)) && (a.parent = null, this.children.splice(b, 1), a.dispatchEvent(yo)), this
                    },
                    attach: function (a) {
                        return this.updateWorldMatrix(!0, !1), uo.getInverse(this.matrixWorld), null !== a.parent && (a.parent.updateWorldMatrix(!0, !1), uo.multiply(a.parent.matrixWorld)), a.applyMatrix(uo), a.updateWorldMatrix(!1, !1), this.add(a), this
                    },
                    getObjectById: function (a) {
                        return this.getObjectByProperty("id", a)
                    },
                    getObjectByName: function (a) {
                        return this.getObjectByProperty("name", a)
                    },
                    getObjectByProperty: function (a, b) {
                        if (this[a] === b) return this;
                        for (var t = 0, e = this.children.length; t < e; t++) {
                            var n = this.children[t].getObjectByProperty(a, b);
                            if (void 0 !== n) return n
                        }
                    },
                    getWorldPosition: function (a) {
                        return void 0 === a && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), a = new o), this.updateMatrixWorld(!0), a.setFromMatrixPosition(this.matrixWorld)
                    },
                    getWorldQuaternion: function (a) {
                        return void 0 === a && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), a = new r), this.updateMatrixWorld(!0), this.matrixWorld.decompose(lo, a, ho), a
                    },
                    getWorldScale: function (a) {
                        return void 0 === a && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), a = new o), this.updateMatrixWorld(!0), this.matrixWorld.decompose(lo, po, a), a
                    },
                    getWorldDirection: function (a) {
                        void 0 === a && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), a = new o), this.updateMatrixWorld(!0);
                        var b = this.matrixWorld.elements;
                        return a.set(b[8], b[9], b[10]).normalize()
                    },
                    raycast: function () {},
                    traverse: function (a) {
                        a(this);
                        for (var b = this.children, t = 0, e = b.length; t < e; t++) b[t].traverse(a)
                    },
                    traverseVisible: function (a) {
                        if (!1 !== this.visible) {
                            a(this);
                            for (var b = this.children, t = 0, e = b.length; t < e; t++) b[t].traverseVisible(a)
                        }
                    },
                    traverseAncestors: function (a) {
                        var b = this.parent;
                        null !== b && (a(b), b.traverseAncestors(a))
                    },
                    updateMatrix: function () {
                        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                    },
                    updateMatrixWorld: function (a) {
                        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || a) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0);
                        for (var b = this.children, t = 0, e = b.length; t < e; t++) b[t].updateMatrixWorld(a)
                    },
                    updateWorldMatrix: function (a, b) {
                        var t = this.parent;
                        if (!0 === a && null !== t && t.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === b)
                            for (b = 0, t = (a = this.children).length; b < t; b++) a[b].updateWorldMatrix(!1, !0)
                    },
                    toJSON: function (a) {
                        function b(b, t) {
                            return void 0 === b[t.uuid] && (b[t.uuid] = t.toJSON(a)), t.uuid
                        }

                        function t(a) {
                            var t, b = [];
                            for (t in a) {
                                var e = a[t];
                                delete e.metadata, b.push(e)
                            }
                            return b
                        }
                        var e = void 0 === a || "string" == typeof a,
                            n = {};
                        e && (a = {
                            geometries: {},
                            materials: {},
                            textures: {},
                            images: {},
                            shapes: {}
                        }, n.metadata = {
                            version: 4.5,
                            type: "Object",
                            generator: "Object3D.toJSON"
                        });
                        var r = {};
                        if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) {
                            r.geometry = b(a.geometries, this.geometry);
                            var g = this.geometry.parameters;
                            if (void 0 !== g && void 0 !== g.shapes)
                                if (g = g.shapes, Array.isArray(g))
                                    for (var o = 0, c = g.length; o < c; o++) b(a.shapes, g[o]);
                                else b(a.shapes, g)
                        }
                        if (void 0 !== this.material)
                            if (Array.isArray(this.material)) {
                                for (g = [], o = 0, c = this.material.length; o < c; o++) g.push(b(a.materials, this.material[o]));
                                r.material = g
                            } else r.material = b(a.materials, this.material);
                        if (0 < this.children.length)
                            for (r.children = [], o = 0; o < this.children.length; o++) r.children.push(this.children[o].toJSON(a).object);
                        if (e) {
                            e = t(a.geometries), o = t(a.materials), c = t(a.textures);
                            var l = t(a.images);
                            g = t(a.shapes), 0 < e.length && (n.geometries = e), 0 < o.length && (n.materials = o), 0 < c.length && (n.textures = c), 0 < l.length && (n.images = l), 0 < g.length && (n.shapes = g)
                        }
                        return n.object = r, n
                    },
                    clone: function (a) {
                        return (new this.constructor).copy(this, a)
                    },
                    copy: function (a, b) {
                        if (void 0 === b && (b = !0), this.name = a.name, this.up.copy(a.up), this.position.copy(a.position), this.quaternion.copy(a.quaternion), this.scale.copy(a.scale), this.matrix.copy(a.matrix), this.matrixWorld.copy(a.matrixWorld), this.matrixAutoUpdate = a.matrixAutoUpdate, this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate, this.layers.mask = a.layers.mask, this.visible = a.visible, this.castShadow = a.castShadow, this.receiveShadow = a.receiveShadow, this.frustumCulled = a.frustumCulled, this.renderOrder = a.renderOrder, this.userData = JSON.parse(JSON.stringify(a.userData)), !0 === b)
                            for (b = 0; b < a.children.length; b++) this.add(a.children[b].clone());
                        return this
                    }
                }), x.prototype = Object.assign(Object.create(_.prototype), {
                    constructor: x,
                    isScene: !0,
                    copy: function (a, b) {
                        return _.prototype.copy.call(this, a, b), null !== a.background && (this.background = a.background.clone()), null !== a.environment && (this.environment = a.environment.clone()), null !== a.fog && (this.fog = a.fog.clone()), null !== a.overrideMaterial && (this.overrideMaterial = a.overrideMaterial.clone()), this.autoUpdate = a.autoUpdate, this.matrixAutoUpdate = a.matrixAutoUpdate, this
                    },
                    toJSON: function (a) {
                        var b = _.prototype.toJSON.call(this, a);
                        return null !== this.background && (b.object.background = this.background.toJSON(a)), null !== this.environment && (b.object.environment = this.environment.toJSON(a)), null !== this.fog && (b.object.fog = this.fog.toJSON()), b
                    },
                    dispose: function () {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                });
                var _o = [new o, new o, new o, new o, new o, new o, new o, new o],
                    xo = new o,
                    bo = new w,
                    wo = new o,
                    Mo = new o,
                    Eo = new o,
                    To = new o,
                    Do = new o,
                    So = new o,
                    Ao = new o,
                    Co = new o,
                    Lo = new o,
                    Ro = new o;
                Object.assign(w.prototype, {
                    isBox3: !0,
                    set: function (a, b) {
                        return this.min.copy(a), this.max.copy(b), this
                    },
                    setFromArray: function (a) {
                        for (var b = 1 / 0, t = 1 / 0, e = 1 / 0, n = -1 / 0, r = -1 / 0, g = -1 / 0, o = 0, c = a.length; o < c; o += 3) {
                            var l = a[o],
                                h = a[o + 1],
                                p = a[o + 2];
                            l < b && (b = l), h < t && (t = h), p < e && (e = p), l > n && (n = l), h > r && (r = h), p > g && (g = p)
                        }
                        return this.min.set(b, t, e), this.max.set(n, r, g), this
                    },
                    setFromBufferAttribute: function (a) {
                        for (var b = 1 / 0, t = 1 / 0, e = 1 / 0, n = -1 / 0, r = -1 / 0, g = -1 / 0, o = 0, c = a.count; o < c; o++) {
                            var l = a.getX(o),
                                h = a.getY(o),
                                p = a.getZ(o);
                            l < b && (b = l), h < t && (t = h), p < e && (e = p), l > n && (n = l), h > r && (r = h), p > g && (g = p)
                        }
                        return this.min.set(b, t, e), this.max.set(n, r, g), this
                    },
                    setFromPoints: function (a) {
                        this.makeEmpty();
                        for (var b = 0, t = a.length; b < t; b++) this.expandByPoint(a[b]);
                        return this
                    },
                    setFromCenterAndSize: function (a, b) {
                        return b = xo.copy(b).multiplyScalar(.5), this.min.copy(a).sub(b), this.max.copy(a).add(b), this
                    },
                    setFromObject: function (a) {
                        return this.makeEmpty(), this.expandByObject(a)
                    },
                    clone: function () {
                        return (new this.constructor).copy(this)
                    },
                    copy: function (a) {
                        return this.min.copy(a.min), this.max.copy(a.max), this
                    },
                    makeEmpty: function () {
                        return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                    },
                    isEmpty: function () {
                        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                    },
                    getCenter: function (a) {
                        return void 0 === a && (console.warn("THREE.Box3: .getCenter() target is now required"), a = new o), this.isEmpty() ? a.set(0, 0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5)
                    },
                    getSize: function (a) {
                        return void 0 === a && (console.warn("THREE.Box3: .getSize() target is now required"), a = new o), this.isEmpty() ? a.set(0, 0, 0) : a.subVectors(this.max, this.min)
                    },
                    expandByPoint: function (a) {
                        return this.min.min(a), this.max.max(a), this
                    },
                    expandByVector: function (a) {
                        return this.min.sub(a), this.max.add(a), this
                    },
                    expandByScalar: function (a) {
                        return this.min.addScalar(-a), this.max.addScalar(a), this
                    },
                    expandByObject: function (a) {
                        a.updateWorldMatrix(!1, !1);
                        var b = a.geometry;
                        void 0 !== b && (null === b.boundingBox && b.computeBoundingBox(), bo.copy(b.boundingBox), bo.applyMatrix4(a.matrixWorld), this.expandByPoint(bo.min), this.expandByPoint(bo.max)), b = 0;
                        for (var t = (a = a.children).length; b < t; b++) this.expandByObject(a[b]);
                        return this
                    },
                    containsPoint: function (a) {
                        return !(a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z)
                    },
                    containsBox: function (a) {
                        return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z
                    },
                    getParameter: function (a, b) {
                        return void 0 === b && (console.warn("THREE.Box3: .getParameter() target is now required"), b = new o), b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z))
                    },
                    intersectsBox: function (a) {
                        return !(a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z)
                    },
                    intersectsSphere: function (a) {
                        return this.clampPoint(a.center, xo), xo.distanceToSquared(a.center) <= a.radius * a.radius
                    },
                    intersectsPlane: function (a) {
                        if (0 < a.normal.x) var b = a.normal.x * this.min.x,
                            t = a.normal.x * this.max.x;
                        else b = a.normal.x * this.max.x, t = a.normal.x * this.min.x;
                        return 0 < a.normal.y ? (b += a.normal.y * this.min.y, t += a.normal.y * this.max.y) : (b += a.normal.y * this.max.y, t += a.normal.y * this.min.y), 0 < a.normal.z ? (b += a.normal.z * this.min.z, t += a.normal.z * this.max.z) : (b += a.normal.z * this.max.z, t += a.normal.z * this.min.z), b <= -a.constant && t >= -a.constant
                    },
                    intersectsTriangle: function (a) {
                        return !this.isEmpty() && (this.getCenter(Ao), Co.subVectors(this.max, Ao), wo.subVectors(a.a, Ao), Mo.subVectors(a.b, Ao), Eo.subVectors(a.c, Ao), To.subVectors(Mo, wo), Do.subVectors(Eo, Mo), So.subVectors(wo, Eo), !!M(a = [0, -To.z, To.y, 0, -Do.z, Do.y, 0, -So.z, So.y, To.z, 0, -To.x, Do.z, 0, -Do.x, So.z, 0, -So.x, -To.y, To.x, 0, -Do.y, Do.x, 0, -So.y, So.x, 0], wo, Mo, Eo, Co) && !!M(a = [1, 0, 0, 0, 1, 0, 0, 0, 1], wo, Mo, Eo, Co) && (Lo.crossVectors(To, Do), M(a = [Lo.x, Lo.y, Lo.z], wo, Mo, Eo, Co)))
                    },
                    clampPoint: function (a, b) {
                        return void 0 === b && (console.warn("THREE.Box3: .clampPoint() target is now required"), b = new o), b.copy(a).clamp(this.min, this.max)
                    },
                    distanceToPoint: function (a) {
                        return xo.copy(a).clamp(this.min, this.max).sub(a).length()
                    },
                    getBoundingSphere: function (a) {
                        return void 0 === a && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(a.center), a.radius = .5 * this.getSize(xo).length(), a
                    },
                    intersect: function (a) {
                        return this.min.max(a.min), this.max.min(a.max), this.isEmpty() && this.makeEmpty(), this
                    },
                    union: function (a) {
                        return this.min.min(a.min), this.max.max(a.max), this
                    },
                    applyMatrix4: function (a) {
                        return this.isEmpty() ? this : (_o[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(a), _o[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(a), _o[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(a), _o[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(a), _o[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(a), _o[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(a), _o[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(a), _o[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(a), this.setFromPoints(_o), this)
                    },
                    translate: function (a) {
                        return this.min.add(a), this.max.add(a), this
                    },
                    equals: function (a) {
                        return a.min.equals(this.min) && a.max.equals(this.max)
                    }
                });
                var Po = new w;
                Object.assign(E.prototype, {
                    set: function (a, b) {
                        return this.center.copy(a), this.radius = b, this
                    },
                    setFromPoints: function (a, b) {
                        var t = this.center;
                        void 0 !== b ? t.copy(b) : Po.setFromPoints(a).getCenter(t);
                        for (var e = b = 0, n = a.length; e < n; e++) b = Math.max(b, t.distanceToSquared(a[e]));
                        return this.radius = Math.sqrt(b), this
                    },
                    clone: function () {
                        return (new this.constructor).copy(this)
                    },
                    copy: function (a) {
                        return this.center.copy(a.center), this.radius = a.radius, this
                    },
                    empty: function () {
                        return 0 >= this.radius
                    },
                    containsPoint: function (a) {
                        return a.distanceToSquared(this.center) <= this.radius * this.radius
                    },
                    distanceToPoint: function (a) {
                        return a.distanceTo(this.center) - this.radius
                    },
                    intersectsSphere: function (a) {
                        var b = this.radius + a.radius;
                        return a.center.distanceToSquared(this.center) <= b * b
                    },
                    intersectsBox: function (a) {
                        return a.intersectsSphere(this)
                    },
                    intersectsPlane: function (a) {
                        return Math.abs(a.distanceToPoint(this.center)) <= this.radius
                    },
                    clampPoint: function (a, b) {
                        var t = this.center.distanceToSquared(a);
                        return void 0 === b && (console.warn("THREE.Sphere: .clampPoint() target is now required"), b = new o), b.copy(a), t > this.radius * this.radius && (b.sub(this.center).normalize(), b.multiplyScalar(this.radius).add(this.center)), b
                    },
                    getBoundingBox: function (a) {
                        return void 0 === a && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), a = new w), a.set(this.center, this.center), a.expandByScalar(this.radius), a
                    },
                    applyMatrix4: function (a) {
                        return this.center.applyMatrix4(a), this.radius *= a.getMaxScaleOnAxis(), this
                    },
                    translate: function (a) {
                        return this.center.add(a), this
                    },
                    equals: function (a) {
                        return a.center.equals(this.center) && a.radius === this.radius
                    }
                });
                var Oo = new o,
                    Fo = new o,
                    No = new o,
                    Io = new o,
                    Bo = new o,
                    ko = new o,
                    zo = new o;
                Object.assign(T.prototype, {
                    set: function (a, b) {
                        return this.origin.copy(a), this.direction.copy(b), this
                    },
                    clone: function () {
                        return (new this.constructor).copy(this)
                    },
                    copy: function (a) {
                        return this.origin.copy(a.origin), this.direction.copy(a.direction), this
                    },
                    at: function (a, b) {
                        return void 0 === b && (console.warn("THREE.Ray: .at() target is now required"), b = new o), b.copy(this.direction).multiplyScalar(a).add(this.origin)
                    },
                    lookAt: function (a) {
                        return this.direction.copy(a).sub(this.origin).normalize(), this
                    },
                    recast: function (a) {
                        return this.origin.copy(this.at(a, Oo)), this
                    },
                    closestPointToPoint: function (a, b) {
                        return void 0 === b && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), b = new o), b.subVectors(a, this.origin), 0 > (a = b.dot(this.direction)) ? b.copy(this.origin) : b.copy(this.direction).multiplyScalar(a).add(this.origin)
                    },
                    distanceToPoint: function (a) {
                        return Math.sqrt(this.distanceSqToPoint(a))
                    },
                    distanceSqToPoint: function (a) {
                        var b = Oo.subVectors(a, this.origin).dot(this.direction);
                        return 0 > b ? this.origin.distanceToSquared(a) : (Oo.copy(this.direction).multiplyScalar(b).add(this.origin), Oo.distanceToSquared(a))
                    },
                    distanceSqToSegment: function (a, b, t, e) {
                        Fo.copy(a).add(b).multiplyScalar(.5), No.copy(b).sub(a).normalize(), Io.copy(this.origin).sub(Fo);
                        var n = .5 * a.distanceTo(b),
                            r = -this.direction.dot(No),
                            g = Io.dot(this.direction),
                            o = -Io.dot(No),
                            c = Io.lengthSq(),
                            l = Math.abs(1 - r * r);
                        if (0 < l) {
                            b = r * g - o;
                            var h = n * l;
                            0 <= (a = r * o - g) ? b >= -h ? b <= h ? r = (a *= n = 1 / l) * (a + r * (b *= n) + 2 * g) + b * (r * a + b + 2 * o) + c : (b = n, r = -(a = Math.max(0, -(r * b + g))) * a + b * (b + 2 * o) + c) : (b = -n, r = -(a = Math.max(0, -(r * b + g))) * a + b * (b + 2 * o) + c) : b <= -h ? r = -(a = Math.max(0, -(-r * n + g))) * a + (b = 0 < a ? -n : Math.min(Math.max(-n, -o), n)) * (b + 2 * o) + c : b <= h ? (a = 0, r = (b = Math.min(Math.max(-n, -o), n)) * (b + 2 * o) + c) : r = -(a = Math.max(0, -(r * n + g))) * a + (b = 0 < a ? n : Math.min(Math.max(-n, -o), n)) * (b + 2 * o) + c
                        } else b = 0 < r ? -n : n, r = -(a = Math.max(0, -(r * b + g))) * a + b * (b + 2 * o) + c;
                        return t && t.copy(this.direction).multiplyScalar(a).add(this.origin), e && e.copy(No).multiplyScalar(b).add(Fo), r
                    },
                    intersectSphere: function (a, b) {
                        Oo.subVectors(a.center, this.origin);
                        var t = Oo.dot(this.direction),
                            e = Oo.dot(Oo) - t * t;
                        return e > (a = a.radius * a.radius) ? null : (e = t - (a = Math.sqrt(a - e)), t += a, 0 > e && 0 > t ? null : 0 > e ? this.at(t, b) : this.at(e, b))
                    },
                    intersectsSphere: function (a) {
                        return this.distanceSqToPoint(a.center) <= a.radius * a.radius
                    },
                    distanceToPlane: function (a) {
                        var b = a.normal.dot(this.direction);
                        return 0 === b ? 0 === a.distanceToPoint(this.origin) ? 0 : null : 0 <= (a = -(this.origin.dot(a.normal) + a.constant) / b) ? a : null
                    },
                    intersectPlane: function (a, b) {
                        return null === (a = this.distanceToPlane(a)) ? null : this.at(a, b)
                    },
                    intersectsPlane: function (a) {
                        var b = a.distanceToPoint(this.origin);
                        return 0 === b || 0 > a.normal.dot(this.direction) * b
                    },
                    intersectBox: function (a, b) {
                        var t = 1 / this.direction.x,
                            e = 1 / this.direction.y,
                            n = 1 / this.direction.z,
                            r = this.origin;
                        if (0 <= t) {
                            var g = (a.min.x - r.x) * t;
                            t *= a.max.x - r.x
                        } else g = (a.max.x - r.x) * t, t *= a.min.x - r.x;
                        if (0 <= e) {
                            var o = (a.min.y - r.y) * e;
                            e *= a.max.y - r.y
                        } else o = (a.max.y - r.y) * e, e *= a.min.y - r.y;
                        return g > e || o > t ? null : ((o > g || g != g) && (g = o), (e < t || t != t) && (t = e), 0 <= n ? (o = (a.min.z - r.z) * n, a = (a.max.z - r.z) * n) : (o = (a.max.z - r.z) * n, a = (a.min.z - r.z) * n), g > a || o > t ? null : ((o > g || g != g) && (g = o), (a < t || t != t) && (t = a), 0 > t ? null : this.at(0 <= g ? g : t, b)))
                    },
                    intersectsBox: function (a) {
                        return null !== this.intersectBox(a, Oo)
                    },
                    intersectTriangle: function (a, b, t, e, n) {
                        if (Bo.subVectors(b, a), ko.subVectors(t, a), zo.crossVectors(Bo, ko), 0 < (b = this.direction.dot(zo))) {
                            if (e) return null;
                            e = 1
                        } else {
                            if (!(0 > b)) return null;
                            e = -1, b = -b
                        }
                        return Io.subVectors(this.origin, a), 0 > (a = e * this.direction.dot(ko.crossVectors(Io, ko))) ? null : 0 > (t = e * this.direction.dot(Bo.cross(Io))) || a + t > b ? null : 0 > (a = -e * Io.dot(zo)) ? null : this.at(a / b, n)
                    },
                    applyMatrix4: function (a) {
                        return this.origin.applyMatrix4(a), this.direction.transformDirection(a), this
                    },
                    equals: function (a) {
                        return a.origin.equals(this.origin) && a.direction.equals(this.direction)
                    }
                });
                var Uo = new o,
                    Ho = new o,
                    Go = new c;
                Object.assign(D.prototype, {
                    isPlane: !0,
                    set: function (a, b) {
                        return this.normal.copy(a), this.constant = b, this
                    },
                    setComponents: function (a, b, t, e) {
                        return this.normal.set(a, b, t), this.constant = e, this
                    },
                    setFromNormalAndCoplanarPoint: function (a, b) {
                        return this.normal.copy(a), this.constant = -b.dot(this.normal), this
                    },
                    setFromCoplanarPoints: function (a, b, t) {
                        return b = Uo.subVectors(t, b).cross(Ho.subVectors(a, b)).normalize(), this.setFromNormalAndCoplanarPoint(b, a), this
                    },
                    clone: function () {
                        return (new this.constructor).copy(this)
                    },
                    copy: function (a) {
                        return this.normal.copy(a.normal), this.constant = a.constant, this
                    },
                    normalize: function () {
                        var a = 1 / this.normal.length();
                        return this.normal.multiplyScalar(a), this.constant *= a, this
                    },
                    negate: function () {
                        return this.constant *= -1, this.normal.negate(), this
                    },
                    distanceToPoint: function (a) {
                        return this.normal.dot(a) + this.constant
                    },
                    distanceToSphere: function (a) {
                        return this.distanceToPoint(a.center) - a.radius
                    },
                    projectPoint: function (a, b) {
                        return void 0 === b && (console.warn("THREE.Plane: .projectPoint() target is now required"), b = new o), b.copy(this.normal).multiplyScalar(-this.distanceToPoint(a)).add(a)
                    },
                    intersectLine: function (a, b) {
                        void 0 === b && (console.warn("THREE.Plane: .intersectLine() target is now required"), b = new o);
                        var t = a.delta(Uo),
                            e = this.normal.dot(t);
                        if (0 === e) {
                            if (0 === this.distanceToPoint(a.start)) return b.copy(a.start)
                        } else if (!(0 > (e = -(a.start.dot(this.normal) + this.constant) / e) || 1 < e)) return b.copy(t).multiplyScalar(e).add(a.start)
                    },
                    intersectsLine: function (a) {
                        var b = this.distanceToPoint(a.start);
                        return a = this.distanceToPoint(a.end), 0 > b && 0 < a || 0 > a && 0 < b
                    },
                    intersectsBox: function (a) {
                        return a.intersectsPlane(this)
                    },
                    intersectsSphere: function (a) {
                        return a.intersectsPlane(this)
                    },
                    coplanarPoint: function (a) {
                        return void 0 === a && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), a = new o), a.copy(this.normal).multiplyScalar(-this.constant)
                    },
                    applyMatrix4: function (a, b) {
                        return b = b || Go.getNormalMatrix(a), a = this.coplanarPoint(Uo).applyMatrix4(a), b = this.normal.applyMatrix3(b).normalize(), this.constant = -a.dot(b), this
                    },
                    translate: function (a) {
                        return this.constant -= a.dot(this.normal), this
                    },
                    equals: function (a) {
                        return a.normal.equals(this.normal) && a.constant === this.constant
                    }
                });
                var Vo = new o,
                    jo = new o,
                    Wo = new o,
                    Yo = new o,
                    qo = new o,
                    td = new o,
                    Xo = new o,
                    Zo = new o,
                    Jo = new o,
                    $o = new o;
                Object.assign(S, {
                    getNormal: function (a, b, t, e) {
                        return void 0 === e && (console.warn("THREE.Triangle: .getNormal() target is now required"), e = new o), e.subVectors(t, b), Vo.subVectors(a, b), e.cross(Vo), 0 < (a = e.lengthSq()) ? e.multiplyScalar(1 / Math.sqrt(a)) : e.set(0, 0, 0)
                    },
                    getBarycoord: function (a, b, t, e, n) {
                        Vo.subVectors(e, b), jo.subVectors(t, b), Wo.subVectors(a, b), a = Vo.dot(Vo), b = Vo.dot(jo), t = Vo.dot(Wo);
                        var r = jo.dot(jo);
                        e = jo.dot(Wo);
                        var g = a * r - b * b;
                        return void 0 === n && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), n = new o), 0 === g ? n.set(-2, -1, -1) : (r = (r * t - b * e) * (g = 1 / g), a = (a * e - b * t) * g, n.set(1 - r - a, a, r))
                    },
                    containsPoint: function (a, b, t, e) {
                        return S.getBarycoord(a, b, t, e, Yo), 0 <= Yo.x && 0 <= Yo.y && 1 >= Yo.x + Yo.y
                    },
                    getUV: function (a, b, t, e, n, r, g, o) {
                        return this.getBarycoord(a, b, t, e, Yo), o.set(0, 0), o.addScaledVector(n, Yo.x), o.addScaledVector(r, Yo.y), o.addScaledVector(g, Yo.z), o
                    },
                    isFrontFacing: function (a, b, t, e) {
                        return Vo.subVectors(t, b), jo.subVectors(a, b), 0 > Vo.cross(jo).dot(e)
                    }
                }), Object.assign(S.prototype, {
                    set: function (a, b, t) {
                        return this.a.copy(a), this.b.copy(b), this.c.copy(t), this
                    },
                    setFromPointsAndIndices: function (a, b, t, e) {
                        return this.a.copy(a[b]), this.b.copy(a[t]), this.c.copy(a[e]), this
                    },
                    clone: function () {
                        return (new this.constructor).copy(this)
                    },
                    copy: function (a) {
                        return this.a.copy(a.a), this.b.copy(a.b), this.c.copy(a.c), this
                    },
                    getArea: function () {
                        return Vo.subVectors(this.c, this.b), jo.subVectors(this.a, this.b), .5 * Vo.cross(jo).length()
                    },
                    getMidpoint: function (a) {
                        return void 0 === a && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), a = new o), a.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                    },
                    getNormal: function (a) {
                        return S.getNormal(this.a, this.b, this.c, a)
                    },
                    getPlane: function (a) {
                        return void 0 === a && (console.warn("THREE.Triangle: .getPlane() target is now required"), a = new D), a.setFromCoplanarPoints(this.a, this.b, this.c)
                    },
                    getBarycoord: function (a, b) {
                        return S.getBarycoord(a, this.a, this.b, this.c, b)
                    },
                    getUV: function (a, b, t, e, n) {
                        return S.getUV(a, this.a, this.b, this.c, b, t, e, n)
                    },
                    containsPoint: function (a) {
                        return S.containsPoint(a, this.a, this.b, this.c)
                    },
                    isFrontFacing: function (a) {
                        return S.isFrontFacing(this.a, this.b, this.c, a)
                    },
                    intersectsBox: function (a) {
                        return a.intersectsTriangle(this)
                    },
                    closestPointToPoint: function (a, b) {
                        void 0 === b && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), b = new o);
                        var t = this.a,
                            e = this.b,
                            n = this.c;
                        qo.subVectors(e, t), td.subVectors(n, t), Zo.subVectors(a, t);
                        var r = qo.dot(Zo),
                            g = td.dot(Zo);
                        if (0 >= r && 0 >= g) return b.copy(t);
                        Jo.subVectors(a, e);
                        var c = qo.dot(Jo),
                            l = td.dot(Jo);
                        if (0 <= c && l <= c) return b.copy(e);
                        var h = r * l - c * g;
                        if (0 >= h && 0 <= r && 0 >= c) return e = r / (r - c), b.copy(t).addScaledVector(qo, e);
                        $o.subVectors(a, n), a = qo.dot($o);
                        var d = td.dot($o);
                        return 0 <= d && a <= d ? b.copy(n) : 0 >= (r = a * g - r * d) && 0 <= g && 0 >= d ? (h = g / (g - d), b.copy(t).addScaledVector(td, h)) : 0 >= (g = c * d - a * l) && 0 <= l - c && 0 <= a - d ? (Xo.subVectors(n, e), h = (l - c) / (l - c + (a - d)), b.copy(e).addScaledVector(Xo, h)) : (e = r * (n = 1 / (g + r + h)), h *= n, b.copy(t).addScaledVector(qo, e).addScaledVector(td, h))
                    },
                    equals: function (a) {
                        return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c)
                    }
                });
                var Qo = {
                        aliceblue: 15792383,
                        antiquewhite: 16444375,
                        aqua: 65535,
                        aquamarine: 8388564,
                        azure: 15794175,
                        beige: 16119260,
                        bisque: 16770244,
                        black: 0,
                        blanchedalmond: 16772045,
                        blue: 255,
                        blueviolet: 9055202,
                        brown: 10824234,
                        burlywood: 14596231,
                        cadetblue: 6266528,
                        chartreuse: 8388352,
                        chocolate: 13789470,
                        coral: 16744272,
                        cornflowerblue: 6591981,
                        cornsilk: 16775388,
                        crimson: 14423100,
                        cyan: 65535,
                        darkblue: 139,
                        darkcyan: 35723,
                        darkgoldenrod: 12092939,
                        darkgray: 11119017,
                        darkgreen: 25600,
                        darkgrey: 11119017,
                        darkkhaki: 12433259,
                        darkmagenta: 9109643,
                        darkolivegreen: 5597999,
                        darkorange: 16747520,
                        darkorchid: 10040012,
                        darkred: 9109504,
                        darksalmon: 15308410,
                        darkseagreen: 9419919,
                        darkslateblue: 4734347,
                        darkslategray: 3100495,
                        darkslategrey: 3100495,
                        darkturquoise: 52945,
                        darkviolet: 9699539,
                        deeppink: 16716947,
                        deepskyblue: 49151,
                        dimgray: 6908265,
                        dimgrey: 6908265,
                        dodgerblue: 2003199,
                        firebrick: 11674146,
                        floralwhite: 16775920,
                        forestgreen: 2263842,
                        fuchsia: 16711935,
                        gainsboro: 14474460,
                        ghostwhite: 16316671,
                        gold: 16766720,
                        goldenrod: 14329120,
                        gray: 8421504,
                        green: 32768,
                        greenyellow: 11403055,
                        grey: 8421504,
                        honeydew: 15794160,
                        hotpink: 16738740,
                        indianred: 13458524,
                        indigo: 4915330,
                        ivory: 16777200,
                        khaki: 15787660,
                        lavender: 15132410,
                        lavenderblush: 16773365,
                        lawngreen: 8190976,
                        lemonchiffon: 16775885,
                        lightblue: 11393254,
                        lightcoral: 15761536,
                        lightcyan: 14745599,
                        lightgoldenrodyellow: 16448210,
                        lightgray: 13882323,
                        lightgreen: 9498256,
                        lightgrey: 13882323,
                        lightpink: 16758465,
                        lightsalmon: 16752762,
                        lightseagreen: 2142890,
                        lightskyblue: 8900346,
                        lightslategray: 7833753,
                        lightslategrey: 7833753,
                        lightsteelblue: 11584734,
                        lightyellow: 16777184,
                        lime: 65280,
                        limegreen: 3329330,
                        linen: 16445670,
                        magenta: 16711935,
                        maroon: 8388608,
                        mediumaquamarine: 6737322,
                        mediumblue: 205,
                        mediumorchid: 12211667,
                        mediumpurple: 9662683,
                        mediumseagreen: 3978097,
                        mediumslateblue: 8087790,
                        mediumspringgreen: 64154,
                        mediumturquoise: 4772300,
                        mediumvioletred: 13047173,
                        midnightblue: 1644912,
                        mintcream: 16121850,
                        mistyrose: 16770273,
                        moccasin: 16770229,
                        navajowhite: 16768685,
                        navy: 128,
                        oldlace: 16643558,
                        olive: 8421376,
                        olivedrab: 7048739,
                        orange: 16753920,
                        orangered: 16729344,
                        orchid: 14315734,
                        palegoldenrod: 15657130,
                        palegreen: 10025880,
                        paleturquoise: 11529966,
                        palevioletred: 14381203,
                        papayawhip: 16773077,
                        peachpuff: 16767673,
                        peru: 13468991,
                        pink: 16761035,
                        plum: 14524637,
                        powderblue: 11591910,
                        purple: 8388736,
                        rebeccapurple: 6697881,
                        red: 16711680,
                        rosybrown: 12357519,
                        royalblue: 4286945,
                        saddlebrown: 9127187,
                        salmon: 16416882,
                        sandybrown: 16032864,
                        seagreen: 3050327,
                        seashell: 16774638,
                        sienna: 10506797,
                        silver: 12632256,
                        skyblue: 8900331,
                        slateblue: 6970061,
                        slategray: 7372944,
                        slategrey: 7372944,
                        snow: 16775930,
                        springgreen: 65407,
                        steelblue: 4620980,
                        tan: 13808780,
                        teal: 32896,
                        thistle: 14204888,
                        tomato: 16737095,
                        turquoise: 4251856,
                        violet: 15631086,
                        wheat: 16113331,
                        white: 16777215,
                        whitesmoke: 16119285,
                        yellow: 16776960,
                        yellowgreen: 10145074
                    },
                    Ko = {
                        h: 0,
                        s: 0,
                        l: 0
                    },
                    ts = {
                        h: 0,
                        s: 0,
                        l: 0
                    };
                Object.assign(A.prototype, {
                    isColor: !0,
                    r: 1,
                    g: 1,
                    b: 1,
                    set: function (a) {
                        return a && a.isColor ? this.copy(a) : "number" == typeof a ? this.setHex(a) : "string" == typeof a && this.setStyle(a), this
                    },
                    setScalar: function (a) {
                        return this.b = this.g = this.r = a, this
                    },
                    setHex: function (a) {
                        return a = Math.floor(a), this.r = (a >> 16 & 255) / 255, this.g = (a >> 8 & 255) / 255, this.b = (255 & a) / 255, this
                    },
                    setRGB: function (a, b, t) {
                        return this.r = a, this.g = b, this.b = t, this
                    },
                    setHSL: function (a, b, t) {
                        return a = Va.euclideanModulo(a, 1), b = Va.clamp(b, 0, 1), t = Va.clamp(t, 0, 1), 0 === b ? this.r = this.g = this.b = t : (t = 2 * t - (b = .5 >= t ? t * (1 + b) : t + b - t * b), this.r = C(t, b, a + 1 / 3), this.g = C(t, b, a), this.b = C(t, b, a - 1 / 3)), this
                    },
                    setStyle: function (a) {
                        function b(b) {
                            void 0 !== b && 1 > parseFloat(b) && console.warn("THREE.Color: Alpha component of " + a + " will be ignored.")
                        }
                        var t;
                        if (t = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a)) {
                            var e = t[2];
                            switch (t[1]) {
                                case "rgb":
                                case "rgba":
                                    if (t = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(e)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, b(t[5]), this;
                                    if (t = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(e)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, b(t[5]), this;
                                    break;
                                case "hsl":
                                case "hsla":
                                    if (t = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(e)) {
                                        e = parseFloat(t[1]) / 360;
                                        var n = parseInt(t[2], 10) / 100,
                                            r = parseInt(t[3], 10) / 100;
                                        return b(t[5]), this.setHSL(e, n, r)
                                    }
                            }
                        } else if (t = /^#([A-Fa-f0-9]+)$/.exec(a)) {
                            if (3 === (e = (t = t[1]).length)) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this;
                            if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this
                        }
                        return a && 0 < a.length ? this.setColorName(a) : this
                    },
                    setColorName: function (a) {
                        var b = Qo[a];
                        return void 0 !== b ? this.setHex(b) : console.warn("THREE.Color: Unknown color " + a), this
                    },
                    clone: function () {
                        return new this.constructor(this.r, this.g, this.b)
                    },
                    copy: function (a) {
                        return this.r = a.r, this.g = a.g, this.b = a.b, this
                    },
                    copyGammaToLinear: function (a, b) {
                        return void 0 === b && (b = 2), this.r = Math.pow(a.r, b), this.g = Math.pow(a.g, b), this.b = Math.pow(a.b, b), this
                    },
                    copyLinearToGamma: function (a, b) {
                        return void 0 === b && (b = 2), b = 0 < b ? 1 / b : 1, this.r = Math.pow(a.r, b), this.g = Math.pow(a.g, b), this.b = Math.pow(a.b, b), this
                    },
                    convertGammaToLinear: function (a) {
                        return this.copyGammaToLinear(this, a), this
                    },
                    convertLinearToGamma: function (a) {
                        return this.copyLinearToGamma(this, a), this
                    },
                    copySRGBToLinear: function (a) {
                        return this.r = L(a.r), this.g = L(a.g), this.b = L(a.b), this
                    },
                    copyLinearToSRGB: function (a) {
                        return this.r = R(a.r), this.g = R(a.g), this.b = R(a.b), this
                    },
                    convertSRGBToLinear: function () {
                        return this.copySRGBToLinear(this), this
                    },
                    convertLinearToSRGB: function () {
                        return this.copyLinearToSRGB(this), this
                    },
                    getHex: function () {
                        return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                    },
                    getHexString: function () {
                        return ("000000" + this.getHex().toString(16)).slice(-6)
                    },
                    getHSL: function (a) {
                        void 0 === a && (console.warn("THREE.Color: .getHSL() target is now required"), a = {
                            h: 0,
                            s: 0,
                            l: 0
                        });
                        var g, b = this.r,
                            t = this.g,
                            e = this.b,
                            n = Math.max(b, t, e),
                            r = Math.min(b, t, e),
                            o = (r + n) / 2;
                        if (r === n) r = g = 0;
                        else {
                            var c = n - r;
                            switch (r = .5 >= o ? c / (n + r) : c / (2 - n - r), n) {
                                case b:
                                    g = (t - e) / c + (t < e ? 6 : 0);
                                    break;
                                case t:
                                    g = (e - b) / c + 2;
                                    break;
                                case e:
                                    g = (b - t) / c + 4
                            }
                            g /= 6
                        }
                        return a.h = g, a.s = r, a.l = o, a
                    },
                    getStyle: function () {
                        return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                    },
                    offsetHSL: function (a, b, t) {
                        return this.getHSL(Ko), Ko.h += a, Ko.s += b, Ko.l += t, this.setHSL(Ko.h, Ko.s, Ko.l), this
                    },
                    add: function (a) {
                        return this.r += a.r, this.g += a.g, this.b += a.b, this
                    },
                    addColors: function (a, b) {
                        return this.r = a.r + b.r, this.g = a.g + b.g, this.b = a.b + b.b, this
                    },
                    addScalar: function (a) {
                        return this.r += a, this.g += a, this.b += a, this
                    },
                    sub: function (a) {
                        return this.r = Math.max(0, this.r - a.r), this.g = Math.max(0, this.g - a.g), this.b = Math.max(0, this.b - a.b), this
                    },
                    multiply: function (a) {
                        return this.r *= a.r, this.g *= a.g, this.b *= a.b, this
                    },
                    multiplyScalar: function (a) {
                        return this.r *= a, this.g *= a, this.b *= a, this
                    },
                    lerp: function (a, b) {
                        return this.r += (a.r - this.r) * b, this.g += (a.g - this.g) * b, this.b += (a.b - this.b) * b, this
                    },
                    lerpHSL: function (a, b) {
                        this.getHSL(Ko), a.getHSL(ts), a = Va.lerp(Ko.h, ts.h, b);
                        var t = Va.lerp(Ko.s, ts.s, b);
                        return b = Va.lerp(Ko.l, ts.l, b), this.setHSL(a, t, b), this
                    },
                    equals: function (a) {
                        return a.r === this.r && a.g === this.g && a.b === this.b
                    },
                    fromArray: function (a, b) {
                        return void 0 === b && (b = 0), this.r = a[b], this.g = a[b + 1], this.b = a[b + 2], this
                    },
                    toArray: function (a, b) {
                        return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.r, a[b + 1] = this.g, a[b + 2] = this.b, a
                    },
                    toJSON: function () {
                        return this.getHex()
                    }
                }), A.NAMES = Qo, Object.assign(P.prototype, {
                    clone: function () {
                        return (new this.constructor).copy(this)
                    },
                    copy: function (a) {
                        this.a = a.a, this.b = a.b, this.c = a.c, this.normal.copy(a.normal), this.color.copy(a.color), this.materialIndex = a.materialIndex;
                        for (var b = 0, t = a.vertexNormals.length; b < t; b++) this.vertexNormals[b] = a.vertexNormals[b].clone();
                        for (b = 0, t = a.vertexColors.length; b < t; b++) this.vertexColors[b] = a.vertexColors[b].clone();
                        return this
                    }
                });
                var es = 0;
                O.prototype = Object.assign(Object.create(e.prototype), {
                    constructor: O,
                    isMaterial: !0,
                    onBeforeCompile: function () {},
                    setValues: function (a) {
                        if (void 0 !== a)
                            for (var b in a) {
                                var t = a[b];
                                if (void 0 === t) console.warn("THREE.Material: '" + b + "' parameter is undefined.");
                                else if ("shading" === b) console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t;
                                else {
                                    var e = this[b];
                                    void 0 === e ? console.warn("THREE." + this.type + ": '" + b + "' is not a property of this material.") : e && e.isColor ? e.set(t) : e && e.isVector3 && t && t.isVector3 ? e.copy(t) : this[b] = t
                                }
                            }
                    },
                    toJSON: function (a) {
                        function b(a) {
                            var t, b = [];
                            for (t in a) {
                                var e = a[t];
                                delete e.metadata, b.push(e)
                            }
                            return b
                        }
                        var t = void 0 === a || "string" == typeof a;
                        t && (a = {
                            textures: {},
                            images: {}
                        });
                        var e = {
                            metadata: {
                                version: 4.5,
                                type: "Material",
                                generator: "Material.toJSON"
                            }
                        };
                        return e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), this.color && this.color.isColor && (e.color = this.color.getHex()), void 0 !== this.roughness && (e.roughness = this.roughness), void 0 !== this.metalness && (e.metalness = this.metalness), this.sheen && this.sheen.isColor && (e.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (e.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (e.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (e.specular = this.specular.getHex()), void 0 !== this.shininess && (e.shininess = this.shininess), void 0 !== this.clearcoat && (e.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (e.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (e.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(a).uuid, e.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (e.map = this.map.toJSON(a).uuid), this.matcap && this.matcap.isTexture && (e.matcap = this.matcap.toJSON(a).uuid), this.alphaMap && this.alphaMap.isTexture && (e.alphaMap = this.alphaMap.toJSON(a).uuid), this.lightMap && this.lightMap.isTexture && (e.lightMap = this.lightMap.toJSON(a).uuid), this.aoMap && this.aoMap.isTexture && (e.aoMap = this.aoMap.toJSON(a).uuid, e.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (e.bumpMap = this.bumpMap.toJSON(a).uuid, e.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (e.normalMap = this.normalMap.toJSON(a).uuid, e.normalMapType = this.normalMapType, e.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (e.displacementMap = this.displacementMap.toJSON(a).uuid, e.displacementScale = this.displacementScale, e.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (e.roughnessMap = this.roughnessMap.toJSON(a).uuid), this.metalnessMap && this.metalnessMap.isTexture && (e.metalnessMap = this.metalnessMap.toJSON(a).uuid), this.emissiveMap && this.emissiveMap.isTexture && (e.emissiveMap = this.emissiveMap.toJSON(a).uuid), this.specularMap && this.specularMap.isTexture && (e.specularMap = this.specularMap.toJSON(a).uuid), this.envMap && this.envMap.isTexture && (e.envMap = this.envMap.toJSON(a).uuid, e.reflectivity = this.reflectivity, e.refractionRatio = this.refractionRatio, void 0 !== this.combine && (e.combine = this.combine), void 0 !== this.envMapIntensity && (e.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (e.gradientMap = this.gradientMap.toJSON(a).uuid), void 0 !== this.size && (e.size = this.size), void 0 !== this.sizeAttenuation && (e.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (e.blending = this.blending), !0 === this.flatShading && (e.flatShading = this.flatShading), 0 !== this.side && (e.side = this.side), 0 !== this.vertexColors && (e.vertexColors = this.vertexColors), 1 > this.opacity && (e.opacity = this.opacity), !0 === this.transparent && (e.transparent = this.transparent), e.depthFunc = this.depthFunc, e.depthTest = this.depthTest, e.depthWrite = this.depthWrite, e.stencilWrite = this.stencilWrite, e.stencilWriteMask = this.stencilWriteMask, e.stencilFunc = this.stencilFunc, e.stencilRef = this.stencilRef, e.stencilFuncMask = this.stencilFuncMask, e.stencilFail = this.stencilFail, e.stencilZFail = this.stencilZFail, e.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (e.rotation = this.rotation), !0 === this.polygonOffset && (e.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (e.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (e.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (e.linewidth = this.linewidth), void 0 !== this.dashSize && (e.dashSize = this.dashSize), void 0 !== this.gapSize && (e.gapSize = this.gapSize), void 0 !== this.scale && (e.scale = this.scale), !0 === this.dithering && (e.dithering = !0), 0 < this.alphaTest && (e.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (e.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (e.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (e.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (e.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (e.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (e.morphTargets = !0), !0 === this.morphNormals && (e.morphNormals = !0), !0 === this.skinning && (e.skinning = !0), !1 === this.visible && (e.visible = !1), !1 === this.toneMapped && (e.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (e.userData = this.userData), t && (t = b(a.textures), a = b(a.images), 0 < t.length && (e.textures = t), 0 < a.length && (e.images = a)), e
                    },
                    clone: function () {
                        return (new this.constructor).copy(this)
                    },
                    copy: function (a) {
                        this.name = a.name, this.fog = a.fog, this.blending = a.blending, this.side = a.side, this.flatShading = a.flatShading, this.vertexTangents = a.vertexTangents, this.vertexColors = a.vertexColors, this.opacity = a.opacity, this.transparent = a.transparent, this.blendSrc = a.blendSrc, this.blendDst = a.blendDst, this.blendEquation = a.blendEquation, this.blendSrcAlpha = a.blendSrcAlpha, this.blendDstAlpha = a.blendDstAlpha, this.blendEquationAlpha = a.blendEquationAlpha, this.depthFunc = a.depthFunc, this.depthTest = a.depthTest, this.depthWrite = a.depthWrite, this.stencilWriteMask = a.stencilWriteMask, this.stencilFunc = a.stencilFunc, this.stencilRef = a.stencilRef, this.stencilFuncMask = a.stencilFuncMask, this.stencilFail = a.stencilFail, this.stencilZFail = a.stencilZFail, this.stencilZPass = a.stencilZPass, this.stencilWrite = a.stencilWrite;
                        var b = a.clippingPlanes,
                            t = null;
                        if (null !== b) {
                            var e = b.length;
                            t = Array(e);
                            for (var n = 0; n !== e; ++n) t[n] = b[n].clone()
                        }
                        return this.clippingPlanes = t, this.clipIntersection = a.clipIntersection, this.clipShadows = a.clipShadows, this.shadowSide = a.shadowSide, this.colorWrite = a.colorWrite, this.precision = a.precision, this.polygonOffset = a.polygonOffset, this.polygonOffsetFactor = a.polygonOffsetFactor, this.polygonOffsetUnits = a.polygonOffsetUnits, this.dithering = a.dithering, this.alphaTest = a.alphaTest, this.premultipliedAlpha = a.premultipliedAlpha, this.visible = a.visible, this.toneMapped = a.toneMapped, this.userData = JSON.parse(JSON.stringify(a.userData)), this
                    },
                    dispose: function () {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }), Object.defineProperty(O.prototype, "needsUpdate", {
                    set: function (a) {
                        !0 === a && this.version++
                    }
                }), F.prototype = Object.create(O.prototype), F.prototype.constructor = F, F.prototype.isMeshBasicMaterial = !0, F.prototype.copy = function (a) {
                    return O.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.specularMap = a.specularMap, this.alphaMap = a.alphaMap, this.envMap = a.envMap, this.combine = a.combine, this.reflectivity = a.reflectivity, this.refractionRatio = a.refractionRatio, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.wireframeLinecap = a.wireframeLinecap, this.wireframeLinejoin = a.wireframeLinejoin, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this
                };
                var ns = new o;
                Object.defineProperty(N.prototype, "needsUpdate", {
                    set: function (a) {
                        !0 === a && this.version++
                    }
                }), Object.assign(N.prototype, {
                    isBufferAttribute: !0,
                    onUploadCallback: function () {},
                    setUsage: function (a) {
                        return this.usage = a, this
                    },
                    copy: function (a) {
                        return this.name = a.name, this.array = new a.array.constructor(a.array), this.itemSize = a.itemSize, this.count = a.count, this.normalized = a.normalized, this.usage = a.usage, this
                    },
                    copyAt: function (a, b, t) {
                        a *= this.itemSize, t *= b.itemSize;
                        for (var e = 0, n = this.itemSize; e < n; e++) this.array[a + e] = b.array[t + e];
                        return this
                    },
                    copyArray: function (a) {
                        return this.array.set(a), this
                    },
                    copyColorsArray: function (a) {
                        for (var b = this.array, t = 0, e = 0, n = a.length; e < n; e++) {
                            var r = a[e];
                            void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", e), r = new A), b[t++] = r.r, b[t++] = r.g, b[t++] = r.b
                        }
                        return this
                    },
                    copyVector2sArray: function (a) {
                        for (var b = this.array, t = 0, e = 0, r = a.length; e < r; e++) {
                            var o = a[e];
                            void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", e), o = new n), b[t++] = o.x, b[t++] = o.y
                        }
                        return this
                    },
                    copyVector3sArray: function (a) {
                        for (var b = this.array, t = 0, e = 0, n = a.length; e < n; e++) {
                            var r = a[e];
                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", e), r = new o), b[t++] = r.x, b[t++] = r.y, b[t++] = r.z
                        }
                        return this
                    },
                    copyVector4sArray: function (a) {
                        for (var b = this.array, t = 0, e = 0, n = a.length; e < n; e++) {
                            var r = a[e];
                            void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", e), r = new h), b[t++] = r.x, b[t++] = r.y, b[t++] = r.z, b[t++] = r.w
                        }
                        return this
                    },
                    applyMatrix3: function (a) {
                        for (var b = 0, t = this.count; b < t; b++) ns.x = this.getX(b), ns.y = this.getY(b), ns.z = this.getZ(b), ns.applyMatrix3(a), this.setXYZ(b, ns.x, ns.y, ns.z);
                        return this
                    },
                    applyMatrix4: function (a) {
                        for (var b = 0, t = this.count; b < t; b++) ns.x = this.getX(b), ns.y = this.getY(b), ns.z = this.getZ(b), ns.applyMatrix4(a), this.setXYZ(b, ns.x, ns.y, ns.z);
                        return this
                    },
                    applyNormalMatrix: function (a) {
                        for (var b = 0, t = this.count; b < t; b++) ns.x = this.getX(b), ns.y = this.getY(b), ns.z = this.getZ(b), ns.applyNormalMatrix(a), this.setXYZ(b, ns.x, ns.y, ns.z);
                        return this
                    },
                    transformDirection: function (a) {
                        for (var b = 0, t = this.count; b < t; b++) ns.x = this.getX(b), ns.y = this.getY(b), ns.z = this.getZ(b), ns.transformDirection(a), this.setXYZ(b, ns.x, ns.y, ns.z);
                        return this
                    },
                    set: function (a, b) {
                        return void 0 === b && (b = 0), this.array.set(a, b), this
                    },
                    getX: function (a) {
                        return this.array[a * this.itemSize]
                    },
                    setX: function (a, b) {
                        return this.array[a * this.itemSize] = b, this
                    },
                    getY: function (a) {
                        return this.array[a * this.itemSize + 1]
                    },
                    setY: function (a, b) {
                        return this.array[a * this.itemSize + 1] = b, this
                    },
                    getZ: function (a) {
                        return this.array[a * this.itemSize + 2]
                    },
                    setZ: function (a, b) {
                        return this.array[a * this.itemSize + 2] = b, this
                    },
                    getW: function (a) {
                        return this.array[a * this.itemSize + 3]
                    },
                    setW: function (a, b) {
                        return this.array[a * this.itemSize + 3] = b, this
                    },
                    setXY: function (a, b, t) {
                        return a *= this.itemSize, this.array[a + 0] = b, this.array[a + 1] = t, this
                    },
                    setXYZ: function (a, b, t, e) {
                        return a *= this.itemSize, this.array[a + 0] = b, this.array[a + 1] = t, this.array[a + 2] = e, this
                    },
                    setXYZW: function (a, b, t, e, n) {
                        return a *= this.itemSize, this.array[a + 0] = b, this.array[a + 1] = t, this.array[a + 2] = e, this.array[a + 3] = n, this
                    },
                    onUpload: function (a) {
                        return this.onUploadCallback = a, this
                    },
                    clone: function () {
                        return new this.constructor(this.array, this.itemSize).copy(this)
                    },
                    toJSON: function () {
                        return {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: Array.prototype.slice.call(this.array),
                            normalized: this.normalized
                        }
                    }
                }), I.prototype = Object.create(N.prototype), I.prototype.constructor = I, B.prototype = Object.create(N.prototype), B.prototype.constructor = B, k.prototype = Object.create(N.prototype), k.prototype.constructor = k, z.prototype = Object.create(N.prototype), z.prototype.constructor = z, U.prototype = Object.create(N.prototype), U.prototype.constructor = U, H.prototype = Object.create(N.prototype), H.prototype.constructor = H, G.prototype = Object.create(N.prototype), G.prototype.constructor = G, V.prototype = Object.create(N.prototype), V.prototype.constructor = V, j.prototype = Object.create(N.prototype), j.prototype.constructor = j, Object.assign(W.prototype, {
                    computeGroups: function (a) {
                        var b = [],
                            t = void 0;
                        a = a.faces;
                        for (var e = 0; e < a.length; e++) {
                            var n = a[e];
                            if (n.materialIndex !== t) {
                                t = n.materialIndex, void 0 !== r && (r.count = 3 * e - r.start, b.push(r));
                                var r = {
                                    start: 3 * e,
                                    materialIndex: t
                                }
                            }
                        }
                        void 0 !== r && (r.count = 3 * e - r.start, b.push(r)), this.groups = b
                    },
                    fromGeometry: function (a) {
                        var b = a.faces,
                            t = a.vertices,
                            e = a.faceVertexUvs,
                            r = e[0] && 0 < e[0].length,
                            o = e[1] && 0 < e[1].length,
                            g = a.morphTargets,
                            c = g.length;
                        if (0 < c) {
                            for (var l = [], h = 0; h < c; h++) l[h] = {
                                name: g[h].name,
                                data: []
                            };
                            this.morphTargets.position = l
                        }
                        var d = a.morphNormals,
                            p = d.length;
                        if (0 < p) {
                            var q = [];
                            for (h = 0; h < p; h++) q[h] = {
                                name: d[h].name,
                                data: []
                            };
                            this.morphTargets.normal = q
                        }
                        var f = a.skinIndices,
                            m = a.skinWeights,
                            u = f.length === t.length,
                            v = m.length === t.length;
                        for (0 < t.length && 0 === b.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported."), h = 0; h < b.length; h++) {
                            var y = b[h];
                            this.vertices.push(t[y.a], t[y.b], t[y.c]);
                            var _ = y.vertexNormals;
                            for (3 === _.length ? this.normals.push(_[0], _[1], _[2]) : (_ = y.normal, this.normals.push(_, _, _)), 3 === (_ = y.vertexColors).length ? this.colors.push(_[0], _[1], _[2]) : (_ = y.color, this.colors.push(_, _, _)), !0 === r && (void 0 !== (_ = e[0][h]) ? this.uvs.push(_[0], _[1], _[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h), this.uvs.push(new n, new n, new n))), !0 === o && (void 0 !== (_ = e[1][h]) ? this.uvs2.push(_[0], _[1], _[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h), this.uvs2.push(new n, new n, new n))), _ = 0; _ < c; _++) {
                                var x = g[_].vertices;
                                l[_].data.push(x[y.a], x[y.b], x[y.c])
                            }
                            for (_ = 0; _ < p; _++) x = d[_].vertexNormals[h], q[_].data.push(x.a, x.b, x.c);
                            u && this.skinIndices.push(f[y.a], f[y.b], f[y.c]), v && this.skinWeights.push(m[y.a], m[y.b], m[y.c])
                        }
                        return this.computeGroups(a), this.verticesNeedUpdate = a.verticesNeedUpdate, this.normalsNeedUpdate = a.normalsNeedUpdate, this.colorsNeedUpdate = a.colorsNeedUpdate, this.uvsNeedUpdate = a.uvsNeedUpdate, this.groupsNeedUpdate = a.groupsNeedUpdate, null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()), null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()), this
                    }
                });
                var is = 1,
                    rs = new m,
                    as = new _,
                    os = new o,
                    ss = new w,
                    us = new w,
                    cs = new o;
                X.prototype = Object.assign(Object.create(e.prototype), {
                    constructor: X,
                    isBufferGeometry: !0,
                    getIndex: function () {
                        return this.index
                    },
                    setIndex: function (a) {
                        Array.isArray(a) ? this.index = new(65535 < Y(a) ? G : U)(a, 1) : this.index = a
                    },
                    getAttribute: function (a) {
                        return this.attributes[a]
                    },
                    setAttribute: function (a, b) {
                        return this.attributes[a] = b, this
                    },
                    deleteAttribute: function (a) {
                        return delete this.attributes[a], this
                    },
                    addGroup: function (a, b, t) {
                        this.groups.push({
                            start: a,
                            count: b,
                            materialIndex: void 0 !== t ? t : 0
                        })
                    },
                    clearGroups: function () {
                        this.groups = []
                    },
                    setDrawRange: function (a, b) {
                        this.drawRange.start = a, this.drawRange.count = b
                    },
                    applyMatrix: function (a) {
                        var b = this.attributes.position;
                        if (void 0 !== b && (b.applyMatrix4(a), b.needsUpdate = !0), void 0 !== (b = this.attributes.normal)) {
                            var t = (new c).getNormalMatrix(a);
                            b.applyNormalMatrix(t), b.needsUpdate = !0
                        }
                        return void 0 !== (b = this.attributes.tangent) && (b.transformDirection(a), b.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                    },
                    rotateX: function (a) {
                        return rs.makeRotationX(a), this.applyMatrix(rs), this
                    },
                    rotateY: function (a) {
                        return rs.makeRotationY(a), this.applyMatrix(rs), this
                    },
                    rotateZ: function (a) {
                        return rs.makeRotationZ(a), this.applyMatrix(rs), this
                    },
                    translate: function (a, b, t) {
                        return rs.makeTranslation(a, b, t), this.applyMatrix(rs), this
                    },
                    scale: function (a, b, t) {
                        return rs.makeScale(a, b, t), this.applyMatrix(rs), this
                    },
                    lookAt: function (a) {
                        return as.lookAt(a), as.updateMatrix(), this.applyMatrix(as.matrix), this
                    },
                    center: function () {
                        return this.computeBoundingBox(), this.boundingBox.getCenter(os).negate(), this.translate(os.x, os.y, os.z), this
                    },
                    setFromObject: function (a) {
                        var b = a.geometry;
                        if (a.isPoints || a.isLine) {
                            a = new V(3 * b.vertices.length, 3);
                            var t = new V(3 * b.colors.length, 3);
                            this.setAttribute("position", a.copyVector3sArray(b.vertices)), this.setAttribute("color", t.copyColorsArray(b.colors)), b.lineDistances && b.lineDistances.length === b.vertices.length && (a = new V(b.lineDistances.length, 1), this.setAttribute("lineDistance", a.copyArray(b.lineDistances))), null !== b.boundingSphere && (this.boundingSphere = b.boundingSphere.clone()), null !== b.boundingBox && (this.boundingBox = b.boundingBox.clone())
                        } else a.isMesh && b && b.isGeometry && this.fromGeometry(b);
                        return this
                    },
                    setFromPoints: function (a) {
                        for (var b = [], t = 0, e = a.length; t < e; t++) {
                            var n = a[t];
                            b.push(n.x, n.y, n.z || 0)
                        }
                        return this.setAttribute("position", new V(b, 3)), this
                    },
                    updateFromObject: function (a) {
                        var b = a.geometry;
                        if (a.isMesh) {
                            var t = b.__directGeometry;
                            if (!0 === b.elementsNeedUpdate && (t = void 0, b.elementsNeedUpdate = !1), void 0 === t) return this.fromGeometry(b);
                            t.verticesNeedUpdate = b.verticesNeedUpdate, t.normalsNeedUpdate = b.normalsNeedUpdate, t.colorsNeedUpdate = b.colorsNeedUpdate, t.uvsNeedUpdate = b.uvsNeedUpdate, t.groupsNeedUpdate = b.groupsNeedUpdate, b.verticesNeedUpdate = !1, b.normalsNeedUpdate = !1, b.colorsNeedUpdate = !1, b.uvsNeedUpdate = !1, b.groupsNeedUpdate = !1, b = t
                        }
                        return !0 === b.verticesNeedUpdate && (void 0 !== (t = this.attributes.position) && (t.copyVector3sArray(b.vertices), t.needsUpdate = !0), b.verticesNeedUpdate = !1), !0 === b.normalsNeedUpdate && (void 0 !== (t = this.attributes.normal) && (t.copyVector3sArray(b.normals), t.needsUpdate = !0), b.normalsNeedUpdate = !1), !0 === b.colorsNeedUpdate && (void 0 !== (t = this.attributes.color) && (t.copyColorsArray(b.colors), t.needsUpdate = !0), b.colorsNeedUpdate = !1), b.uvsNeedUpdate && (void 0 !== (t = this.attributes.uv) && (t.copyVector2sArray(b.uvs), t.needsUpdate = !0), b.uvsNeedUpdate = !1), b.lineDistancesNeedUpdate && (void 0 !== (t = this.attributes.lineDistance) && (t.copyArray(b.lineDistances), t.needsUpdate = !0), b.lineDistancesNeedUpdate = !1), b.groupsNeedUpdate && (b.computeGroups(a.geometry), this.groups = b.groups, b.groupsNeedUpdate = !1), this
                    },
                    fromGeometry: function (a) {
                        return a.__directGeometry = (new W).fromGeometry(a), this.fromDirectGeometry(a.__directGeometry)
                    },
                    fromDirectGeometry: function (a) {
                        var b = new Float32Array(3 * a.vertices.length);
                        for (var t in this.setAttribute("position", new N(b, 3).copyVector3sArray(a.vertices)), 0 < a.normals.length && (b = new Float32Array(3 * a.normals.length), this.setAttribute("normal", new N(b, 3).copyVector3sArray(a.normals))), 0 < a.colors.length && (b = new Float32Array(3 * a.colors.length), this.setAttribute("color", new N(b, 3).copyColorsArray(a.colors))), 0 < a.uvs.length && (b = new Float32Array(2 * a.uvs.length), this.setAttribute("uv", new N(b, 2).copyVector2sArray(a.uvs))), 0 < a.uvs2.length && (b = new Float32Array(2 * a.uvs2.length), this.setAttribute("uv2", new N(b, 2).copyVector2sArray(a.uvs2))), this.groups = a.groups, a.morphTargets) {
                            b = [];
                            for (var e = a.morphTargets[t], n = 0, r = e.length; n < r; n++) {
                                var g = e[n],
                                    o = new V(3 * g.data.length, 3);
                                o.name = g.name, b.push(o.copyVector3sArray(g.data))
                            }
                            this.morphAttributes[t] = b
                        }
                        return 0 < a.skinIndices.length && (t = new V(4 * a.skinIndices.length, 4), this.setAttribute("skinIndex", t.copyVector4sArray(a.skinIndices))), 0 < a.skinWeights.length && (t = new V(4 * a.skinWeights.length, 4), this.setAttribute("skinWeight", t.copyVector4sArray(a.skinWeights))), null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()), null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()), this
                    },
                    computeBoundingBox: function () {
                        null === this.boundingBox && (this.boundingBox = new w);
                        var a = this.attributes.position,
                            b = this.morphAttributes.position;
                        if (void 0 !== a) {
                            if (this.boundingBox.setFromBufferAttribute(a), b) {
                                a = 0;
                                for (var t = b.length; a < t; a++) ss.setFromBufferAttribute(b[a]), this.morphTargetsRelative ? (cs.addVectors(this.boundingBox.min, ss.min), this.boundingBox.expandByPoint(cs), cs.addVectors(this.boundingBox.max, ss.max), this.boundingBox.expandByPoint(cs)) : (this.boundingBox.expandByPoint(ss.min), this.boundingBox.expandByPoint(ss.max))
                            }
                        } else this.boundingBox.makeEmpty();
                        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                    },
                    computeBoundingSphere: function () {
                        null === this.boundingSphere && (this.boundingSphere = new E);
                        var a = this.attributes.position,
                            b = this.morphAttributes.position;
                        if (a) {
                            var t = this.boundingSphere.center;
                            if (ss.setFromBufferAttribute(a), b)
                                for (var e = 0, n = b.length; e < n; e++) {
                                    var r = b[e];
                                    us.setFromBufferAttribute(r), this.morphTargetsRelative ? (cs.addVectors(ss.min, us.min), ss.expandByPoint(cs), cs.addVectors(ss.max, us.max), ss.expandByPoint(cs)) : (ss.expandByPoint(us.min), ss.expandByPoint(us.max))
                                }
                            ss.getCenter(t);
                            var g = 0;
                            for (e = 0, n = a.count; e < n; e++) cs.fromBufferAttribute(a, e), g = Math.max(g, t.distanceToSquared(cs));
                            if (b)
                                for (e = 0, n = b.length; e < n; e++) {
                                    r = b[e];
                                    for (var o = this.morphTargetsRelative, c = 0, l = r.count; c < l; c++) cs.fromBufferAttribute(r, c), o && (os.fromBufferAttribute(a, c), cs.add(os)), g = Math.max(g, t.distanceToSquared(cs))
                                }
                            this.boundingSphere.radius = Math.sqrt(g), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                        }
                    },
                    computeFaceNormals: function () {},
                    computeVertexNormals: function () {
                        var a = this.index,
                            b = this.attributes;
                        if (b.position) {
                            var t = b.position.array;
                            if (void 0 === b.normal) this.setAttribute("normal", new N(new Float32Array(t.length), 3));
                            else
                                for (var e = b.normal.array, n = 0, r = e.length; n < r; n++) e[n] = 0;
                            e = b.normal.array;
                            var g = new o,
                                c = new o,
                                l = new o,
                                h = new o,
                                d = new o;
                            if (a) {
                                var p = a.array;
                                for (n = 0, r = a.count; n < r; n += 3) {
                                    a = 3 * p[n + 0];
                                    var q = 3 * p[n + 1],
                                        f = 3 * p[n + 2];
                                    g.fromArray(t, a), c.fromArray(t, q), l.fromArray(t, f), h.subVectors(l, c), d.subVectors(g, c), h.cross(d), e[a] += h.x, e[a + 1] += h.y, e[a + 2] += h.z, e[q] += h.x, e[q + 1] += h.y, e[q + 2] += h.z, e[f] += h.x, e[f + 1] += h.y, e[f + 2] += h.z
                                }
                            } else
                                for (n = 0, r = t.length; n < r; n += 9) g.fromArray(t, n), c.fromArray(t, n + 3), l.fromArray(t, n + 6), h.subVectors(l, c), d.subVectors(g, c), h.cross(d), e[n] = h.x, e[n + 1] = h.y, e[n + 2] = h.z, e[n + 3] = h.x, e[n + 4] = h.y, e[n + 5] = h.z, e[n + 6] = h.x, e[n + 7] = h.y, e[n + 8] = h.z;
                            this.normalizeNormals(), b.normal.needsUpdate = !0
                        }
                    },
                    merge: function (a, b) {
                        if (a && a.isBufferGeometry) {
                            void 0 === b && (b = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                            var t, e = this.attributes;
                            for (t in e)
                                if (void 0 !== a.attributes[t]) {
                                    var n = e[t].array,
                                        r = a.attributes[t],
                                        g = r.array,
                                        o = r.itemSize * b;
                                    r = Math.min(g.length, n.length - o);
                                    for (var c = 0; c < r; c++, o++) n[o] = g[c]
                                } return this
                        }
                        console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", a)
                    },
                    normalizeNormals: function () {
                        for (var a = this.attributes.normal, b = 0, t = a.count; b < t; b++) cs.x = a.getX(b), cs.y = a.getY(b), cs.z = a.getZ(b), cs.normalize(), a.setXYZ(b, cs.x, cs.y, cs.z)
                    },
                    toNonIndexed: function () {
                        function a(a, b) {
                            var t = a.array;
                            a = a.itemSize;
                            for (var e, n = new t.constructor(b.length * a), r = 0, g = 0, o = b.length; g < o; g++) {
                                e = b[g] * a;
                                for (var c = 0; c < a; c++) n[r++] = t[e++]
                            }
                            return new N(n, a)
                        }
                        if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                        var t, b = new X,
                            e = this.index.array,
                            n = this.attributes;
                        for (t in n) {
                            var r = n[t];
                            r = a(r, e), b.setAttribute(t, r)
                        }
                        var g = this.morphAttributes;
                        for (t in g) {
                            var o = [],
                                c = g[t];
                            n = 0;
                            for (var l = c.length; n < l; n++) r = a(r = c[n], e), o.push(r);
                            b.morphAttributes[t] = o
                        }
                        for (b.morphTargetsRelative = this.morphTargetsRelative, n = 0, t = (e = this.groups).length; n < t; n++) r = e[n], b.addGroup(r.start, r.count, r.materialIndex);
                        return b
                    },
                    toJSON: function () {
                        var a = {
                            metadata: {
                                version: 4.5,
                                type: "BufferGeometry",
                                generator: "BufferGeometry.toJSON"
                            }
                        };
                        if (a.uuid = this.uuid, a.type = this.type, "" !== this.name && (a.name = this.name), 0 < Object.keys(this.userData).length && (a.userData = this.userData), void 0 !== this.parameters) {
                            var b = this.parameters;
                            for (l in b) void 0 !== b[l] && (a[l] = b[l]);
                            return a
                        }
                        a.data = {
                            attributes: {}
                        }, null !== (b = this.index) && (a.data.index = {
                            type: b.array.constructor.name,
                            array: Array.prototype.slice.call(b.array)
                        });
                        var t = this.attributes;
                        for (l in t) {
                            var e = (b = t[l]).toJSON();
                            "" !== b.name && (e.name = b.name), a.data.attributes[l] = e
                        }
                        t = {};
                        var n = !1;
                        for (l in this.morphAttributes) {
                            for (var r = this.morphAttributes[l], g = [], o = 0, c = r.length; o < c; o++) e = (b = r[o]).toJSON(), "" !== b.name && (e.name = b.name), g.push(e);
                            0 < g.length && (t[l] = g, n = !0)
                        }
                        n && (a.data.morphAttributes = t, a.data.morphTargetsRelative = this.morphTargetsRelative);
                        var l = this.groups;
                        return 0 < l.length && (a.data.groups = JSON.parse(JSON.stringify(l))), null !== (l = this.boundingSphere) && (a.data.boundingSphere = {
                            center: l.center.toArray(),
                            radius: l.radius
                        }), a
                    },
                    clone: function () {
                        return (new X).copy(this)
                    },
                    copy: function (a) {
                        var b;
                        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.name = a.name;
                        var t = a.index;
                        for (g in null !== t && this.setIndex(t.clone()), t = a.attributes) this.setAttribute(g, t[g].clone());
                        var e = a.morphAttributes;
                        for (g in e) {
                            var n = [],
                                r = e[g];
                            for (t = 0, b = r.length; t < b; t++) n.push(r[t].clone());
                            this.morphAttributes[g] = n
                        }
                        this.morphTargetsRelative = a.morphTargetsRelative;
                        var g = a.groups;
                        for (t = 0, b = g.length; t < b; t++) e = g[t], this.addGroup(e.start, e.count, e.materialIndex);
                        return null !== (g = a.boundingBox) && (this.boundingBox = g.clone()), null !== (g = a.boundingSphere) && (this.boundingSphere = g.clone()), this.drawRange.start = a.drawRange.start, this.drawRange.count = a.drawRange.count, this.userData = a.userData, this
                    },
                    dispose: function () {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                });
                var ls = new m,
                    hs = new T,
                    ds = new E,
                    ps = new o,
                    fs = new o,
                    ms = new o,
                    gs = new o,
                    vs = new o,
                    ys = new o,
                    _s = new o,
                    xs = new o,
                    bs = new o,
                    ws = new n,
                    Ms = new n,
                    Es = new n,
                    Ts = new o,
                    Ds = new o;
                Z.prototype = Object.assign(Object.create(_.prototype), {
                    constructor: Z,
                    isMesh: !0,
                    copy: function (a) {
                        return _.prototype.copy.call(this, a), void 0 !== a.morphTargetInfluences && (this.morphTargetInfluences = a.morphTargetInfluences.slice()), void 0 !== a.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, a.morphTargetDictionary)), this
                    },
                    updateMorphTargets: function () {
                        var a = this.geometry;
                        if (a.isBufferGeometry) {
                            a = a.morphAttributes;
                            var b = Object.keys(a);
                            if (0 < b.length) {
                                var t = a[b[0]];
                                if (void 0 !== t)
                                    for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, a = 0, b = t.length; a < b; a++) {
                                        var e = t[a].name || String(a);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = a
                                    }
                            }
                        } else void 0 !== (a = a.morphTargets) && 0 < a.length && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    },
                    raycast: function (a, b) {
                        var t = this.geometry,
                            e = this.material,
                            r = this.matrixWorld;
                        if (void 0 !== e && (null === t.boundingSphere && t.computeBoundingSphere(), ds.copy(t.boundingSphere), ds.applyMatrix4(r), !1 !== a.ray.intersectsSphere(ds) && (ls.getInverse(r), hs.copy(a.ray).applyMatrix4(ls), null === t.boundingBox || !1 !== hs.intersectsBox(t.boundingBox))))
                            if (t.isBufferGeometry) {
                                var o = t.index;
                                r = t.attributes.position;
                                var q, c, g = t.morphAttributes.position,
                                    l = t.morphTargetsRelative,
                                    h = t.attributes.uv,
                                    d = t.attributes.uv2,
                                    f = t.groups,
                                    p = t.drawRange;
                                if (null !== o)
                                    if (Array.isArray(e)) {
                                        var m = 0;
                                        for (q = f.length; m < q; m++) {
                                            var u = f[m],
                                                v = e[u.materialIndex],
                                                y = Math.max(u.start, p.start);
                                            for (c = t = Math.min(u.start + u.count, p.start + p.count); y < c; y += 3) {
                                                t = o.getX(y);
                                                var _ = o.getX(y + 1),
                                                    x = o.getX(y + 2);
                                                (t = $(this, v, a, hs, r, g, l, h, d, t, _, x)) && (t.faceIndex = Math.floor(y / 3), t.face.materialIndex = u.materialIndex, b.push(t))
                                            }
                                        }
                                    } else
                                        for (m = y = Math.max(0, p.start), q = t = Math.min(o.count, p.start + p.count); m < q; m += 3) t = o.getX(m), _ = o.getX(m + 1), x = o.getX(m + 2), (t = $(this, e, a, hs, r, g, l, h, d, t, _, x)) && (t.faceIndex = Math.floor(m / 3), b.push(t));
                                else if (void 0 !== r)
                                    if (Array.isArray(e))
                                        for (m = 0, q = f.length; m < q; m++)
                                            for (v = e[(u = f[m]).materialIndex], y = Math.max(u.start, p.start), c = t = Math.min(u.start + u.count, p.start + p.count); y < c; y += 3)(t = $(this, v, a, hs, r, g, l, h, d, t = y, _ = y + 1, x = y + 2)) && (t.faceIndex = Math.floor(y / 3), t.face.materialIndex = u.materialIndex, b.push(t));
                                    else
                                        for (m = y = Math.max(0, p.start), q = t = Math.min(r.count, p.start + p.count); m < q; m += 3)(t = $(this, e, a, hs, r, g, l, h, d, t = m, _ = m + 1, x = m + 2)) && (t.faceIndex = Math.floor(m / 3), b.push(t))
                            } else if (t.isGeometry)
                            for (r = Array.isArray(e), g = t.vertices, l = t.faces, 0 < (t = t.faceVertexUvs[0]).length && (o = t), p = 0, m = l.length; p < m; p++) q = l[p], void 0 !== (t = r ? e[q.materialIndex] : e) && (h = g[q.a], d = g[q.b], f = g[q.c], t = J(this, t, a, hs, h, d, f, Ts)) && (o && o[p] && (u = o[p], ws.copy(u[0]), Ms.copy(u[1]), Es.copy(u[2]), t.uv = S.getUV(Ts, h, d, f, ws, Ms, Es, new n)), t.face = q, t.faceIndex = p, b.push(t))
                    },
                    clone: function () {
                        return new this.constructor(this.geometry, this.material).copy(this)
                    }
                });
                var Ss = 0,
                    As = new m,
                    Cs = new _,
                    Ls = new o;
                Q.prototype = Object.assign(Object.create(e.prototype), {
                    constructor: Q,
                    isGeometry: !0,
                    applyMatrix: function (a) {
                        for (var b = (new c).getNormalMatrix(a), t = 0, e = this.vertices.length; t < e; t++) this.vertices[t].applyMatrix4(a);
                        for (t = 0, e = this.faces.length; t < e; t++) {
                            (a = this.faces[t]).normal.applyMatrix3(b).normalize();
                            for (var n = 0, r = a.vertexNormals.length; n < r; n++) a.vertexNormals[n].applyMatrix3(b).normalize()
                        }
                        return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.normalsNeedUpdate = this.verticesNeedUpdate = !0, this
                    },
                    rotateX: function (a) {
                        return As.makeRotationX(a), this.applyMatrix(As), this
                    },
                    rotateY: function (a) {
                        return As.makeRotationY(a), this.applyMatrix(As), this
                    },
                    rotateZ: function (a) {
                        return As.makeRotationZ(a), this.applyMatrix(As), this
                    },
                    translate: function (a, b, t) {
                        return As.makeTranslation(a, b, t), this.applyMatrix(As), this
                    },
                    scale: function (a, b, t) {
                        return As.makeScale(a, b, t), this.applyMatrix(As), this
                    },
                    lookAt: function (a) {
                        return Cs.lookAt(a), Cs.updateMatrix(), this.applyMatrix(Cs.matrix), this
                    },
                    fromBufferGeometry: function (a) {
                        function b(a, b, e, r) {
                            var c = void 0 === l ? [] : [t.colors[a].clone(), t.colors[b].clone(), t.colors[e].clone()];
                            r = new P(a, b, e, void 0 === g ? [] : [(new o).fromArray(g, 3 * a), (new o).fromArray(g, 3 * b), (new o).fromArray(g, 3 * e)], c, r), t.faces.push(r), void 0 !== h && t.faceVertexUvs[0].push([(new n).fromArray(h, 2 * a), (new n).fromArray(h, 2 * b), (new n).fromArray(h, 2 * e)]), void 0 !== d && t.faceVertexUvs[1].push([(new n).fromArray(d, 2 * a), (new n).fromArray(d, 2 * b), (new n).fromArray(d, 2 * e)])
                        }
                        var t = this,
                            e = null !== a.index ? a.index.array : void 0,
                            r = a.attributes;
                        if (void 0 === r.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
                        var c = r.position.array,
                            g = void 0 !== r.normal ? r.normal.array : void 0,
                            l = void 0 !== r.color ? r.color.array : void 0,
                            h = void 0 !== r.uv ? r.uv.array : void 0,
                            d = void 0 !== r.uv2 ? r.uv2.array : void 0;
                        for (void 0 !== d && (this.faceVertexUvs[1] = []), r = 0; r < c.length; r += 3) t.vertices.push((new o).fromArray(c, r)), void 0 !== l && t.colors.push((new A).fromArray(l, r));
                        var f = a.groups;
                        if (0 < f.length)
                            for (r = 0; r < f.length; r++) {
                                var p = (c = f[r]).start,
                                    q = p;
                                for (p += c.count; q < p; q += 3) void 0 !== e ? b(e[q], e[q + 1], e[q + 2], c.materialIndex) : b(q, q + 1, q + 2, c.materialIndex)
                            } else if (void 0 !== e)
                                for (r = 0; r < e.length; r += 3) b(e[r], e[r + 1], e[r + 2]);
                            else
                                for (r = 0; r < c.length / 3; r += 3) b(r, r + 1, r + 2);
                        return this.computeFaceNormals(), null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()), null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()), this
                    },
                    center: function () {
                        return this.computeBoundingBox(), this.boundingBox.getCenter(Ls).negate(), this.translate(Ls.x, Ls.y, Ls.z), this
                    },
                    normalize: function () {
                        this.computeBoundingSphere();
                        var a = this.boundingSphere.center,
                            b = this.boundingSphere.radius;
                        b = 0 === b ? 1 : 1 / b;
                        var t = new m;
                        return t.set(b, 0, 0, -b * a.x, 0, b, 0, -b * a.y, 0, 0, b, -b * a.z, 0, 0, 0, 1), this.applyMatrix(t), this
                    },
                    computeFaceNormals: function () {
                        for (var a = new o, b = new o, t = 0, e = this.faces.length; t < e; t++) {
                            var n = this.faces[t],
                                r = this.vertices[n.a],
                                g = this.vertices[n.b];
                            a.subVectors(this.vertices[n.c], g), b.subVectors(r, g), a.cross(b), a.normalize(), n.normal.copy(a)
                        }
                    },
                    computeVertexNormals: function (a) {
                        var b;
                        void 0 === a && (a = !0);
                        var t = Array(this.vertices.length),
                            e = 0;
                        for (b = this.vertices.length; e < b; e++) t[e] = new o;
                        if (a) {
                            var n = new o,
                                r = new o;
                            for (a = 0, e = this.faces.length; a < e; a++) {
                                b = this.faces[a];
                                var g = this.vertices[b.a],
                                    c = this.vertices[b.b],
                                    l = this.vertices[b.c];
                                n.subVectors(l, c), r.subVectors(g, c), n.cross(r), t[b.a].add(n), t[b.b].add(n), t[b.c].add(n)
                            }
                        } else
                            for (this.computeFaceNormals(), a = 0, e = this.faces.length; a < e; a++) t[(b = this.faces[a]).a].add(b.normal), t[b.b].add(b.normal), t[b.c].add(b.normal);
                        for (e = 0, b = this.vertices.length; e < b; e++) t[e].normalize();
                        for (a = 0, e = this.faces.length; a < e; a++) 3 === (g = (b = this.faces[a]).vertexNormals).length ? (g[0].copy(t[b.a]), g[1].copy(t[b.b]), g[2].copy(t[b.c])) : (g[0] = t[b.a].clone(), g[1] = t[b.b].clone(), g[2] = t[b.c].clone());
                        0 < this.faces.length && (this.normalsNeedUpdate = !0)
                    },
                    computeFlatVertexNormals: function () {
                        var a;
                        this.computeFaceNormals();
                        var b = 0;
                        for (a = this.faces.length; b < a; b++) {
                            var t = this.faces[b],
                                e = t.vertexNormals;
                            3 === e.length ? (e[0].copy(t.normal), e[1].copy(t.normal), e[2].copy(t.normal)) : (e[0] = t.normal.clone(), e[1] = t.normal.clone(), e[2] = t.normal.clone())
                        }
                        0 < this.faces.length && (this.normalsNeedUpdate = !0)
                    },
                    computeMorphNormals: function () {
                        var a, b, t = 0;
                        for (b = this.faces.length; t < b; t++) {
                            var e = this.faces[t];
                            e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(), e.__originalVertexNormals || (e.__originalVertexNormals = []);
                            var n = 0;
                            for (a = e.vertexNormals.length; n < a; n++) e.__originalVertexNormals[n] ? e.__originalVertexNormals[n].copy(e.vertexNormals[n]) : e.__originalVertexNormals[n] = e.vertexNormals[n].clone()
                        }
                        var r = new Q;
                        for (r.faces = this.faces, n = 0, a = this.morphTargets.length; n < a; n++) {
                            if (!this.morphNormals[n]) {
                                this.morphNormals[n] = {}, this.morphNormals[n].faceNormals = [], this.morphNormals[n].vertexNormals = [], e = this.morphNormals[n].faceNormals;
                                var g = this.morphNormals[n].vertexNormals;
                                for (t = 0, b = this.faces.length; t < b; t++) {
                                    var c = new o,
                                        l = {
                                            a: new o,
                                            b: new o,
                                            c: new o
                                        };
                                    e.push(c), g.push(l)
                                }
                            }
                            for (g = this.morphNormals[n], r.vertices = this.morphTargets[n].vertices, r.computeFaceNormals(), r.computeVertexNormals(), t = 0, b = this.faces.length; t < b; t++) e = this.faces[t], c = g.faceNormals[t], l = g.vertexNormals[t], c.copy(e.normal), l.a.copy(e.vertexNormals[0]), l.b.copy(e.vertexNormals[1]), l.c.copy(e.vertexNormals[2])
                        }
                        for (t = 0, b = this.faces.length; t < b; t++)(e = this.faces[t]).normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals
                    },
                    computeBoundingBox: function () {
                        null === this.boundingBox && (this.boundingBox = new w), this.boundingBox.setFromPoints(this.vertices)
                    },
                    computeBoundingSphere: function () {
                        null === this.boundingSphere && (this.boundingSphere = new E), this.boundingSphere.setFromPoints(this.vertices)
                    },
                    merge: function (a, b, t) {
                        if (a && a.isGeometry) {
                            var e, n = this.vertices.length,
                                r = this.vertices,
                                g = a.vertices,
                                o = this.faces,
                                l = a.faces,
                                h = this.colors,
                                d = a.colors;
                            void 0 === t && (t = 0), void 0 !== b && (e = (new c).getNormalMatrix(b));
                            for (var p = 0, q = g.length; p < q; p++) {
                                var f = g[p].clone();
                                void 0 !== b && f.applyMatrix4(b), r.push(f)
                            }
                            for (p = 0, q = d.length; p < q; p++) h.push(d[p].clone());
                            for (p = 0, q = l.length; p < q; p++) {
                                var m = (g = l[p]).vertexNormals;
                                for (d = g.vertexColors, (h = new P(g.a + n, g.b + n, g.c + n)).normal.copy(g.normal), void 0 !== e && h.normal.applyMatrix3(e).normalize(), b = 0, r = m.length; b < r; b++) f = m[b].clone(), void 0 !== e && f.applyMatrix3(e).normalize(), h.vertexNormals.push(f);
                                for (h.color.copy(g.color), b = 0, r = d.length; b < r; b++) f = d[b], h.vertexColors.push(f.clone());
                                h.materialIndex = g.materialIndex + t, o.push(h)
                            }
                            for (p = 0, q = a.faceVertexUvs.length; p < q; p++)
                                for (t = a.faceVertexUvs[p], void 0 === this.faceVertexUvs[p] && (this.faceVertexUvs[p] = []), b = 0, r = t.length; b < r; b++) {
                                    for (n = [], o = 0, l = (e = t[b]).length; o < l; o++) n.push(e[o].clone());
                                    this.faceVertexUvs[p].push(n)
                                }
                        } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", a)
                    },
                    mergeMesh: function (a) {
                        a && a.isMesh ? (a.matrixAutoUpdate && a.updateMatrix(), this.merge(a.geometry, a.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", a)
                    },
                    mergeVertices: function () {
                        var t, a = {},
                            b = [],
                            e = [],
                            n = Math.pow(10, 4),
                            r = 0;
                        for (t = this.vertices.length; r < t; r++) {
                            var g = this.vertices[r];
                            void 0 === a[g = Math.round(g.x * n) + "_" + Math.round(g.y * n) + "_" + Math.round(g.z * n)] ? (a[g] = r, b.push(this.vertices[r]), e[r] = b.length - 1) : e[r] = e[a[g]]
                        }
                        for (a = [], r = 0, t = this.faces.length; r < t; r++)
                            for ((n = this.faces[r]).a = e[n.a], n.b = e[n.b], n.c = e[n.c], n = [n.a, n.b, n.c], g = 0; 3 > g; g++)
                                if (n[g] === n[(g + 1) % 3]) {
                                    a.push(r);
                                    break
                                } for (r = a.length - 1; 0 <= r; r--)
                            for (n = a[r], this.faces.splice(n, 1), e = 0, t = this.faceVertexUvs.length; e < t; e++) this.faceVertexUvs[e].splice(n, 1);
                        return r = this.vertices.length - b.length, this.vertices = b, r
                    },
                    setFromPoints: function (a) {
                        this.vertices = [];
                        for (var b = 0, t = a.length; b < t; b++) {
                            var e = a[b];
                            this.vertices.push(new o(e.x, e.y, e.z || 0))
                        }
                        return this
                    },
                    sortFacesByMaterialIndex: function () {
                        for (var a = this.faces, b = a.length, t = 0; t < b; t++) a[t]._id = t;
                        a.sort((function (a, b) {
                            return a.materialIndex - b.materialIndex
                        }));
                        var e, g, n = this.faceVertexUvs[0],
                            r = this.faceVertexUvs[1];
                        for (n && n.length === b && (e = []), r && r.length === b && (g = []), t = 0; t < b; t++) {
                            var o = a[t]._id;
                            e && e.push(n[o]), g && g.push(r[o])
                        }
                        e && (this.faceVertexUvs[0] = e), g && (this.faceVertexUvs[1] = g)
                    },
                    toJSON: function () {
                        function a(a, b, t) {
                            return t ? a | 1 << b : a & ~(1 << b)
                        }

                        function b(a) {
                            var b = a.x.toString() + a.y.toString() + a.z.toString();
                            return void 0 !== l[b] ? l[b] : (l[b] = c.length / 3, c.push(a.x, a.y, a.z), l[b])
                        }

                        function t(a) {
                            var b = a.r.toString() + a.g.toString() + a.b.toString();
                            return void 0 !== p[b] ? p[b] : (p[b] = h.length, h.push(a.getHex()), p[b])
                        }

                        function e(a) {
                            var b = a.x.toString() + a.y.toString();
                            return void 0 !== d[b] ? d[b] : (d[b] = q.length / 2, q.push(a.x, a.y), d[b])
                        }
                        var n = {
                            metadata: {
                                version: 4.5,
                                type: "Geometry",
                                generator: "Geometry.toJSON"
                            }
                        };
                        if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), void 0 !== this.parameters) {
                            var g, r = this.parameters;
                            for (g in r) void 0 !== r[g] && (n[g] = r[g]);
                            return n
                        }
                        for (r = [], g = 0; g < this.vertices.length; g++) {
                            var o = this.vertices[g];
                            r.push(o.x, o.y, o.z)
                        }
                        o = [];
                        var c = [],
                            l = {},
                            h = [],
                            p = {},
                            q = [],
                            d = {};
                        for (g = 0; g < this.faces.length; g++) {
                            var f = this.faces[g],
                                u = void 0 !== this.faceVertexUvs[0][g],
                                m = 0 < f.normal.length(),
                                v = 0 < f.vertexNormals.length,
                                y = 1 !== f.color.r || 1 !== f.color.g || 1 !== f.color.b,
                                _ = 0 < f.vertexColors.length,
                                x = 0;
                            x = a(x, 0, 0), x = a(x, 1, !0), x = a(x, 2, !1), x = a(x, 3, u), x = a(x, 4, m), x = a(x, 5, v), x = a(x, 6, y), x = a(x, 7, _), o.push(x), o.push(f.a, f.b, f.c), o.push(f.materialIndex), u && (u = this.faceVertexUvs[0][g], o.push(e(u[0]), e(u[1]), e(u[2]))), m && o.push(b(f.normal)), v && (m = f.vertexNormals, o.push(b(m[0]), b(m[1]), b(m[2]))), y && o.push(t(f.color)), _ && (f = f.vertexColors, o.push(t(f[0]), t(f[1]), t(f[2])))
                        }
                        return n.data = {}, n.data.vertices = r, n.data.normals = c, 0 < h.length && (n.data.colors = h), 0 < q.length && (n.data.uvs = [q]), n.data.faces = o, n
                    },
                    clone: function () {
                        return (new Q).copy(this)
                    },
                    copy: function (a) {
                        var b, t, e;
                        this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                            []
                        ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.name = a.name;
                        var n = a.vertices,
                            r = 0;
                        for (b = n.length; r < b; r++) this.vertices.push(n[r].clone());
                        for (r = 0, b = (n = a.colors).length; r < b; r++) this.colors.push(n[r].clone());
                        for (r = 0, b = (n = a.faces).length; r < b; r++) this.faces.push(n[r].clone());
                        for (r = 0, b = a.faceVertexUvs.length; r < b; r++) {
                            var g = a.faceVertexUvs[r];
                            for (void 0 === this.faceVertexUvs[r] && (this.faceVertexUvs[r] = []), n = 0, t = g.length; n < t; n++) {
                                var o = g[n],
                                    c = [],
                                    l = 0;
                                for (e = o.length; l < e; l++) c.push(o[l].clone());
                                this.faceVertexUvs[r].push(c)
                            }
                        }
                        for (r = 0, b = (l = a.morphTargets).length; r < b; r++) {
                            if ((e = {}).name = l[r].name, void 0 !== l[r].vertices)
                                for (e.vertices = [], n = 0, t = l[r].vertices.length; n < t; n++) e.vertices.push(l[r].vertices[n].clone());
                            if (void 0 !== l[r].normals)
                                for (e.normals = [], n = 0, t = l[r].normals.length; n < t; n++) e.normals.push(l[r].normals[n].clone());
                            this.morphTargets.push(e)
                        }
                        for (r = 0, b = (l = a.morphNormals).length; r < b; r++) {
                            if (e = {}, void 0 !== l[r].vertexNormals)
                                for (e.vertexNormals = [], n = 0, t = l[r].vertexNormals.length; n < t; n++) g = l[r].vertexNormals[n], (o = {}).a = g.a.clone(), o.b = g.b.clone(), o.c = g.c.clone(), e.vertexNormals.push(o);
                            if (void 0 !== l[r].faceNormals)
                                for (e.faceNormals = [], n = 0, t = l[r].faceNormals.length; n < t; n++) e.faceNormals.push(l[r].faceNormals[n].clone());
                            this.morphNormals.push(e)
                        }
                        for (r = 0, b = (n = a.skinWeights).length; r < b; r++) this.skinWeights.push(n[r].clone());
                        for (r = 0, b = (n = a.skinIndices).length; r < b; r++) this.skinIndices.push(n[r].clone());
                        for (r = 0, b = (n = a.lineDistances).length; r < b; r++) this.lineDistances.push(n[r]);
                        return null !== (r = a.boundingBox) && (this.boundingBox = r.clone()), null !== (r = a.boundingSphere) && (this.boundingSphere = r.clone()), this.elementsNeedUpdate = a.elementsNeedUpdate, this.verticesNeedUpdate = a.verticesNeedUpdate, this.uvsNeedUpdate = a.uvsNeedUpdate, this.normalsNeedUpdate = a.normalsNeedUpdate, this.colorsNeedUpdate = a.colorsNeedUpdate, this.lineDistancesNeedUpdate = a.lineDistancesNeedUpdate, this.groupsNeedUpdate = a.groupsNeedUpdate, this
                    },
                    dispose: function () {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                });
                var Rs = function (a) {
                        function b(b, t, e, n, g, r) {
                            a.call(this), this.type = "BoxGeometry", this.parameters = {
                                width: b,
                                height: t,
                                depth: e,
                                widthSegments: n,
                                heightSegments: g,
                                depthSegments: r
                            }, this.fromBufferGeometry(new Ps(b, t, e, n, g, r)), this.mergeVertices()
                        }
                        return a && (b.__proto__ = a), b.prototype = Object.create(a && a.prototype), b.prototype.constructor = b
                    }(Q),
                    Ps = function (a) {
                        function b(b, t, e, n, g, r) {
                            function c(a, b, t, e, n, r, g, c, m, v, y) {
                                var _ = r / m,
                                    x = g / v,
                                    w = r / 2,
                                    M = g / 2,
                                    E = c / 2;
                                g = m + 1;
                                var T, D, S = v + 1,
                                    A = r = 0,
                                    C = new o;
                                for (D = 0; D < S; D++) {
                                    var L = D * x - M;
                                    for (T = 0; T < g; T++) C[a] = (T * _ - w) * e, C[b] = L * n, C[t] = E, p.push(C.x, C.y, C.z), C[a] = 0, C[b] = 0, C[t] = 0 < c ? 1 : -1, q.push(C.x, C.y, C.z), d.push(T / m), d.push(1 - D / v), r += 1
                                }
                                for (D = 0; D < v; D++)
                                    for (T = 0; T < m; T++) a = f + T + g * (D + 1), b = f + (T + 1) + g * (D + 1), t = f + (T + 1) + g * D, h.push(f + T + g * D, a, t), h.push(a, b, t), A += 6;
                                l.addGroup(u, A, y), u += A, f += r
                            }
                            a.call(this), this.type = "BoxBufferGeometry", this.parameters = {
                                width: b,
                                height: t,
                                depth: e,
                                widthSegments: n,
                                heightSegments: g,
                                depthSegments: r
                            };
                            var l = this;
                            b = b || 1, t = t || 1, e = e || 1, n = Math.floor(n) || 1, g = Math.floor(g) || 1, r = Math.floor(r) || 1;
                            var h = [],
                                p = [],
                                q = [],
                                d = [],
                                f = 0,
                                u = 0;
                            c("z", "y", "x", -1, -1, e, t, b, r, g, 0), c("z", "y", "x", 1, -1, e, t, -b, r, g, 1), c("x", "z", "y", 1, 1, b, e, t, n, r, 2), c("x", "z", "y", 1, -1, b, e, -t, n, r, 3), c("x", "y", "z", 1, -1, b, t, e, n, g, 4), c("x", "y", "z", -1, -1, b, t, -e, n, g, 5), this.setIndex(h), this.setAttribute("position", new V(p, 3)), this.setAttribute("normal", new V(q, 3)), this.setAttribute("uv", new V(d, 2))
                        }
                        return a && (b.__proto__ = a), b.prototype = Object.create(a && a.prototype), b.prototype.constructor = b
                    }(X),
                    Os = {
                        clone: K,
                        merge: tt
                    };
                et.prototype = Object.create(O.prototype), et.prototype.constructor = et, et.prototype.isShaderMaterial = !0, et.prototype.copy = function (a) {
                    return O.prototype.copy.call(this, a), this.fragmentShader = a.fragmentShader, this.vertexShader = a.vertexShader, this.uniforms = K(a.uniforms), this.defines = Object.assign({}, a.defines), this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.lights = a.lights, this.clipping = a.clipping, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, this.extensions = a.extensions, this
                }, et.prototype.toJSON = function (a) {
                    var b = O.prototype.toJSON.call(this, a);
                    for (var t in b.uniforms = {}, this.uniforms) {
                        var e = this.uniforms[t].value;
                        b.uniforms[t] = e && e.isTexture ? {
                            type: "t",
                            value: e.toJSON(a).uuid
                        } : e && e.isColor ? {
                            type: "c",
                            value: e.getHex()
                        } : e && e.isVector2 ? {
                            type: "v2",
                            value: e.toArray()
                        } : e && e.isVector3 ? {
                            type: "v3",
                            value: e.toArray()
                        } : e && e.isVector4 ? {
                            type: "v4",
                            value: e.toArray()
                        } : e && e.isMatrix3 ? {
                            type: "m3",
                            value: e.toArray()
                        } : e && e.isMatrix4 ? {
                            type: "m4",
                            value: e.toArray()
                        } : {
                            value: e
                        }
                    }
                    for (var n in 0 < Object.keys(this.defines).length && (b.defines = this.defines), b.vertexShader = this.vertexShader, b.fragmentShader = this.fragmentShader, a = {}, this.extensions) !0 === this.extensions[n] && (a[n] = !0);
                    return 0 < Object.keys(a).length && (b.extensions = a), b
                }, nt.prototype = Object.assign(Object.create(_.prototype), {
                    constructor: nt,
                    isCamera: !0,
                    copy: function (a, b) {
                        return _.prototype.copy.call(this, a, b), this.matrixWorldInverse.copy(a.matrixWorldInverse), this.projectionMatrix.copy(a.projectionMatrix), this.projectionMatrixInverse.copy(a.projectionMatrixInverse), this
                    },
                    getWorldDirection: function (a) {
                        void 0 === a && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), a = new o), this.updateMatrixWorld(!0);
                        var b = this.matrixWorld.elements;
                        return a.set(-b[8], -b[9], -b[10]).normalize()
                    },
                    updateMatrixWorld: function (a) {
                        _.prototype.updateMatrixWorld.call(this, a), this.matrixWorldInverse.getInverse(this.matrixWorld)
                    },
                    clone: function () {
                        return (new this.constructor).copy(this)
                    }
                }), it.prototype = Object.assign(Object.create(nt.prototype), {
                    constructor: it,
                    isPerspectiveCamera: !0,
                    copy: function (a, b) {
                        return nt.prototype.copy.call(this, a, b), this.fov = a.fov, this.zoom = a.zoom, this.near = a.near, this.far = a.far, this.focus = a.focus, this.aspect = a.aspect, this.view = null === a.view ? null : Object.assign({}, a.view), this.filmGauge = a.filmGauge, this.filmOffset = a.filmOffset, this
                    },
                    setFocalLength: function (a) {
                        a = .5 * this.getFilmHeight() / a, this.fov = 2 * Va.RAD2DEG * Math.atan(a), this.updateProjectionMatrix()
                    },
                    getFocalLength: function () {
                        var a = Math.tan(.5 * Va.DEG2RAD * this.fov);
                        return .5 * this.getFilmHeight() / a
                    },
                    getEffectiveFOV: function () {
                        return 2 * Va.RAD2DEG * Math.atan(Math.tan(.5 * Va.DEG2RAD * this.fov) / this.zoom)
                    },
                    getFilmWidth: function () {
                        return this.filmGauge * Math.min(this.aspect, 1)
                    },
                    getFilmHeight: function () {
                        return this.filmGauge / Math.max(this.aspect, 1)
                    },
                    setViewOffset: function (a, b, t, e, n, r) {
                        this.aspect = a / b, null === this.view && (this.view = {
                            enabled: !0,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1
                        }), this.view.enabled = !0, this.view.fullWidth = a, this.view.fullHeight = b, this.view.offsetX = t, this.view.offsetY = e, this.view.width = n, this.view.height = r, this.updateProjectionMatrix()
                    },
                    clearViewOffset: function () {
                        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                    },
                    updateProjectionMatrix: function () {
                        var a = this.near,
                            b = a * Math.tan(.5 * Va.DEG2RAD * this.fov) / this.zoom,
                            t = 2 * b,
                            e = this.aspect * t,
                            n = -.5 * e,
                            r = this.view;
                        if (null !== this.view && this.view.enabled) {
                            var g = r.fullWidth,
                                o = r.fullHeight;
                            n += r.offsetX * e / g, b -= r.offsetY * t / o, e *= r.width / g, t *= r.height / o
                        }
                        0 !== (r = this.filmOffset) && (n += a * r / this.getFilmWidth()), this.projectionMatrix.makePerspective(n, n + e, b, b - t, a, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                    },
                    toJSON: function (a) {
                        return (a = _.prototype.toJSON.call(this, a)).object.fov = this.fov, a.object.zoom = this.zoom, a.object.near = this.near, a.object.far = this.far, a.object.focus = this.focus, a.object.aspect = this.aspect, null !== this.view && (a.object.view = Object.assign({}, this.view)), a.object.filmGauge = this.filmGauge, a.object.filmOffset = this.filmOffset, a
                    }
                }), at.prototype = Object.create(_.prototype), at.prototype.constructor = at, ot.prototype = Object.create(d.prototype), ot.prototype.constructor = ot, ot.prototype.isWebGLRenderTargetCube = !0, ot.prototype.fromEquirectangularTexture = function (a, b) {
                    this.texture.type = b.type, this.texture.format = b.format, this.texture.encoding = b.encoding;
                    var t = new x,
                        e = new et({
                            type: "CubemapFromEquirect",
                            uniforms: K({
                                tEquirect: {
                                    value: null
                                }
                            }),
                            vertexShader: "varying vec3 vWorldDirection;\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                            fragmentShader: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}",
                            side: 1,
                            blending: 0
                        });
                    return e.uniforms.tEquirect.value = b, b = new Z(new Ps(5, 5, 5), e), t.add(b), (e = new at(1, 10, 1)).renderTarget = this, e.renderTarget.texture.name = "CubeCameraTexture", e.update(a, t), b.geometry.dispose(), b.material.dispose(), this
                }, st.prototype = Object.create(l.prototype), st.prototype.constructor = st, st.prototype.isDataTexture = !0;
                var Fs = new E,
                    Ns = new o;
                Object.assign(ut.prototype, {
                    set: function (a, b, t, e, n, r) {
                        var g = this.planes;
                        return g[0].copy(a), g[1].copy(b), g[2].copy(t), g[3].copy(e), g[4].copy(n), g[5].copy(r), this
                    },
                    clone: function () {
                        return (new this.constructor).copy(this)
                    },
                    copy: function (a) {
                        for (var b = this.planes, t = 0; 6 > t; t++) b[t].copy(a.planes[t]);
                        return this
                    },
                    setFromMatrix: function (a) {
                        var b = this.planes,
                            t = a.elements;
                        a = t[0];
                        var e = t[1],
                            n = t[2],
                            r = t[3],
                            g = t[4],
                            o = t[5],
                            c = t[6],
                            l = t[7],
                            h = t[8],
                            p = t[9],
                            q = t[10],
                            d = t[11],
                            f = t[12],
                            u = t[13],
                            m = t[14];
                        return t = t[15], b[0].setComponents(r - a, l - g, d - h, t - f).normalize(), b[1].setComponents(r + a, l + g, d + h, t + f).normalize(), b[2].setComponents(r + e, l + o, d + p, t + u).normalize(), b[3].setComponents(r - e, l - o, d - p, t - u).normalize(), b[4].setComponents(r - n, l - c, d - q, t - m).normalize(), b[5].setComponents(r + n, l + c, d + q, t + m).normalize(), this
                    },
                    intersectsObject: function (a) {
                        var b = a.geometry;
                        return null === b.boundingSphere && b.computeBoundingSphere(), Fs.copy(b.boundingSphere).applyMatrix4(a.matrixWorld), this.intersectsSphere(Fs)
                    },
                    intersectsSprite: function (a) {
                        return Fs.center.set(0, 0, 0), Fs.radius = .7071067811865476, Fs.applyMatrix4(a.matrixWorld), this.intersectsSphere(Fs)
                    },
                    intersectsSphere: function (a) {
                        var b = this.planes,
                            t = a.center;
                        a = -a.radius;
                        for (var e = 0; 6 > e; e++)
                            if (b[e].distanceToPoint(t) < a) return !1;
                        return !0
                    },
                    intersectsBox: function (a) {
                        for (var b = this.planes, t = 0; 6 > t; t++) {
                            var e = b[t];
                            if (Ns.x = 0 < e.normal.x ? a.max.x : a.min.x, Ns.y = 0 < e.normal.y ? a.max.y : a.min.y, Ns.z = 0 < e.normal.z ? a.max.z : a.min.z, 0 > e.distanceToPoint(Ns)) return !1
                        }
                        return !0
                    },
                    containsPoint: function (a) {
                        for (var b = this.planes, t = 0; 6 > t; t++)
                            if (0 > b[t].distanceToPoint(a)) return !1;
                        return !0
                    }
                });
                var Is = {
                        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                        alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
                        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
                        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                        begin_vertex: "vec3 transformed = vec3( position );",
                        beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                        bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
                        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
                        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
                        color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                        color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                        color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                        color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
                        common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}",
                        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);\n    } else if (face == 1.0) {\n      uv = vec2(direction.x, -direction.z) / abs(direction.y);\n    } else if (face == 2.0) {\n      uv = direction.xy / abs(direction.z);\n    } else if (face == 3.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);\n    } else if (face == 4.0) {\n      uv = direction.xz / abs(direction.y);\n    } else {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);\n    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif",
                        defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\ttransformedNormal = mat3( instanceMatrix ) * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                        encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                        encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
                        envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ), 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                        envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                        envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                        envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
                        envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                        fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
                        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
                        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                        gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
                        lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
                        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                        lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
                        lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
                        lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                        lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
                        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                        lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = saturate( clearcoat );\tmaterial.clearcoatRoughness = max( clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
                        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                        lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( pointLight.shadow, directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( spotLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( directionalLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
                        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                        logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                        map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
                        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                        map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                        map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
                        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
                        normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                        normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
                        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
                        clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                        clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",
                        clearcoat_normalmap_pars_fragment: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
                        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                        project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                        dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                        dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                        shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = ( floor( uv * size - 0.5 ) + 0.5 ) * texelSize;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                        shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
                        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= all( bvec2( directionalLight.shadow, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= all( bvec2( spotLight.shadow, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= all( bvec2( pointLight.shadow, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                        tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                        tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
                        uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
                        uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
                        uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                        uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                        uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
                        uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
                        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                        background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                        background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                        cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                        cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
                        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
                        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                        equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                        meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                        meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
                        normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
                        shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                        sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
                    },
                    Bs = {
                        common: {
                            diffuse: {
                                value: new A(15658734)
                            },
                            opacity: {
                                value: 1
                            },
                            map: {
                                value: null
                            },
                            uvTransform: {
                                value: new c
                            },
                            uv2Transform: {
                                value: new c
                            },
                            alphaMap: {
                                value: null
                            }
                        },
                        specularmap: {
                            specularMap: {
                                value: null
                            }
                        },
                        envmap: {
                            envMap: {
                                value: null
                            },
                            flipEnvMap: {
                                value: -1
                            },
                            reflectivity: {
                                value: 1
                            },
                            refractionRatio: {
                                value: .98
                            },
                            maxMipLevel: {
                                value: 0
                            }
                        },
                        aomap: {
                            aoMap: {
                                value: null
                            },
                            aoMapIntensity: {
                                value: 1
                            }
                        },
                        lightmap: {
                            lightMap: {
                                value: null
                            },
                            lightMapIntensity: {
                                value: 1
                            }
                        },
                        emissivemap: {
                            emissiveMap: {
                                value: null
                            }
                        },
                        bumpmap: {
                            bumpMap: {
                                value: null
                            },
                            bumpScale: {
                                value: 1
                            }
                        },
                        normalmap: {
                            normalMap: {
                                value: null
                            },
                            normalScale: {
                                value: new n(1, 1)
                            }
                        },
                        displacementmap: {
                            displacementMap: {
                                value: null
                            },
                            displacementScale: {
                                value: 1
                            },
                            displacementBias: {
                                value: 0
                            }
                        },
                        roughnessmap: {
                            roughnessMap: {
                                value: null
                            }
                        },
                        metalnessmap: {
                            metalnessMap: {
                                value: null
                            }
                        },
                        gradientmap: {
                            gradientMap: {
                                value: null
                            }
                        },
                        fog: {
                            fogDensity: {
                                value: 25e-5
                            },
                            fogNear: {
                                value: 1
                            },
                            fogFar: {
                                value: 2e3
                            },
                            fogColor: {
                                value: new A(16777215)
                            }
                        },
                        lights: {
                            ambientLightColor: {
                                value: []
                            },
                            lightProbe: {
                                value: []
                            },
                            directionalLights: {
                                value: [],
                                properties: {
                                    direction: {},
                                    color: {},
                                    shadow: {},
                                    shadowBias: {},
                                    shadowRadius: {},
                                    shadowMapSize: {}
                                }
                            },
                            directionalShadowMap: {
                                value: []
                            },
                            directionalShadowMatrix: {
                                value: []
                            },
                            spotLights: {
                                value: [],
                                properties: {
                                    color: {},
                                    position: {},
                                    direction: {},
                                    distance: {},
                                    coneCos: {},
                                    penumbraCos: {},
                                    decay: {},
                                    shadow: {},
                                    shadowBias: {},
                                    shadowRadius: {},
                                    shadowMapSize: {}
                                }
                            },
                            spotShadowMap: {
                                value: []
                            },
                            spotShadowMatrix: {
                                value: []
                            },
                            pointLights: {
                                value: [],
                                properties: {
                                    color: {},
                                    position: {},
                                    decay: {},
                                    distance: {},
                                    shadow: {},
                                    shadowBias: {},
                                    shadowRadius: {},
                                    shadowMapSize: {},
                                    shadowCameraNear: {},
                                    shadowCameraFar: {}
                                }
                            },
                            pointShadowMap: {
                                value: []
                            },
                            pointShadowMatrix: {
                                value: []
                            },
                            hemisphereLights: {
                                value: [],
                                properties: {
                                    direction: {},
                                    skyColor: {},
                                    groundColor: {}
                                }
                            },
                            rectAreaLights: {
                                value: [],
                                properties: {
                                    color: {},
                                    position: {},
                                    width: {},
                                    height: {}
                                }
                            }
                        },
                        points: {
                            diffuse: {
                                value: new A(15658734)
                            },
                            opacity: {
                                value: 1
                            },
                            size: {
                                value: 1
                            },
                            scale: {
                                value: 1
                            },
                            map: {
                                value: null
                            },
                            alphaMap: {
                                value: null
                            },
                            uvTransform: {
                                value: new c
                            }
                        },
                        sprite: {
                            diffuse: {
                                value: new A(15658734)
                            },
                            opacity: {
                                value: 1
                            },
                            center: {
                                value: new n(.5, .5)
                            },
                            rotation: {
                                value: 0
                            },
                            map: {
                                value: null
                            },
                            alphaMap: {
                                value: null
                            },
                            uvTransform: {
                                value: new c
                            }
                        }
                    },
                    ks = {
                        basic: {
                            uniforms: tt([Bs.common, Bs.specularmap, Bs.envmap, Bs.aomap, Bs.lightmap, Bs.fog]),
                            vertexShader: Is.meshbasic_vert,
                            fragmentShader: Is.meshbasic_frag
                        },
                        lambert: {
                            uniforms: tt([Bs.common, Bs.specularmap, Bs.envmap, Bs.aomap, Bs.lightmap, Bs.emissivemap, Bs.fog, Bs.lights, {
                                emissive: {
                                    value: new A(0)
                                }
                            }]),
                            vertexShader: Is.meshlambert_vert,
                            fragmentShader: Is.meshlambert_frag
                        },
                        phong: {
                            uniforms: tt([Bs.common, Bs.specularmap, Bs.envmap, Bs.aomap, Bs.lightmap, Bs.emissivemap, Bs.bumpmap, Bs.normalmap, Bs.displacementmap, Bs.fog, Bs.lights, {
                                emissive: {
                                    value: new A(0)
                                },
                                specular: {
                                    value: new A(1118481)
                                },
                                shininess: {
                                    value: 30
                                }
                            }]),
                            vertexShader: Is.meshphong_vert,
                            fragmentShader: Is.meshphong_frag
                        },
                        standard: {
                            uniforms: tt([Bs.common, Bs.envmap, Bs.aomap, Bs.lightmap, Bs.emissivemap, Bs.bumpmap, Bs.normalmap, Bs.displacementmap, Bs.roughnessmap, Bs.metalnessmap, Bs.fog, Bs.lights, {
                                emissive: {
                                    value: new A(0)
                                },
                                roughness: {
                                    value: .5
                                },
                                metalness: {
                                    value: .5
                                },
                                envMapIntensity: {
                                    value: 1
                                }
                            }]),
                            vertexShader: Is.meshphysical_vert,
                            fragmentShader: Is.meshphysical_frag
                        },
                        toon: {
                            uniforms: tt([Bs.common, Bs.specularmap, Bs.aomap, Bs.lightmap, Bs.emissivemap, Bs.bumpmap, Bs.normalmap, Bs.displacementmap, Bs.gradientmap, Bs.fog, Bs.lights, {
                                emissive: {
                                    value: new A(0)
                                },
                                specular: {
                                    value: new A(1118481)
                                },
                                shininess: {
                                    value: 30
                                }
                            }]),
                            vertexShader: Is.meshtoon_vert,
                            fragmentShader: Is.meshtoon_frag
                        },
                        matcap: {
                            uniforms: tt([Bs.common, Bs.bumpmap, Bs.normalmap, Bs.displacementmap, Bs.fog, {
                                matcap: {
                                    value: null
                                }
                            }]),
                            vertexShader: Is.meshmatcap_vert,
                            fragmentShader: Is.meshmatcap_frag
                        },
                        points: {
                            uniforms: tt([Bs.points, Bs.fog]),
                            vertexShader: Is.points_vert,
                            fragmentShader: Is.points_frag
                        },
                        dashed: {
                            uniforms: tt([Bs.common, Bs.fog, {
                                scale: {
                                    value: 1
                                },
                                dashSize: {
                                    value: 1
                                },
                                totalSize: {
                                    value: 2
                                }
                            }]),
                            vertexShader: Is.linedashed_vert,
                            fragmentShader: Is.linedashed_frag
                        },
                        depth: {
                            uniforms: tt([Bs.common, Bs.displacementmap]),
                            vertexShader: Is.depth_vert,
                            fragmentShader: Is.depth_frag
                        },
                        normal: {
                            uniforms: tt([Bs.common, Bs.bumpmap, Bs.normalmap, Bs.displacementmap, {
                                opacity: {
                                    value: 1
                                }
                            }]),
                            vertexShader: Is.normal_vert,
                            fragmentShader: Is.normal_frag
                        },
                        sprite: {
                            uniforms: tt([Bs.sprite, Bs.fog]),
                            vertexShader: Is.sprite_vert,
                            fragmentShader: Is.sprite_frag
                        },
                        background: {
                            uniforms: {
                                uvTransform: {
                                    value: new c
                                },
                                t2D: {
                                    value: null
                                }
                            },
                            vertexShader: Is.background_vert,
                            fragmentShader: Is.background_frag
                        },
                        cube: {
                            uniforms: tt([Bs.envmap, {
                                opacity: {
                                    value: 1
                                }
                            }]),
                            vertexShader: Is.cube_vert,
                            fragmentShader: Is.cube_frag
                        },
                        equirect: {
                            uniforms: {
                                tEquirect: {
                                    value: null
                                }
                            },
                            vertexShader: Is.equirect_vert,
                            fragmentShader: Is.equirect_frag
                        },
                        distanceRGBA: {
                            uniforms: tt([Bs.common, Bs.displacementmap, {
                                referencePosition: {
                                    value: new o
                                },
                                nearDistance: {
                                    value: 1
                                },
                                farDistance: {
                                    value: 1e3
                                }
                            }]),
                            vertexShader: Is.distanceRGBA_vert,
                            fragmentShader: Is.distanceRGBA_frag
                        },
                        shadow: {
                            uniforms: tt([Bs.lights, Bs.fog, {
                                color: {
                                    value: new A(0)
                                },
                                opacity: {
                                    value: 1
                                }
                            }]),
                            vertexShader: Is.shadow_vert,
                            fragmentShader: Is.shadow_frag
                        }
                    };
                ks.physical = {
                    uniforms: tt([ks.standard.uniforms, {
                        transparency: {
                            value: 0
                        },
                        clearcoat: {
                            value: 0
                        },
                        clearcoatRoughness: {
                            value: 0
                        },
                        sheen: {
                            value: new A(0)
                        },
                        clearcoatNormalScale: {
                            value: new n(1, 1)
                        },
                        clearcoatNormalMap: {
                            value: null
                        }
                    }]),
                    vertexShader: Is.meshphysical_vert,
                    fragmentShader: Is.meshphysical_frag
                }, ht.prototype = Object.create(Q.prototype), ht.prototype.constructor = ht, pt.prototype = Object.create(X.prototype), pt.prototype.constructor = pt, Tt.prototype = Object.create(l.prototype), Tt.prototype.constructor = Tt, Tt.prototype.isCubeTexture = !0, Object.defineProperty(Tt.prototype, "images", {
                    get: function () {
                        return this.image
                    },
                    set: function (a) {
                        this.image = a
                    }
                }), Dt.prototype = Object.create(l.prototype), Dt.prototype.constructor = Dt, Dt.prototype.isDataTexture2DArray = !0, St.prototype = Object.create(l.prototype), St.prototype.constructor = St, St.prototype.isDataTexture3D = !0;
                var zs = new l,
                    Us = new Dt,
                    Hs = new St,
                    Gs = new Tt,
                    Vs = [],
                    js = [],
                    Ws = new Float32Array(16),
                    Ys = new Float32Array(9),
                    qs = new Float32Array(4);
                se.prototype.updateCache = function (a) {
                    var b = this.cache;
                    a instanceof Float32Array && b.length !== a.length && (this.cache = new Float32Array(a.length)), Lt(b, a)
                }, ue.prototype.setValue = function (a, b, t) {
                    for (var e = this.seq, n = 0, r = e.length; n !== r; ++n) {
                        var g = e[n];
                        g.setValue(a, b[g.id], t)
                    }
                };
                var Xs = /([\w\d_]+)(\])?(\[|\.)?/g;
                ce.prototype.setValue = function (a, b, t, e) {
                    void 0 !== (b = this.map[b]) && b.setValue(a, t, e)
                }, ce.prototype.setOptional = function (a, b, t) {
                    void 0 !== (b = b[t]) && this.setValue(a, t, b)
                }, ce.upload = function (a, b, t, e) {
                    for (var n = 0, r = b.length; n !== r; ++n) {
                        var g = b[n],
                            o = t[g.id];
                        !1 !== o.needsUpdate && g.setValue(a, o.value, e)
                    }
                }, ce.seqWithValue = function (a, b) {
                    for (var t = [], e = 0, n = a.length; e !== n; ++e) {
                        var r = a[e];
                        r.id in b && t.push(r)
                    }
                    return t
                };
                var Zs = 0,
                    Js = /^[ \t]*#include +<([\w\d./]+)>/gm,
                    $s = /#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
                    Qs = 0;
                Fe.prototype = Object.create(O.prototype), Fe.prototype.constructor = Fe, Fe.prototype.isMeshDepthMaterial = !0, Fe.prototype.copy = function (a) {
                    return O.prototype.copy.call(this, a), this.depthPacking = a.depthPacking, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.map = a.map, this.alphaMap = a.alphaMap, this.displacementMap = a.displacementMap, this.displacementScale = a.displacementScale, this.displacementBias = a.displacementBias, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this
                }, Ne.prototype = Object.create(O.prototype), Ne.prototype.constructor = Ne, Ne.prototype.isMeshDistanceMaterial = !0, Ne.prototype.copy = function (a) {
                    return O.prototype.copy.call(this, a), this.referencePosition.copy(a.referencePosition), this.nearDistance = a.nearDistance, this.farDistance = a.farDistance, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.map = a.map, this.alphaMap = a.alphaMap, this.displacementMap = a.displacementMap, this.displacementScale = a.displacementScale, this.displacementBias = a.displacementBias, this
                }, Ue.prototype = Object.assign(Object.create(d.prototype), {
                    constructor: Ue,
                    isWebGLMultiviewRenderTarget: !0,
                    copy: function (a) {
                        return d.prototype.copy.call(this, a), this.numViews = a.numViews, this
                    },
                    setNumViews: function (a) {
                        return this.numViews !== a && (this.numViews = a, this.dispose()), this
                    }
                }), Ge.prototype = Object.assign(Object.create(it.prototype), {
                    constructor: Ge,
                    isArrayCamera: !0
                }), Ve.prototype = Object.assign(Object.create(_.prototype), {
                    constructor: Ve,
                    isGroup: !0
                }), Object.assign(je.prototype, e.prototype), Object.assign(Ye.prototype, {
                    isFogExp2: !0,
                    clone: function () {
                        return new Ye(this.color, this.density)
                    },
                    toJSON: function () {
                        return {
                            type: "FogExp2",
                            color: this.color.getHex(),
                            density: this.density
                        }
                    }
                }), Object.assign(qe.prototype, {
                    isFog: !0,
                    clone: function () {
                        return new qe(this.color, this.near, this.far)
                    },
                    toJSON: function () {
                        return {
                            type: "Fog",
                            color: this.color.getHex(),
                            near: this.near,
                            far: this.far
                        }
                    }
                }), Object.defineProperty(Xe.prototype, "needsUpdate", {
                    set: function (a) {
                        !0 === a && this.version++
                    }
                }), Object.assign(Xe.prototype, {
                    isInterleavedBuffer: !0,
                    onUploadCallback: function () {},
                    setUsage: function (a) {
                        return this.usage = a, this
                    },
                    copy: function (a) {
                        return this.array = new a.array.constructor(a.array), this.count = a.count, this.stride = a.stride, this.usage = a.usage, this
                    },
                    copyAt: function (a, b, t) {
                        a *= this.stride, t *= b.stride;
                        for (var e = 0, n = this.stride; e < n; e++) this.array[a + e] = b.array[t + e];
                        return this
                    },
                    set: function (a, b) {
                        return void 0 === b && (b = 0), this.array.set(a, b), this
                    },
                    clone: function () {
                        return (new this.constructor).copy(this)
                    },
                    onUpload: function (a) {
                        return this.onUploadCallback = a, this
                    }
                });
                var Ks = new o;
                Object.defineProperties(Ze.prototype, {
                    count: {
                        get: function () {
                            return this.data.count
                        }
                    },
                    array: {
                        get: function () {
                            return this.data.array
                        }
                    }
                }), Object.assign(Ze.prototype, {
                    isInterleavedBufferAttribute: !0,
                    applyMatrix4: function (a) {
                        for (var b = 0, t = this.data.count; b < t; b++) Ks.x = this.getX(b), Ks.y = this.getY(b), Ks.z = this.getZ(b), Ks.applyMatrix4(a), this.setXYZ(b, Ks.x, Ks.y, Ks.z);
                        return this
                    },
                    setX: function (a, b) {
                        return this.data.array[a * this.data.stride + this.offset] = b, this
                    },
                    setY: function (a, b) {
                        return this.data.array[a * this.data.stride + this.offset + 1] = b, this
                    },
                    setZ: function (a, b) {
                        return this.data.array[a * this.data.stride + this.offset + 2] = b, this
                    },
                    setW: function (a, b) {
                        return this.data.array[a * this.data.stride + this.offset + 3] = b, this
                    },
                    getX: function (a) {
                        return this.data.array[a * this.data.stride + this.offset]
                    },
                    getY: function (a) {
                        return this.data.array[a * this.data.stride + this.offset + 1]
                    },
                    getZ: function (a) {
                        return this.data.array[a * this.data.stride + this.offset + 2]
                    },
                    getW: function (a) {
                        return this.data.array[a * this.data.stride + this.offset + 3]
                    },
                    setXY: function (a, b, t) {
                        return a = a * this.data.stride + this.offset, this.data.array[a + 0] = b, this.data.array[a + 1] = t, this
                    },
                    setXYZ: function (a, b, t, e) {
                        return a = a * this.data.stride + this.offset, this.data.array[a + 0] = b, this.data.array[a + 1] = t, this.data.array[a + 2] = e, this
                    },
                    setXYZW: function (a, b, t, e, n) {
                        return a = a * this.data.stride + this.offset, this.data.array[a + 0] = b, this.data.array[a + 1] = t, this.data.array[a + 2] = e, this.data.array[a + 3] = n, this
                    }
                }), Je.prototype = Object.create(O.prototype), Je.prototype.constructor = Je, Je.prototype.isSpriteMaterial = !0, Je.prototype.copy = function (a) {
                    return O.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, this.alphaMap = a.alphaMap, this.rotation = a.rotation, this.sizeAttenuation = a.sizeAttenuation, this
                };
                var tu, eu = new o,
                    nu = new o,
                    iu = new o,
                    ru = new n,
                    au = new n,
                    ou = new m,
                    su = new o,
                    uu = new o,
                    cu = new o,
                    lu = new n,
                    hu = new n,
                    du = new n;
                $e.prototype = Object.assign(Object.create(_.prototype), {
                    constructor: $e,
                    isSprite: !0,
                    raycast: function (a, b) {
                        null === a.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), nu.setFromMatrixScale(this.matrixWorld), ou.copy(a.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(a.camera.matrixWorldInverse, this.matrixWorld), iu.setFromMatrixPosition(this.modelViewMatrix), a.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && nu.multiplyScalar(-iu.z);
                        var t = this.material.rotation;
                        if (0 !== t) var e = Math.cos(t),
                            r = Math.sin(t);
                        t = this.center, Qe(su.set(-.5, -.5, 0), iu, t, nu, r, e), Qe(uu.set(.5, -.5, 0), iu, t, nu, r, e), Qe(cu.set(.5, .5, 0), iu, t, nu, r, e), lu.set(0, 0), hu.set(1, 0), du.set(1, 1);
                        var o = a.ray.intersectTriangle(su, uu, cu, !1, eu);
                        null === o && (Qe(uu.set(-.5, .5, 0), iu, t, nu, r, e), hu.set(0, 1), null === (o = a.ray.intersectTriangle(su, cu, uu, !1, eu))) || (r = a.ray.origin.distanceTo(eu)) < a.near || r > a.far || b.push({
                            distance: r,
                            point: eu.clone(),
                            uv: S.getUV(eu, su, uu, cu, lu, hu, du, new n),
                            face: null,
                            object: this
                        })
                    },
                    clone: function () {
                        return new this.constructor(this.material).copy(this)
                    },
                    copy: function (a) {
                        return _.prototype.copy.call(this, a), void 0 !== a.center && this.center.copy(a.center), this
                    }
                });
                var pu = new o,
                    fu = new o;
                Ke.prototype = Object.assign(Object.create(_.prototype), {
                    constructor: Ke,
                    isLOD: !0,
                    copy: function (a) {
                        _.prototype.copy.call(this, a, !1);
                        for (var b = a.levels, t = 0, e = b.length; t < e; t++) {
                            var n = b[t];
                            this.addLevel(n.object.clone(), n.distance)
                        }
                        return this.autoUpdate = a.autoUpdate, this
                    },
                    addLevel: function (a, b) {
                        void 0 === b && (b = 0), b = Math.abs(b);
                        for (var t = this.levels, e = 0; e < t.length && !(b < t[e].distance); e++);
                        return t.splice(e, 0, {
                            distance: b,
                            object: a
                        }), this.add(a), this
                    },
                    getObjectForDistance: function (a) {
                        var b = this.levels;
                        if (0 < b.length) {
                            for (var t = 1, e = b.length; t < e && !(a < b[t].distance); t++);
                            return b[t - 1].object
                        }
                        return null
                    },
                    raycast: function (a, b) {
                        if (0 < this.levels.length) {
                            pu.setFromMatrixPosition(this.matrixWorld);
                            var t = a.ray.origin.distanceTo(pu);
                            this.getObjectForDistance(t).raycast(a, b)
                        }
                    },
                    update: function (a) {
                        var b = this.levels;
                        if (1 < b.length) {
                            pu.setFromMatrixPosition(a.matrixWorld), fu.setFromMatrixPosition(this.matrixWorld), a = pu.distanceTo(fu), b[0].object.visible = !0;
                            for (var t = 1, e = b.length; t < e && a >= b[t].distance; t++) b[t - 1].object.visible = !1, b[t].object.visible = !0;
                            for (; t < e; t++) b[t].object.visible = !1
                        }
                    },
                    toJSON: function (a) {
                        a = _.prototype.toJSON.call(this, a), !1 === this.autoUpdate && (a.object.autoUpdate = !1), a.object.levels = [];
                        for (var b = this.levels, t = 0, e = b.length; t < e; t++) {
                            var n = b[t];
                            a.object.levels.push({
                                object: n.object.uuid,
                                distance: n.distance
                            })
                        }
                        return a
                    }
                }), tn.prototype = Object.assign(Object.create(Z.prototype), {
                    constructor: tn,
                    isSkinnedMesh: !0,
                    bind: function (a, b) {
                        this.skeleton = a, void 0 === b && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), b = this.matrixWorld), this.bindMatrix.copy(b), this.bindMatrixInverse.getInverse(b)
                    },
                    pose: function () {
                        this.skeleton.pose()
                    },
                    normalizeSkinWeights: function () {
                        for (var a = new h, b = this.geometry.attributes.skinWeight, t = 0, e = b.count; t < e; t++) {
                            a.x = b.getX(t), a.y = b.getY(t), a.z = b.getZ(t), a.w = b.getW(t);
                            var n = 1 / a.manhattanLength();
                            1 / 0 !== n ? a.multiplyScalar(n) : a.set(1, 0, 0, 0), b.setXYZW(t, a.x, a.y, a.z, a.w)
                        }
                    },
                    updateMatrixWorld: function (a) {
                        Z.prototype.updateMatrixWorld.call(this, a), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                    },
                    clone: function () {
                        return new this.constructor(this.geometry, this.material).copy(this)
                    }
                });
                var mu = new m,
                    gu = new m;
                Object.assign(en.prototype, {
                    calculateInverses: function () {
                        this.boneInverses = [];
                        for (var a = 0, b = this.bones.length; a < b; a++) {
                            var t = new m;
                            this.bones[a] && t.getInverse(this.bones[a].matrixWorld), this.boneInverses.push(t)
                        }
                    },
                    pose: function () {
                        var a, b, t = 0;
                        for (b = this.bones.length; t < b; t++)(a = this.bones[t]) && a.matrixWorld.getInverse(this.boneInverses[t]);
                        for (t = 0, b = this.bones.length; t < b; t++)(a = this.bones[t]) && (a.parent && a.parent.isBone ? (a.matrix.getInverse(a.parent.matrixWorld), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale))
                    },
                    update: function () {
                        for (var a = this.bones, b = this.boneInverses, t = this.boneMatrices, e = this.boneTexture, n = 0, r = a.length; n < r; n++) mu.multiplyMatrices(a[n] ? a[n].matrixWorld : gu, b[n]), mu.toArray(t, 16 * n);
                        void 0 !== e && (e.needsUpdate = !0)
                    },
                    clone: function () {
                        return new en(this.bones, this.boneInverses)
                    },
                    getBoneByName: function (a) {
                        for (var b = 0, t = this.bones.length; b < t; b++) {
                            var e = this.bones[b];
                            if (e.name === a) return e
                        }
                    }
                }), nn.prototype = Object.assign(Object.create(_.prototype), {
                    constructor: nn,
                    isBone: !0
                });
                var vu = new m,
                    yu = new m,
                    _u = [],
                    xu = new Z;
                rn.prototype = Object.assign(Object.create(Z.prototype), {
                    constructor: rn,
                    isInstancedMesh: !0,
                    getMatrixAt: function (a, b) {
                        b.fromArray(this.instanceMatrix.array, 16 * a)
                    },
                    raycast: function (a, b) {
                        var t = this.matrixWorld,
                            e = this.count;
                        if (xu.geometry = this.geometry, xu.material = this.material, void 0 !== xu.material)
                            for (var n = 0; n < e; n++) this.getMatrixAt(n, vu), yu.multiplyMatrices(t, vu), xu.matrixWorld = yu, xu.raycast(a, _u), 0 < _u.length && (_u[0].instanceId = n, _u[0].object = this, b.push(_u[0]), _u.length = 0)
                    },
                    setMatrixAt: function (a, b) {
                        b.toArray(this.instanceMatrix.array, 16 * a)
                    },
                    updateMorphTargets: function () {}
                }), an.prototype = Object.create(O.prototype), an.prototype.constructor = an, an.prototype.isLineBasicMaterial = !0, an.prototype.copy = function (a) {
                    return O.prototype.copy.call(this, a), this.color.copy(a.color), this.linewidth = a.linewidth, this.linecap = a.linecap, this.linejoin = a.linejoin, this
                };
                var bu = new o,
                    wu = new o,
                    Mu = new m,
                    Eu = new T,
                    Tu = new E;
                on.prototype = Object.assign(Object.create(_.prototype), {
                    constructor: on,
                    isLine: !0,
                    computeLineDistances: function () {
                        var a = this.geometry;
                        if (a.isBufferGeometry)
                            if (null === a.index) {
                                for (var b = a.attributes.position, t = [0], e = 1, n = b.count; e < n; e++) bu.fromBufferAttribute(b, e - 1), wu.fromBufferAttribute(b, e), t[e] = t[e - 1], t[e] += bu.distanceTo(wu);
                                a.setAttribute("lineDistance", new V(t, 1))
                            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else if (a.isGeometry)
                            for (b = a.vertices, (t = a.lineDistances)[0] = 0, e = 1, n = b.length; e < n; e++) t[e] = t[e - 1], t[e] += b[e - 1].distanceTo(b[e]);
                        return this
                    },
                    raycast: function (a, b) {
                        var t = a.linePrecision,
                            e = this.geometry,
                            n = this.matrixWorld;
                        if (null === e.boundingSphere && e.computeBoundingSphere(), Tu.copy(e.boundingSphere), Tu.applyMatrix4(n), Tu.radius += t, !1 !== a.ray.intersectsSphere(Tu)) {
                            Mu.getInverse(n), Eu.copy(a.ray).applyMatrix4(Mu), t /= (this.scale.x + this.scale.y + this.scale.z) / 3, t *= t;
                            var r = new o,
                                g = new o;
                            n = new o;
                            var c = new o,
                                l = this && this.isLineSegments ? 2 : 1;
                            if (e.isBufferGeometry) {
                                var h = e.index,
                                    d = e.attributes.position.array;
                                if (null !== h) {
                                    e = 0;
                                    for (var p = (h = h.array).length - 1; e < p; e += l) {
                                        var q = h[e + 1];
                                        r.fromArray(d, 3 * h[e]), g.fromArray(d, 3 * q), (q = Eu.distanceSqToSegment(r, g, c, n)) > t || (c.applyMatrix4(this.matrixWorld), (q = a.ray.origin.distanceTo(c)) < a.near || q > a.far || b.push({
                                            distance: q,
                                            point: n.clone().applyMatrix4(this.matrixWorld),
                                            index: e,
                                            face: null,
                                            faceIndex: null,
                                            object: this
                                        }))
                                    }
                                } else
                                    for (e = 0, p = d.length / 3 - 1; e < p; e += l) r.fromArray(d, 3 * e), g.fromArray(d, 3 * e + 3), (q = Eu.distanceSqToSegment(r, g, c, n)) > t || (c.applyMatrix4(this.matrixWorld), (q = a.ray.origin.distanceTo(c)) < a.near || q > a.far || b.push({
                                        distance: q,
                                        point: n.clone().applyMatrix4(this.matrixWorld),
                                        index: e,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    }))
                            } else if (e.isGeometry)
                                for (g = (r = e.vertices).length, e = 0; e < g - 1; e += l)(q = Eu.distanceSqToSegment(r[e], r[e + 1], c, n)) > t || (c.applyMatrix4(this.matrixWorld), (q = a.ray.origin.distanceTo(c)) < a.near || q > a.far || b.push({
                                    distance: q,
                                    point: n.clone().applyMatrix4(this.matrixWorld),
                                    index: e,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                }))
                        }
                    },
                    clone: function () {
                        return new this.constructor(this.geometry, this.material).copy(this)
                    }
                });
                var Du = new o,
                    Su = new o;
                sn.prototype = Object.assign(Object.create(on.prototype), {
                    constructor: sn,
                    isLineSegments: !0,
                    computeLineDistances: function () {
                        var a = this.geometry;
                        if (a.isBufferGeometry)
                            if (null === a.index) {
                                for (var b = a.attributes.position, t = [], e = 0, n = b.count; e < n; e += 2) Du.fromBufferAttribute(b, e), Su.fromBufferAttribute(b, e + 1), t[e] = 0 === e ? 0 : t[e - 1], t[e + 1] = t[e] + Du.distanceTo(Su);
                                a.setAttribute("lineDistance", new V(t, 1))
                            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else if (a.isGeometry)
                            for (b = a.vertices, t = a.lineDistances, e = 0, n = b.length; e < n; e += 2) Du.copy(b[e]), Su.copy(b[e + 1]), t[e] = 0 === e ? 0 : t[e - 1], t[e + 1] = t[e] + Du.distanceTo(Su);
                        return this
                    }
                }), un.prototype = Object.assign(Object.create(on.prototype), {
                    constructor: un,
                    isLineLoop: !0
                }), cn.prototype = Object.create(O.prototype), cn.prototype.constructor = cn, cn.prototype.isPointsMaterial = !0, cn.prototype.copy = function (a) {
                    return O.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, this.alphaMap = a.alphaMap, this.size = a.size, this.sizeAttenuation = a.sizeAttenuation, this.morphTargets = a.morphTargets, this
                };
                var Au = new m,
                    Cu = new T,
                    Lu = new E,
                    Ru = new o;
                ln.prototype = Object.assign(Object.create(_.prototype), {
                    constructor: ln,
                    isPoints: !0,
                    raycast: function (a, b) {
                        var t = this.geometry,
                            e = this.matrixWorld,
                            n = a.params.Points.threshold;
                        if (null === t.boundingSphere && t.computeBoundingSphere(), Lu.copy(t.boundingSphere), Lu.applyMatrix4(e), Lu.radius += n, !1 !== a.ray.intersectsSphere(Lu))
                            if (Au.getInverse(e), Cu.copy(a.ray).applyMatrix4(Au), n /= (this.scale.x + this.scale.y + this.scale.z) / 3, n *= n, t.isBufferGeometry) {
                                var r = t.index;
                                if (t = t.attributes.position.array, null !== r) {
                                    var g = r.array;
                                    r = 0;
                                    for (var o = g.length; r < o; r++) {
                                        var c = g[r];
                                        Ru.fromArray(t, 3 * c), hn(Ru, c, n, e, a, b, this)
                                    }
                                } else
                                    for (r = 0, g = t.length / 3; r < g; r++) Ru.fromArray(t, 3 * r), hn(Ru, r, n, e, a, b, this)
                            } else
                                for (r = 0, g = (t = t.vertices).length; r < g; r++) hn(t[r], r, n, e, a, b, this)
                    },
                    updateMorphTargets: function () {
                        var a = this.geometry;
                        if (a.isBufferGeometry) {
                            a = a.morphAttributes;
                            var b = Object.keys(a);
                            if (0 < b.length) {
                                var t = a[b[0]];
                                if (void 0 !== t)
                                    for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, a = 0, b = t.length; a < b; a++) {
                                        var e = t[a].name || String(a);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = a
                                    }
                            }
                        } else void 0 !== (a = a.morphTargets) && 0 < a.length && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                    },
                    clone: function () {
                        return new this.constructor(this.geometry, this.material).copy(this)
                    }
                }), dn.prototype = Object.assign(Object.create(l.prototype), {
                    constructor: dn,
                    isVideoTexture: !0,
                    update: function () {
                        var a = this.image;
                        a.readyState >= a.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                    }
                }), pn.prototype = Object.create(l.prototype), pn.prototype.constructor = pn, pn.prototype.isCompressedTexture = !0, fn.prototype = Object.create(l.prototype), fn.prototype.constructor = fn, fn.prototype.isCanvasTexture = !0, mn.prototype = Object.create(l.prototype), mn.prototype.constructor = mn, mn.prototype.isDepthTexture = !0, gn.prototype = Object.create(X.prototype), gn.prototype.constructor = gn, vn.prototype = Object.create(Q.prototype), vn.prototype.constructor = vn, yn.prototype = Object.create(X.prototype), yn.prototype.constructor = yn, _n.prototype = Object.create(Q.prototype), _n.prototype.constructor = _n, xn.prototype = Object.create(X.prototype), xn.prototype.constructor = xn, bn.prototype = Object.create(Q.prototype), bn.prototype.constructor = bn, wn.prototype = Object.create(xn.prototype), wn.prototype.constructor = wn, Mn.prototype = Object.create(Q.prototype), Mn.prototype.constructor = Mn, En.prototype = Object.create(xn.prototype), En.prototype.constructor = En, Tn.prototype = Object.create(Q.prototype), Tn.prototype.constructor = Tn, Dn.prototype = Object.create(xn.prototype), Dn.prototype.constructor = Dn, Sn.prototype = Object.create(Q.prototype), Sn.prototype.constructor = Sn, An.prototype = Object.create(xn.prototype), An.prototype.constructor = An, Cn.prototype = Object.create(Q.prototype), Cn.prototype.constructor = Cn, Ln.prototype = Object.create(X.prototype), Ln.prototype.constructor = Ln, Ln.prototype.toJSON = function () {
                    var a = X.prototype.toJSON.call(this);
                    return a.path = this.parameters.path.toJSON(), a
                }, Rn.prototype = Object.create(Q.prototype), Rn.prototype.constructor = Rn, Pn.prototype = Object.create(X.prototype), Pn.prototype.constructor = Pn, On.prototype = Object.create(Q.prototype), On.prototype.constructor = On, Fn.prototype = Object.create(X.prototype), Fn.prototype.constructor = Fn;
                var Pu = function (a, b, t) {
                        t = t || 2;
                        var e, n = b && b.length,
                            r = n ? b[0] * t : a.length,
                            o = Nn(a, 0, r, t, !0),
                            g = [];
                        if (!o || o.next === o.prev) return g;
                        if (n) {
                            var c, l = t;
                            n = [];
                            var h = 0;
                            for (c = b.length; h < c; h++) {
                                var p = b[h] * l;
                                (p = Nn(a, p, h < c - 1 ? b[h + 1] * l : a.length, l, !1)) === p.next && (p.steiner = !0), n.push(Hn(p))
                            }
                            for (n.sort(kn), h = 0; h < n.length; h++)(l = zn(b = n[h], l = o)) && In(b = qn(l, b), b.next), o = In(o, o.next)
                        }
                        if (a.length > 80 * t) {
                            var d = e = a[0],
                                f = n = a[1];
                            for (l = t; l < r; l += t)(h = a[l]) < d && (d = h), (b = a[l + 1]) < f && (f = b), h > e && (e = h), b > n && (n = b);
                            e = 0 !== (e = Math.max(e - d, n - f)) ? 1 / e : 0
                        }
                        return function t(a, b, e, n, r, o, g) {
                            if (a) {
                                if (!g && o) {
                                    var c = a,
                                        l = c;
                                    do {
                                        null === l.z && (l.z = Un(l.x, l.y, n, r, o)), l.prevZ = l.prev, l = l.nextZ = l.next
                                    } while (l !== c);
                                    l.prevZ.nextZ = null, l.prevZ = null, c = l;
                                    var h, d, p, q, f = 1;
                                    do {
                                        l = c;
                                        var m = c = null;
                                        for (d = 0; l;) {
                                            d++;
                                            var v = l;
                                            for (h = p = 0; h < f && (p++, v = v.nextZ); h++);
                                            for (q = f; 0 < p || 0 < q && v;) 0 !== p && (0 === q || !v || l.z <= v.z) ? (h = l, l = l.nextZ, p--) : (h = v, v = v.nextZ, q--), m ? m.nextZ = h : c = h, h.prevZ = m, m = h;
                                            l = v
                                        }
                                        m.nextZ = null, f *= 2
                                    } while (1 < d)
                                }
                                for (c = a; a.prev !== a.next;) {
                                    if (l = a.prev, v = a.next, o) m = Bn(a, n, r, o);
                                    else t: if (m = a, d = m.prev, p = m, f = m.next, 0 <= Vn(d, p, f)) m = !1;
                                        else {
                                            for (h = m.next.next; h !== m.prev;) {
                                                if (Gn(d.x, d.y, p.x, p.y, f.x, f.y, h.x, h.y) && 0 <= Vn(h.prev, h, h.next)) {
                                                    m = !1;
                                                    break t
                                                }
                                                h = h.next
                                            }
                                            m = !0
                                        } if (m) b.push(l.i / e), b.push(a.i / e), b.push(v.i / e), Zn(a), c = a = v.next;
                                    else if ((a = v) === c) {
                                        if (g) {
                                            if (1 === g) {
                                                g = b, c = e, l = a;
                                                do {
                                                    !jn(v = l.prev, m = l.next.next) && Wn(v, l, l.next, m) && Yn(v, m) && Yn(m, v) && (g.push(v.i / c), g.push(l.i / c), g.push(m.i / c), Zn(l), Zn(l.next), l = a = m), l = l.next
                                                } while (l !== a);
                                                t(a = l, b, e, n, r, o, 2)
                                            } else if (2 === g) t: {
                                                g = a;do {
                                                    for (c = g.next.next; c !== g.prev;) {
                                                        if (l = g.i !== c.i) {
                                                            if (v = c, m = (l = g).next.i !== v.i && l.prev.i !== v.i) {
                                                                e: {
                                                                    m = l;do {
                                                                        if (m.i !== l.i && m.next.i !== l.i && m.i !== v.i && m.next.i !== v.i && Wn(m, m.next, l, v)) {
                                                                            m = !0;
                                                                            break e
                                                                        }
                                                                        m = m.next
                                                                    } while (m !== l);m = !1
                                                                }
                                                                m = !m
                                                            }
                                                            if (m = m && Yn(l, v) && Yn(v, l)) {
                                                                m = l, d = !1, p = (l.x + v.x) / 2, v = (l.y + v.y) / 2;
                                                                do {
                                                                    m.y > v != m.next.y > v && m.next.y !== m.y && p < (m.next.x - m.x) * (v - m.y) / (m.next.y - m.y) + m.x && (d = !d), m = m.next
                                                                } while (m !== l);
                                                                m = d
                                                            }
                                                            l = m
                                                        }
                                                        if (l) {
                                                            a = qn(g, c), g = In(g, g.next), a = In(a, a.next), t(g, b, e, n, r, o), t(a, b, e, n, r, o);
                                                            break t
                                                        }
                                                        c = c.next
                                                    }
                                                    g = g.next
                                                } while (g !== a)
                                            }
                                        } else t(In(a), b, e, n, r, o, 1);
                                        break
                                    }
                                }
                            }
                        }(o, g, t, d, f, e), g
                    },
                    Ou = {
                        area: function (a) {
                            for (var b = a.length, t = 0, e = b - 1, n = 0; n < b; e = n++) t += a[e].x * a[n].y - a[n].x * a[e].y;
                            return .5 * t
                        },
                        isClockWise: function (a) {
                            return 0 > Ou.area(a)
                        },
                        triangulateShape: function (a, b) {
                            var t = [],
                                e = [],
                                n = [];
                            $n(a), Qn(t, a);
                            var r = a.length;
                            for (b.forEach($n), a = 0; a < b.length; a++) e.push(r), r += b[a].length, Qn(t, b[a]);
                            for (b = Pu(t, e), a = 0; a < b.length; a += 3) n.push(b.slice(a, a + 3));
                            return n
                        }
                    };
                Kn.prototype = Object.create(Q.prototype), Kn.prototype.constructor = Kn, Kn.prototype.toJSON = function () {
                    var a = Q.prototype.toJSON.call(this);
                    return ei(this.parameters.shapes, this.parameters.options, a)
                }, ti.prototype = Object.create(X.prototype), ti.prototype.constructor = ti, ti.prototype.toJSON = function () {
                    var a = X.prototype.toJSON.call(this);
                    return ei(this.parameters.shapes, this.parameters.options, a)
                };
                var Fu = {
                    generateTopUV: function (a, b, t, e, r) {
                        a = b[3 * e], e = b[3 * e + 1];
                        var o = b[3 * r];
                        return r = b[3 * r + 1], [new n(b[3 * t], b[3 * t + 1]), new n(a, e), new n(o, r)]
                    },
                    generateSideWallUV: function (a, b, t, e, r, o) {
                        a = b[3 * t];
                        var g = b[3 * t + 1];
                        t = b[3 * t + 2];
                        var c = b[3 * e],
                            l = b[3 * e + 1];
                        e = b[3 * e + 2];
                        var h = b[3 * r],
                            d = b[3 * r + 1];
                        r = b[3 * r + 2];
                        var p = b[3 * o],
                            q = b[3 * o + 1];
                        return b = b[3 * o + 2], .01 > Math.abs(g - l) ? [new n(a, 1 - t), new n(c, 1 - e), new n(h, 1 - r), new n(p, 1 - b)] : [new n(g, 1 - t), new n(l, 1 - e), new n(d, 1 - r), new n(q, 1 - b)]
                    }
                };
                ni.prototype = Object.create(Q.prototype), ni.prototype.constructor = ni, ii.prototype = Object.create(ti.prototype), ii.prototype.constructor = ii, ri.prototype = Object.create(Q.prototype), ri.prototype.constructor = ri, ai.prototype = Object.create(X.prototype), ai.prototype.constructor = ai, oi.prototype = Object.create(Q.prototype), oi.prototype.constructor = oi, si.prototype = Object.create(X.prototype), si.prototype.constructor = si, ui.prototype = Object.create(Q.prototype), ui.prototype.constructor = ui, ci.prototype = Object.create(X.prototype), ci.prototype.constructor = ci, hi.prototype = Object.create(Q.prototype), hi.prototype.constructor = hi, hi.prototype.toJSON = function () {
                    var a = Q.prototype.toJSON.call(this);
                    return pi(this.parameters.shapes, a)
                }, di.prototype = Object.create(X.prototype), di.prototype.constructor = di, di.prototype.toJSON = function () {
                    var a = X.prototype.toJSON.call(this);
                    return pi(this.parameters.shapes, a)
                }, fi.prototype = Object.create(X.prototype), fi.prototype.constructor = fi, mi.prototype = Object.create(Q.prototype), mi.prototype.constructor = mi, gi.prototype = Object.create(X.prototype), gi.prototype.constructor = gi, vi.prototype = Object.create(mi.prototype), vi.prototype.constructor = vi, yi.prototype = Object.create(gi.prototype), yi.prototype.constructor = yi, _i.prototype = Object.create(Q.prototype), _i.prototype.constructor = _i, xi.prototype = Object.create(X.prototype), xi.prototype.constructor = xi;
                var Nu = Object.freeze({
                    __proto__: null,
                    WireframeGeometry: gn,
                    ParametricGeometry: vn,
                    ParametricBufferGeometry: yn,
                    TetrahedronGeometry: bn,
                    TetrahedronBufferGeometry: wn,
                    OctahedronGeometry: Mn,
                    OctahedronBufferGeometry: En,
                    IcosahedronGeometry: Tn,
                    IcosahedronBufferGeometry: Dn,
                    DodecahedronGeometry: Sn,
                    DodecahedronBufferGeometry: An,
                    PolyhedronGeometry: _n,
                    PolyhedronBufferGeometry: xn,
                    TubeGeometry: Cn,
                    TubeBufferGeometry: Ln,
                    TorusKnotGeometry: Rn,
                    TorusKnotBufferGeometry: Pn,
                    TorusGeometry: On,
                    TorusBufferGeometry: Fn,
                    TextGeometry: ni,
                    TextBufferGeometry: ii,
                    SphereGeometry: ri,
                    SphereBufferGeometry: ai,
                    RingGeometry: oi,
                    RingBufferGeometry: si,
                    PlaneGeometry: ht,
                    PlaneBufferGeometry: pt,
                    LatheGeometry: ui,
                    LatheBufferGeometry: ci,
                    ShapeGeometry: hi,
                    ShapeBufferGeometry: di,
                    ExtrudeGeometry: Kn,
                    ExtrudeBufferGeometry: ti,
                    EdgesGeometry: fi,
                    ConeGeometry: vi,
                    ConeBufferGeometry: yi,
                    CylinderGeometry: mi,
                    CylinderBufferGeometry: gi,
                    CircleGeometry: _i,
                    CircleBufferGeometry: xi,
                    BoxGeometry: Rs,
                    BoxBufferGeometry: Ps
                });
                bi.prototype = Object.create(O.prototype), bi.prototype.constructor = bi, bi.prototype.isShadowMaterial = !0, bi.prototype.copy = function (a) {
                    return O.prototype.copy.call(this, a), this.color.copy(a.color), this
                }, wi.prototype = Object.create(et.prototype), wi.prototype.constructor = wi, wi.prototype.isRawShaderMaterial = !0, Mi.prototype = Object.create(O.prototype), Mi.prototype.constructor = Mi, Mi.prototype.isMeshStandardMaterial = !0, Mi.prototype.copy = function (a) {
                    return O.prototype.copy.call(this, a), this.defines = {
                        STANDARD: ""
                    }, this.color.copy(a.color), this.roughness = a.roughness, this.metalness = a.metalness, this.map = a.map, this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.emissive.copy(a.emissive), this.emissiveMap = a.emissiveMap, this.emissiveIntensity = a.emissiveIntensity, this.bumpMap = a.bumpMap, this.bumpScale = a.bumpScale, this.normalMap = a.normalMap, this.normalMapType = a.normalMapType, this.normalScale.copy(a.normalScale), this.displacementMap = a.displacementMap, this.displacementScale = a.displacementScale, this.displacementBias = a.displacementBias, this.roughnessMap = a.roughnessMap, this.metalnessMap = a.metalnessMap, this.alphaMap = a.alphaMap, this.envMap = a.envMap, this.envMapIntensity = a.envMapIntensity, this.refractionRatio = a.refractionRatio, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.wireframeLinecap = a.wireframeLinecap, this.wireframeLinejoin = a.wireframeLinejoin, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, this
                }, Ei.prototype = Object.create(Mi.prototype), Ei.prototype.constructor = Ei, Ei.prototype.isMeshPhysicalMaterial = !0, Ei.prototype.copy = function (a) {
                    return Mi.prototype.copy.call(this, a), this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    }, this.reflectivity = a.reflectivity, this.clearcoat = a.clearcoat, this.clearcoatRoughness = a.clearcoatRoughness, this.sheen = a.sheen ? (this.sheen || new A).copy(a.sheen) : null, this.clearcoatNormalMap = a.clearcoatNormalMap, this.clearcoatNormalScale.copy(a.clearcoatNormalScale), this.transparency = a.transparency, this
                }, Ti.prototype = Object.create(O.prototype), Ti.prototype.constructor = Ti, Ti.prototype.isMeshPhongMaterial = !0, Ti.prototype.copy = function (a) {
                    return O.prototype.copy.call(this, a), this.color.copy(a.color), this.specular.copy(a.specular), this.shininess = a.shininess, this.map = a.map, this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.emissive.copy(a.emissive), this.emissiveMap = a.emissiveMap, this.emissiveIntensity = a.emissiveIntensity, this.bumpMap = a.bumpMap, this.bumpScale = a.bumpScale, this.normalMap = a.normalMap, this.normalMapType = a.normalMapType, this.normalScale.copy(a.normalScale), this.displacementMap = a.displacementMap, this.displacementScale = a.displacementScale, this.displacementBias = a.displacementBias, this.specularMap = a.specularMap, this.alphaMap = a.alphaMap, this.envMap = a.envMap, this.combine = a.combine, this.reflectivity = a.reflectivity, this.refractionRatio = a.refractionRatio, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.wireframeLinecap = a.wireframeLinecap, this.wireframeLinejoin = a.wireframeLinejoin, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, this
                }, Di.prototype = Object.create(O.prototype), Di.prototype.constructor = Di, Di.prototype.isMeshToonMaterial = !0, Di.prototype.copy = function (a) {
                    return O.prototype.copy.call(this, a), this.color.copy(a.color), this.specular.copy(a.specular), this.shininess = a.shininess, this.map = a.map, this.gradientMap = a.gradientMap, this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.emissive.copy(a.emissive), this.emissiveMap = a.emissiveMap, this.emissiveIntensity = a.emissiveIntensity, this.bumpMap = a.bumpMap, this.bumpScale = a.bumpScale, this.normalMap = a.normalMap, this.normalMapType = a.normalMapType, this.normalScale.copy(a.normalScale), this.displacementMap = a.displacementMap, this.displacementScale = a.displacementScale, this.displacementBias = a.displacementBias, this.specularMap = a.specularMap, this.alphaMap = a.alphaMap, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.wireframeLinecap = a.wireframeLinecap, this.wireframeLinejoin = a.wireframeLinejoin, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, this
                }, Si.prototype = Object.create(O.prototype), Si.prototype.constructor = Si, Si.prototype.isMeshNormalMaterial = !0, Si.prototype.copy = function (a) {
                    return O.prototype.copy.call(this, a), this.bumpMap = a.bumpMap, this.bumpScale = a.bumpScale, this.normalMap = a.normalMap, this.normalMapType = a.normalMapType, this.normalScale.copy(a.normalScale), this.displacementMap = a.displacementMap, this.displacementScale = a.displacementScale, this.displacementBias = a.displacementBias, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, this
                }, Ai.prototype = Object.create(O.prototype), Ai.prototype.constructor = Ai, Ai.prototype.isMeshLambertMaterial = !0, Ai.prototype.copy = function (a) {
                    return O.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.emissive.copy(a.emissive), this.emissiveMap = a.emissiveMap, this.emissiveIntensity = a.emissiveIntensity, this.specularMap = a.specularMap, this.alphaMap = a.alphaMap, this.envMap = a.envMap, this.combine = a.combine, this.reflectivity = a.reflectivity, this.refractionRatio = a.refractionRatio, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.wireframeLinecap = a.wireframeLinecap, this.wireframeLinejoin = a.wireframeLinejoin, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, this
                }, Ci.prototype = Object.create(O.prototype), Ci.prototype.constructor = Ci, Ci.prototype.isMeshMatcapMaterial = !0, Ci.prototype.copy = function (a) {
                    return O.prototype.copy.call(this, a), this.defines = {
                        MATCAP: ""
                    }, this.color.copy(a.color), this.matcap = a.matcap, this.map = a.map, this.bumpMap = a.bumpMap, this.bumpScale = a.bumpScale, this.normalMap = a.normalMap, this.normalMapType = a.normalMapType, this.normalScale.copy(a.normalScale), this.displacementMap = a.displacementMap, this.displacementScale = a.displacementScale, this.displacementBias = a.displacementBias, this.alphaMap = a.alphaMap, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, this
                }, Li.prototype = Object.create(an.prototype), Li.prototype.constructor = Li, Li.prototype.isLineDashedMaterial = !0, Li.prototype.copy = function (a) {
                    return an.prototype.copy.call(this, a), this.scale = a.scale, this.dashSize = a.dashSize, this.gapSize = a.gapSize, this
                };
                var Iu = Object.freeze({
                        __proto__: null,
                        ShadowMaterial: bi,
                        SpriteMaterial: Je,
                        RawShaderMaterial: wi,
                        ShaderMaterial: et,
                        PointsMaterial: cn,
                        MeshPhysicalMaterial: Ei,
                        MeshStandardMaterial: Mi,
                        MeshPhongMaterial: Ti,
                        MeshToonMaterial: Di,
                        MeshNormalMaterial: Si,
                        MeshLambertMaterial: Ai,
                        MeshDepthMaterial: Fe,
                        MeshDistanceMaterial: Ne,
                        MeshBasicMaterial: F,
                        MeshMatcapMaterial: Ci,
                        LineDashedMaterial: Li,
                        LineBasicMaterial: an,
                        Material: O
                    }),
                    Bu = {
                        arraySlice: function (a, b, t) {
                            return Bu.isTypedArray(a) ? new a.constructor(a.subarray(b, void 0 !== t ? t : a.length)) : a.slice(b, t)
                        },
                        convertArray: function (a, b, t) {
                            return !a || !t && a.constructor === b ? a : "number" == typeof b.BYTES_PER_ELEMENT ? new b(a) : Array.prototype.slice.call(a)
                        },
                        isTypedArray: function (a) {
                            return ArrayBuffer.isView(a) && !(a instanceof DataView)
                        },
                        getKeyframeOrder: function (a) {
                            for (var b = a.length, t = Array(b), e = 0; e !== b; ++e) t[e] = e;
                            return t.sort((function (b, t) {
                                return a[b] - a[t]
                            })), t
                        },
                        sortedArray: function (a, b, t) {
                            for (var e = a.length, n = new a.constructor(e), r = 0, g = 0; g !== e; ++r)
                                for (var o = t[r] * b, c = 0; c !== b; ++c) n[g++] = a[o + c];
                            return n
                        },
                        flattenJSON: function (a, b, t, e) {
                            for (var n = 1, r = a[0]; void 0 !== r && void 0 === r[e];) r = a[n++];
                            if (void 0 !== r) {
                                var g = r[e];
                                if (void 0 !== g)
                                    if (Array.isArray(g))
                                        do {
                                            void 0 !== (g = r[e]) && (b.push(r.time), t.push.apply(t, g)), r = a[n++]
                                        } while (void 0 !== r);
                                    else if (void 0 !== g.toArray)
                                    do {
                                        void 0 !== (g = r[e]) && (b.push(r.time), g.toArray(t, t.length)), r = a[n++]
                                    } while (void 0 !== r);
                                else
                                    do {
                                        void 0 !== (g = r[e]) && (b.push(r.time), t.push(g)), r = a[n++]
                                    } while (void 0 !== r)
                            }
                        },
                        subclip: function (a, b, t, e, n) {
                            n = n || 30, (a = a.clone()).name = b;
                            var r = [];
                            for (b = 0; b < a.tracks.length; ++b) {
                                for (var g = a.tracks[b], o = g.getValueSize(), c = [], l = [], h = 0; h < g.times.length; ++h) {
                                    var p = g.times[h] * n;
                                    if (!(p < t || p >= e))
                                        for (c.push(g.times[h]), p = 0; p < o; ++p) l.push(g.values[h * o + p])
                                }
                                0 !== c.length && (g.times = Bu.convertArray(c, g.times.constructor), g.values = Bu.convertArray(l, g.values.constructor), r.push(g))
                            }
                            for (a.tracks = r, t = 1 / 0, b = 0; b < a.tracks.length; ++b) t > a.tracks[b].times[0] && (t = a.tracks[b].times[0]);
                            for (b = 0; b < a.tracks.length; ++b) a.tracks[b].shift(-1 * t);
                            return a.resetDuration(), a
                        }
                    };
                Object.assign(Ri.prototype, {
                    evaluate: function (a) {
                        var b = this.parameterPositions,
                            t = this._cachedIndex,
                            e = b[t],
                            n = b[t - 1];
                        t: {
                            e: {
                                n: {
                                    i: if (!(a < e)) {
                                        for (var r = t + 2;;) {
                                            if (void 0 === e) {
                                                if (a < n) break i;
                                                return this._cachedIndex = t = b.length, this.afterEnd_(t - 1, a, n)
                                            }
                                            if (t === r) break;
                                            if (n = e, a < (e = b[++t])) break e
                                        }
                                        e = b.length;
                                        break n
                                    }if (a >= n) break t;
                                    for (a < (r = b[1]) && (t = 2, n = r), r = t - 2;;) {
                                        if (void 0 === n) return this._cachedIndex = 0, this.beforeStart_(0, a, e);
                                        if (t === r) break;
                                        if (e = n, a >= (n = b[--t - 1])) break e
                                    }
                                    e = t,
                                    t = 0
                                }
                                for (; t < e;) a < b[n = t + e >>> 1] ? e = n : t = n + 1;
                                if (e = b[t], void 0 === (n = b[t - 1])) return this._cachedIndex = 0,
                                this.beforeStart_(0, a, e);
                                if (void 0 === e) return this._cachedIndex = t = b.length,
                                this.afterEnd_(t - 1, n, a)
                            }
                            this._cachedIndex = t,
                            this.intervalChanged_(t, n, e)
                        }
                        return this.interpolate_(t, n, a, e)
                    },
                    settings: null,
                    DefaultSettings_: {},
                    getSettings_: function () {
                        return this.settings || this.DefaultSettings_
                    },
                    copySampleValue_: function (a) {
                        var b = this.resultBuffer,
                            t = this.sampleValues,
                            e = this.valueSize;
                        a *= e;
                        for (var n = 0; n !== e; ++n) b[n] = t[a + n];
                        return b
                    },
                    interpolate_: function () {
                        throw Error("call to abstract method")
                    },
                    intervalChanged_: function () {}
                }), Object.assign(Ri.prototype, {
                    beforeStart_: Ri.prototype.copySampleValue_,
                    afterEnd_: Ri.prototype.copySampleValue_
                }), Pi.prototype = Object.assign(Object.create(Ri.prototype), {
                    constructor: Pi,
                    DefaultSettings_: {
                        endingStart: 2400,
                        endingEnd: 2400
                    },
                    intervalChanged_: function (a, b, t) {
                        var e = this.parameterPositions,
                            n = a - 2,
                            r = a + 1,
                            g = e[n],
                            o = e[r];
                        if (void 0 === g) switch (this.getSettings_().endingStart) {
                            case 2401:
                                n = a, g = 2 * b - t;
                                break;
                            case 2402:
                                g = b + e[n = e.length - 2] - e[n + 1];
                                break;
                            default:
                                n = a, g = t
                        }
                        if (void 0 === o) switch (this.getSettings_().endingEnd) {
                            case 2401:
                                r = a, o = 2 * t - b;
                                break;
                            case 2402:
                                r = 1, o = t + e[1] - e[0];
                                break;
                            default:
                                r = a - 1, o = b
                        }
                        a = .5 * (t - b), e = this.valueSize, this._weightPrev = a / (b - g), this._weightNext = a / (o - t), this._offsetPrev = n * e, this._offsetNext = r * e
                    },
                    interpolate_: function (a, b, t, e) {
                        var n = this.resultBuffer,
                            r = this.sampleValues,
                            g = this.valueSize,
                            o = (a *= g) - g,
                            c = this._offsetPrev,
                            l = this._offsetNext,
                            h = this._weightPrev,
                            p = this._weightNext,
                            q = (t - b) / (e - b);
                        for (b = -h * (e = (t = q * q) * q) + 2 * h * t - h * q, h = (1 + h) * e + (-1.5 - 2 * h) * t + (-.5 + h) * q + 1, q = (-1 - p) * e + (1.5 + p) * t + .5 * q, p = p * e - p * t, t = 0; t !== g; ++t) n[t] = b * r[c + t] + h * r[o + t] + q * r[a + t] + p * r[l + t];
                        return n
                    }
                }), Oi.prototype = Object.assign(Object.create(Ri.prototype), {
                    constructor: Oi,
                    interpolate_: function (a, b, t, e) {
                        var n = this.resultBuffer,
                            r = this.sampleValues,
                            g = this.valueSize,
                            o = (a *= g) - g;
                        for (t = 1 - (b = (t - b) / (e - b)), e = 0; e !== g; ++e) n[e] = r[o + e] * t + r[a + e] * b;
                        return n
                    }
                }), Fi.prototype = Object.assign(Object.create(Ri.prototype), {
                    constructor: Fi,
                    interpolate_: function (a) {
                        return this.copySampleValue_(a - 1)
                    }
                }), Object.assign(Ni, {
                    toJSON: function (a) {
                        var b = a.constructor;
                        if (void 0 !== b.toJSON) b = b.toJSON(a);
                        else {
                            b = {
                                name: a.name,
                                times: Bu.convertArray(a.times, Array),
                                values: Bu.convertArray(a.values, Array)
                            };
                            var t = a.getInterpolation();
                            t !== a.DefaultInterpolation && (b.interpolation = t)
                        }
                        return b.type = a.ValueTypeName, b
                    }
                }), Object.assign(Ni.prototype, {
                    constructor: Ni,
                    TimeBufferType: Float32Array,
                    ValueBufferType: Float32Array,
                    DefaultInterpolation: 2301,
                    InterpolantFactoryMethodDiscrete: function (a) {
                        return new Fi(this.times, this.values, this.getValueSize(), a)
                    },
                    InterpolantFactoryMethodLinear: function (a) {
                        return new Oi(this.times, this.values, this.getValueSize(), a)
                    },
                    InterpolantFactoryMethodSmooth: function (a) {
                        return new Pi(this.times, this.values, this.getValueSize(), a)
                    },
                    setInterpolation: function (a) {
                        switch (a) {
                            case 2300:
                                var b = this.InterpolantFactoryMethodDiscrete;
                                break;
                            case 2301:
                                b = this.InterpolantFactoryMethodLinear;
                                break;
                            case 2302:
                                b = this.InterpolantFactoryMethodSmooth
                        }
                        if (void 0 === b) {
                            if (b = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name, void 0 === this.createInterpolant) {
                                if (a === this.DefaultInterpolation) throw Error(b);
                                this.setInterpolation(this.DefaultInterpolation)
                            }
                            return console.warn("THREE.KeyframeTrack:", b), this
                        }
                        return this.createInterpolant = b, this
                    },
                    getInterpolation: function () {
                        switch (this.createInterpolant) {
                            case this.InterpolantFactoryMethodDiscrete:
                                return 2300;
                            case this.InterpolantFactoryMethodLinear:
                                return 2301;
                            case this.InterpolantFactoryMethodSmooth:
                                return 2302
                        }
                    },
                    getValueSize: function () {
                        return this.values.length / this.times.length
                    },
                    shift: function (a) {
                        if (0 !== a)
                            for (var b = this.times, t = 0, e = b.length; t !== e; ++t) b[t] += a;
                        return this
                    },
                    scale: function (a) {
                        if (1 !== a)
                            for (var b = this.times, t = 0, e = b.length; t !== e; ++t) b[t] *= a;
                        return this
                    },
                    trim: function (a, b) {
                        for (var t = this.times, e = t.length, n = 0, r = e - 1; n !== e && t[n] < a;) ++n;
                        for (; - 1 !== r && t[r] > b;) --r;
                        return ++r, 0 === n && r === e || (n >= r && (n = (r = Math.max(r, 1)) - 1), a = this.getValueSize(), this.times = Bu.arraySlice(t, n, r), this.values = Bu.arraySlice(this.values, n * a, r * a)), this
                    },
                    validate: function () {
                        var a = !0,
                            b = this.getValueSize();
                        0 != b - Math.floor(b) && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), a = !1);
                        var t = this.times;
                        b = this.values;
                        var e = t.length;
                        0 === e && (console.error("THREE.KeyframeTrack: Track is empty.", this), a = !1);
                        for (var n = null, r = 0; r !== e; r++) {
                            var g = t[r];
                            if ("number" == typeof g && isNaN(g)) {
                                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, r, g), a = !1;
                                break
                            }
                            if (null !== n && n > g) {
                                console.error("THREE.KeyframeTrack: Out of order keys.", this, r, g, n), a = !1;
                                break
                            }
                            n = g
                        }
                        if (void 0 !== b && Bu.isTypedArray(b))
                            for (r = 0, t = b.length; r !== t; ++r)
                                if (e = b[r], isNaN(e)) {
                                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, r, e), a = !1;
                                    break
                                } return a
                    },
                    optimize: function () {
                        for (var a = this.times, b = this.values, t = this.getValueSize(), e = 2302 === this.getInterpolation(), n = 1, r = a.length - 1, g = 1; g < r; ++g) {
                            var o = !1,
                                c = a[g];
                            if (c !== a[g + 1] && (1 !== g || c !== c[0]))
                                if (e) o = !0;
                                else {
                                    var l = g * t,
                                        h = l - t,
                                        p = l + t;
                                    for (c = 0; c !== t; ++c) {
                                        var q = b[l + c];
                                        if (q !== b[h + c] || q !== b[p + c]) {
                                            o = !0;
                                            break
                                        }
                                    }
                                } if (o) {
                                if (g !== n)
                                    for (a[n] = a[g], o = g * t, l = n * t, c = 0; c !== t; ++c) b[l + c] = b[o + c];
                                ++n
                            }
                        }
                        if (0 < r) {
                            for (a[n] = a[r], o = r * t, l = n * t, c = 0; c !== t; ++c) b[l + c] = b[o + c];
                            ++n
                        }
                        return n !== a.length && (this.times = Bu.arraySlice(a, 0, n), this.values = Bu.arraySlice(b, 0, n * t)), this
                    },
                    clone: function () {
                        var a = Bu.arraySlice(this.times, 0),
                            b = Bu.arraySlice(this.values, 0);
                        return (a = new this.constructor(this.name, a, b)).createInterpolant = this.createInterpolant, a
                    }
                }), Ii.prototype = Object.assign(Object.create(Ni.prototype), {
                    constructor: Ii,
                    ValueTypeName: "bool",
                    ValueBufferType: Array,
                    DefaultInterpolation: 2300,
                    InterpolantFactoryMethodLinear: void 0,
                    InterpolantFactoryMethodSmooth: void 0
                }), Bi.prototype = Object.assign(Object.create(Ni.prototype), {
                    constructor: Bi,
                    ValueTypeName: "color"
                }), ki.prototype = Object.assign(Object.create(Ni.prototype), {
                    constructor: ki,
                    ValueTypeName: "number"
                }), zi.prototype = Object.assign(Object.create(Ri.prototype), {
                    constructor: zi,
                    interpolate_: function (a, b, t, e) {
                        var n = this.resultBuffer,
                            o = this.sampleValues,
                            g = this.valueSize;
                        for (b = (t - b) / (e - b), t = (a *= g) + g; a !== t; a += 4) r.slerpFlat(n, 0, o, a - g, o, a, b);
                        return n
                    }
                }), Ui.prototype = Object.assign(Object.create(Ni.prototype), {
                    constructor: Ui,
                    ValueTypeName: "quaternion",
                    DefaultInterpolation: 2301,
                    InterpolantFactoryMethodLinear: function (a) {
                        return new zi(this.times, this.values, this.getValueSize(), a)
                    },
                    InterpolantFactoryMethodSmooth: void 0
                }), Hi.prototype = Object.assign(Object.create(Ni.prototype), {
                    constructor: Hi,
                    ValueTypeName: "string",
                    ValueBufferType: Array,
                    DefaultInterpolation: 2300,
                    InterpolantFactoryMethodLinear: void 0,
                    InterpolantFactoryMethodSmooth: void 0
                }), dd.prototype = Object.assign(Object.create(Ni.prototype), {
                    constructor: dd,
                    ValueTypeName: "vector"
                }), Object.assign(Gi, {
                    parse: function (a) {
                        for (var b = [], t = a.tracks, e = 1 / (a.fps || 1), n = 0, r = t.length; n !== r; ++n) b.push(Vi(t[n]).scale(e));
                        return new Gi(a.name, a.duration, b)
                    },
                    toJSON: function (a) {
                        var b = [],
                            t = a.tracks;
                        a = {
                            name: a.name,
                            duration: a.duration,
                            tracks: b,
                            uuid: a.uuid
                        };
                        for (var e = 0, n = t.length; e !== n; ++e) b.push(Ni.toJSON(t[e]));
                        return a
                    },
                    CreateFromMorphTargetSequence: function (a, b, t, e) {
                        for (var n = b.length, r = [], g = 0; g < n; g++) {
                            var o = [],
                                c = [];
                            o.push((g + n - 1) % n, g, (g + 1) % n), c.push(0, 1, 0);
                            var l = Bu.getKeyframeOrder(o);
                            o = Bu.sortedArray(o, 1, l), c = Bu.sortedArray(c, 1, l), e || 0 !== o[0] || (o.push(n), c.push(c[0])), r.push(new ki(".morphTargetInfluences[" + b[g].name + "]", o, c).scale(1 / t))
                        }
                        return new Gi(a, -1, r)
                    },
                    findByName: function (a, b) {
                        var t = a;
                        for (Array.isArray(a) || (t = a.geometry && a.geometry.animations || a.animations), a = 0; a < t.length; a++)
                            if (t[a].name === b) return t[a];
                        return null
                    },
                    CreateClipsFromMorphTargetSequences: function (a, b, t) {
                        for (var e = {}, n = /^([\w-]*?)([\d]+)$/, r = 0, g = a.length; r < g; r++) {
                            var o = a[r],
                                c = o.name.match(n);
                            if (c && 1 < c.length) {
                                var l = c[1];
                                (c = e[l]) || (e[l] = c = []), c.push(o)
                            }
                        }
                        for (l in a = [], e) a.push(Gi.CreateFromMorphTargetSequence(l, e[l], b, t));
                        return a
                    },
                    parseAnimation: function (a, b) {
                        if (!a) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                        var t = function (a, b, t, e, n) {
                                if (0 !== t.length) {
                                    var r = [],
                                        g = [];
                                    Bu.flattenJSON(t, r, g, e), 0 !== r.length && n.push(new a(b, r, g))
                                }
                            },
                            e = [],
                            n = a.name || "default",
                            r = a.length || -1,
                            g = a.fps || 30;
                        a = a.hierarchy || [];
                        for (var o = 0; o < a.length; o++) {
                            var c = a[o].keys;
                            if (c && 0 !== c.length)
                                if (c[0].morphTargets) {
                                    r = {};
                                    for (var l = 0; l < c.length; l++)
                                        if (c[l].morphTargets)
                                            for (var h = 0; h < c[l].morphTargets.length; h++) r[c[l].morphTargets[h]] = -1;
                                    for (var p in r) {
                                        var q = [],
                                            d = [];
                                        for (h = 0; h !== c[l].morphTargets.length; ++h) {
                                            var f = c[l];
                                            q.push(f.time), d.push(f.morphTarget === p ? 1 : 0)
                                        }
                                        e.push(new ki(".morphTargetInfluence[" + p + "]", q, d))
                                    }
                                    r = r.length * (g || 1)
                                } else t(dd, (l = ".bones[" + b[o].name + "]") + ".position", c, "pos", e), t(Ui, l + ".quaternion", c, "rot", e), t(dd, l + ".scale", c, "scl", e)
                        }
                        return 0 === e.length ? null : new Gi(n, r, e)
                    }
                }), Object.assign(Gi.prototype, {
                    resetDuration: function () {
                        for (var a = 0, b = 0, t = this.tracks.length; b !== t; ++b) {
                            var e = this.tracks[b];
                            a = Math.max(a, e.times[e.times.length - 1])
                        }
                        return this.duration = a, this
                    },
                    trim: function () {
                        for (var a = 0; a < this.tracks.length; a++) this.tracks[a].trim(0, this.duration);
                        return this
                    },
                    validate: function () {
                        for (var a = !0, b = 0; b < this.tracks.length; b++) a = a && this.tracks[b].validate();
                        return a
                    },
                    optimize: function () {
                        for (var a = 0; a < this.tracks.length; a++) this.tracks[a].optimize();
                        return this
                    },
                    clone: function () {
                        for (var a = [], b = 0; b < this.tracks.length; b++) a.push(this.tracks[b].clone());
                        return new Gi(this.name, this.duration, a)
                    }
                });
                var ku = {
                        enabled: !1,
                        files: {},
                        add: function (a, b) {
                            !1 !== this.enabled && (this.files[a] = b)
                        },
                        get: function (a) {
                            if (!1 !== this.enabled) return this.files[a]
                        },
                        remove: function (a) {
                            delete this.files[a]
                        },
                        clear: function () {
                            this.files = {}
                        }
                    },
                    zu = new ji;
                Object.assign(Wi.prototype, {
                    load: function () {},
                    parse: function () {},
                    setCrossOrigin: function (a) {
                        return this.crossOrigin = a, this
                    },
                    setPath: function (a) {
                        return this.path = a, this
                    },
                    setResourcePath: function (a) {
                        return this.resourcePath = a, this
                    }
                });
                var Uu = {};
                Yi.prototype = Object.assign(Object.create(Wi.prototype), {
                    constructor: Yi,
                    load: function (a, b, t, e) {
                        void 0 === a && (a = ""), void 0 !== this.path && (a = this.path + a), a = this.manager.resolveURL(a);
                        var n = this,
                            r = ku.get(a);
                        if (void 0 !== r) return n.manager.itemStart(a), setTimeout((function () {
                            b && b(r), n.manager.itemEnd(a)
                        }), 0), r;
                        if (void 0 === Uu[a]) {
                            var g = a.match(/^data:(.*?)(;base64)?,(.*)$/);
                            if (g) {
                                t = g[1];
                                var o = !!g[2];
                                g = g[3], g = decodeURIComponent(g), o && (g = atob(g));
                                try {
                                    var c = (this.responseType || "").toLowerCase();
                                    switch (c) {
                                        case "arraybuffer":
                                        case "blob":
                                            var l = new Uint8Array(g.length);
                                            for (o = 0; o < g.length; o++) l[o] = g.charCodeAt(o);
                                            var h = "blob" === c ? new Blob([l.buffer], {
                                                type: t
                                            }) : l.buffer;
                                            break;
                                        case "document":
                                            h = (new DOMParser).parseFromString(g, t);
                                            break;
                                        case "json":
                                            h = JSON.parse(g);
                                            break;
                                        default:
                                            h = g
                                    }
                                    setTimeout((function () {
                                        b && b(h), n.manager.itemEnd(a)
                                    }), 0)
                                } catch (t) {
                                    setTimeout((function () {
                                        e && e(t), n.manager.itemError(a), n.manager.itemEnd(a)
                                    }), 0)
                                }
                            } else {
                                Uu[a] = [], Uu[a].push({
                                    onLoad: b,
                                    onProgress: t,
                                    onError: e
                                });
                                var p = new XMLHttpRequest;
                                for (o in p.open("GET", a, !0), p.addEventListener("load", (function (b) {
                                        var t = this.response,
                                            e = Uu[a];
                                        if (delete Uu[a], 200 === this.status || 0 === this.status) {
                                            0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), ku.add(a, t);
                                            for (var r = 0, g = e.length; r < g; r++) {
                                                var o = e[r];
                                                o.onLoad && o.onLoad(t)
                                            }
                                        } else {
                                            for (r = 0, g = e.length; r < g; r++)(o = e[r]).onError && o.onError(b);
                                            n.manager.itemError(a)
                                        }
                                        n.manager.itemEnd(a)
                                    }), !1), p.addEventListener("progress", (function (b) {
                                        for (var t = Uu[a], e = 0, n = t.length; e < n; e++) {
                                            var r = t[e];
                                            r.onProgress && r.onProgress(b)
                                        }
                                    }), !1), p.addEventListener("error", (function (b) {
                                        var t = Uu[a];
                                        delete Uu[a];
                                        for (var e = 0, r = t.length; e < r; e++) {
                                            var g = t[e];
                                            g.onError && g.onError(b)
                                        }
                                        n.manager.itemError(a), n.manager.itemEnd(a)
                                    }), !1), p.addEventListener("abort", (function (b) {
                                        var t = Uu[a];
                                        delete Uu[a];
                                        for (var e = 0, r = t.length; e < r; e++) {
                                            var g = t[e];
                                            g.onError && g.onError(b)
                                        }
                                        n.manager.itemError(a), n.manager.itemEnd(a)
                                    }), !1), void 0 !== this.responseType && (p.responseType = this.responseType), void 0 !== this.withCredentials && (p.withCredentials = this.withCredentials), p.overrideMimeType && p.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) p.setRequestHeader(o, this.requestHeader[o]);
                                p.send(null)
                            }
                            return n.manager.itemStart(a), p
                        }
                        Uu[a].push({
                            onLoad: b,
                            onProgress: t,
                            onError: e
                        })
                    },
                    setResponseType: function (a) {
                        return this.responseType = a, this
                    },
                    setWithCredentials: function (a) {
                        return this.withCredentials = a, this
                    },
                    setMimeType: function (a) {
                        return this.mimeType = a, this
                    },
                    setRequestHeader: function (a) {
                        return this.requestHeader = a, this
                    }
                }), qi.prototype = Object.assign(Object.create(Wi.prototype), {
                    constructor: qi,
                    load: function (a, b, t, e) {
                        var n = this,
                            r = new Yi(n.manager);
                        r.setPath(n.path), r.load(a, (function (a) {
                            b(n.parse(JSON.parse(a)))
                        }), t, e)
                    },
                    parse: function (a) {
                        for (var b = [], t = 0; t < a.length; t++) {
                            var e = Gi.parse(a[t]);
                            b.push(e)
                        }
                        return b
                    }
                }), Xi.prototype = Object.assign(Object.create(Wi.prototype), {
                    constructor: Xi,
                    load: function (a, b, t, e) {
                        function n(n) {
                            c.load(a[n], (function (a) {
                                a = r.parse(a, !0), g[n] = {
                                    width: a.width,
                                    height: a.height,
                                    format: a.format,
                                    mipmaps: a.mipmaps
                                }, 6 === (l += 1) && (1 === a.mipmapCount && (o.minFilter = 1006), o.format = a.format, o.needsUpdate = !0, b && b(o))
                            }), t, e)
                        }
                        var r = this,
                            g = [],
                            o = new pn;
                        o.image = g;
                        var c = new Yi(this.manager);
                        if (c.setPath(this.path), c.setResponseType("arraybuffer"), Array.isArray(a))
                            for (var l = 0, h = 0, p = a.length; h < p; ++h) n(h);
                        else c.load(a, (function (a) {
                            if ((a = r.parse(a, !0)).isCubemap)
                                for (var t = a.mipmaps.length / a.mipmapCount, e = 0; e < t; e++) {
                                    g[e] = {
                                        mipmaps: []
                                    };
                                    for (var n = 0; n < a.mipmapCount; n++) g[e].mipmaps.push(a.mipmaps[e * a.mipmapCount + n]), g[e].format = a.format, g[e].width = a.width, g[e].height = a.height
                                } else o.image.width = a.width, o.image.height = a.height, o.mipmaps = a.mipmaps;
                            1 === a.mipmapCount && (o.minFilter = 1006), o.format = a.format, o.needsUpdate = !0, b && b(o)
                        }), t, e);
                        return o
                    }
                }), Zi.prototype = Object.assign(Object.create(Wi.prototype), {
                    constructor: Zi,
                    load: function (a, b, t, e) {
                        var n = this,
                            r = new st,
                            g = new Yi(this.manager);
                        return g.setResponseType("arraybuffer"), g.setPath(this.path), g.load(a, (function (a) {
                            (a = n.parse(a)) && (void 0 !== a.image ? r.image = a.image : void 0 !== a.data && (r.image.width = a.width, r.image.height = a.height, r.image.data = a.data), r.wrapS = void 0 !== a.wrapS ? a.wrapS : 1001, r.wrapT = void 0 !== a.wrapT ? a.wrapT : 1001, r.magFilter = void 0 !== a.magFilter ? a.magFilter : 1006, r.minFilter = void 0 !== a.minFilter ? a.minFilter : 1006, r.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1, void 0 !== a.format && (r.format = a.format), void 0 !== a.type && (r.type = a.type), void 0 !== a.mipmaps && (r.mipmaps = a.mipmaps, r.minFilter = 1008), 1 === a.mipmapCount && (r.minFilter = 1006), r.needsUpdate = !0, b && b(r, a))
                        }), t, e), r
                    }
                }), Ji.prototype = Object.assign(Object.create(Wi.prototype), {
                    constructor: Ji,
                    load: function (a, b, t, e) {
                        function n() {
                            c.removeEventListener("load", n, !1), c.removeEventListener("error", r, !1), ku.add(a, this), b && b(this), g.manager.itemEnd(a)
                        }

                        function r(b) {
                            c.removeEventListener("load", n, !1), c.removeEventListener("error", r, !1), e && e(b), g.manager.itemError(a), g.manager.itemEnd(a)
                        }
                        void 0 !== this.path && (a = this.path + a), a = this.manager.resolveURL(a);
                        var g = this,
                            o = ku.get(a);
                        if (void 0 !== o) return g.manager.itemStart(a), setTimeout((function () {
                            b && b(o), g.manager.itemEnd(a)
                        }), 0), o;
                        var c = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
                        return c.addEventListener("load", n, !1), c.addEventListener("error", r, !1), "data:" !== a.substr(0, 5) && void 0 !== this.crossOrigin && (c.crossOrigin = this.crossOrigin), g.manager.itemStart(a), c.src = a, c
                    }
                }), $i.prototype = Object.assign(Object.create(Wi.prototype), {
                    constructor: $i,
                    load: function (a, b, t, e) {
                        function n(t) {
                            g.load(a[t], (function (a) {
                                r.images[t] = a, 6 == ++o && (r.needsUpdate = !0, b && b(r))
                            }), void 0, e)
                        }
                        var r = new Tt,
                            g = new Ji(this.manager);
                        g.setCrossOrigin(this.crossOrigin), g.setPath(this.path);
                        var o = 0;
                        for (t = 0; t < a.length; ++t) n(t);
                        return r
                    }
                }), Qi.prototype = Object.assign(Object.create(Wi.prototype), {
                    constructor: Qi,
                    load: function (a, b, t, e) {
                        var n = new l,
                            r = new Ji(this.manager);
                        return r.setCrossOrigin(this.crossOrigin), r.setPath(this.path), r.load(a, (function (t) {
                            n.image = t, t = 0 < a.search(/\.jpe?g($|\?)/i) || 0 === a.search(/^data:image\/jpeg/), n.format = t ? 1022 : 1023, n.needsUpdate = !0, void 0 !== b && b(n)
                        }), t, e), n
                    }
                }), Object.assign(Ki.prototype, {
                    getPoint: function () {
                        return console.warn("THREE.Curve: .getPoint() not implemented."), null
                    },
                    getPointAt: function (a, b) {
                        return a = this.getUtoTmapping(a), this.getPoint(a, b)
                    },
                    getPoints: function (a) {
                        void 0 === a && (a = 5);
                        for (var b = [], t = 0; t <= a; t++) b.push(this.getPoint(t / a));
                        return b
                    },
                    getSpacedPoints: function (a) {
                        void 0 === a && (a = 5);
                        for (var b = [], t = 0; t <= a; t++) b.push(this.getPointAt(t / a));
                        return b
                    },
                    getLength: function () {
                        var a = this.getLengths();
                        return a[a.length - 1]
                    },
                    getLengths: function (a) {
                        if (void 0 === a && (a = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === a + 1 && !this.needsUpdate) return this.cacheArcLengths;
                        this.needsUpdate = !1;
                        var t, b = [],
                            e = this.getPoint(0),
                            n = 0;
                        for (b.push(0), t = 1; t <= a; t++) {
                            var r = this.getPoint(t / a);
                            n += r.distanceTo(e), b.push(n), e = r
                        }
                        return this.cacheArcLengths = b
                    },
                    updateArcLengths: function () {
                        this.needsUpdate = !0, this.getLengths()
                    },
                    getUtoTmapping: function (a, b) {
                        var t = this.getLengths(),
                            e = t.length;
                        b = b || a * t[e - 1];
                        for (var g, n = 0, r = e - 1; n <= r;)
                            if (0 > (g = t[a = Math.floor(n + (r - n) / 2)] - b)) n = a + 1;
                            else {
                                if (!(0 < g)) {
                                    r = a;
                                    break
                                }
                                r = a - 1
                            } return t[a = r] === b ? a / (e - 1) : (a + (b - (n = t[a])) / (t[a + 1] - n)) / (e - 1)
                    },
                    getTangent: function (a) {
                        var b = a - 1e-4;
                        return 0 > b && (b = 0), 1 < (a += 1e-4) && (a = 1), b = this.getPoint(b), this.getPoint(a).clone().sub(b).normalize()
                    },
                    getTangentAt: function (a) {
                        return a = this.getUtoTmapping(a), this.getTangent(a)
                    },
                    computeFrenetFrames: function (a, b) {
                        var t, e = new o,
                            n = [],
                            r = [],
                            c = [],
                            g = new o,
                            l = new m;
                        for (t = 0; t <= a; t++) {
                            var h = t / a;
                            n[t] = this.getTangentAt(h), n[t].normalize()
                        }
                        r[0] = new o, c[0] = new o, t = Number.MAX_VALUE, h = Math.abs(n[0].x);
                        var d = Math.abs(n[0].y),
                            p = Math.abs(n[0].z);
                        for (h <= t && (t = h, e.set(1, 0, 0)), d <= t && (t = d, e.set(0, 1, 0)), p <= t && e.set(0, 0, 1), g.crossVectors(n[0], e).normalize(), r[0].crossVectors(n[0], g), c[0].crossVectors(n[0], r[0]), t = 1; t <= a; t++) r[t] = r[t - 1].clone(), c[t] = c[t - 1].clone(), g.crossVectors(n[t - 1], n[t]), g.length() > Number.EPSILON && (g.normalize(), e = Math.acos(Va.clamp(n[t - 1].dot(n[t]), -1, 1)), r[t].applyMatrix4(l.makeRotationAxis(g, e))), c[t].crossVectors(n[t], r[t]);
                        if (!0 === b)
                            for (e = Math.acos(Va.clamp(r[0].dot(r[a]), -1, 1)), e /= a, 0 < n[0].dot(g.crossVectors(r[0], r[a])) && (e = -e), t = 1; t <= a; t++) r[t].applyMatrix4(l.makeRotationAxis(n[t], e * t)), c[t].crossVectors(n[t], r[t]);
                        return {
                            tangents: n,
                            normals: r,
                            binormals: c
                        }
                    },
                    clone: function () {
                        return (new this.constructor).copy(this)
                    },
                    copy: function (a) {
                        return this.arcLengthDivisions = a.arcLengthDivisions, this
                    },
                    toJSON: function () {
                        var a = {
                            metadata: {
                                version: 4.5,
                                type: "Curve",
                                generator: "Curve.toJSON"
                            }
                        };
                        return a.arcLengthDivisions = this.arcLengthDivisions, a.type = this.type, a
                    },
                    fromJSON: function (a) {
                        return this.arcLengthDivisions = a.arcLengthDivisions, this
                    }
                }), er.prototype = Object.create(Ki.prototype), er.prototype.constructor = er, er.prototype.isEllipseCurve = !0, er.prototype.getPoint = function (a, b) {
                    b = b || new n;
                    for (var t = 2 * Math.PI, e = this.aEndAngle - this.aStartAngle, r = Math.abs(e) < Number.EPSILON; 0 > e;) e += t;
                    for (; e > t;) e -= t;
                    e < Number.EPSILON && (e = r ? 0 : t), !0 !== this.aClockwise || r || (e = e === t ? -t : e - t), t = this.aStartAngle + a * e, a = this.aX + this.xRadius * Math.cos(t);
                    var o = this.aY + this.yRadius * Math.sin(t);
                    return 0 !== this.aRotation && (t = Math.cos(this.aRotation), e = Math.sin(this.aRotation), a = (r = a - this.aX) * t - (o -= this.aY) * e + this.aX, o = r * e + o * t + this.aY), b.set(a, o)
                }, er.prototype.copy = function (a) {
                    return Ki.prototype.copy.call(this, a), this.aX = a.aX, this.aY = a.aY, this.xRadius = a.xRadius, this.yRadius = a.yRadius, this.aStartAngle = a.aStartAngle, this.aEndAngle = a.aEndAngle, this.aClockwise = a.aClockwise, this.aRotation = a.aRotation, this
                }, er.prototype.toJSON = function () {
                    var a = Ki.prototype.toJSON.call(this);
                    return a.aX = this.aX, a.aY = this.aY, a.xRadius = this.xRadius, a.yRadius = this.yRadius, a.aStartAngle = this.aStartAngle, a.aEndAngle = this.aEndAngle, a.aClockwise = this.aClockwise, a.aRotation = this.aRotation, a
                }, er.prototype.fromJSON = function (a) {
                    return Ki.prototype.fromJSON.call(this, a), this.aX = a.aX, this.aY = a.aY, this.xRadius = a.xRadius, this.yRadius = a.yRadius, this.aStartAngle = a.aStartAngle, this.aEndAngle = a.aEndAngle, this.aClockwise = a.aClockwise, this.aRotation = a.aRotation, this
                }, nr.prototype = Object.create(er.prototype), nr.prototype.constructor = nr, nr.prototype.isArcCurve = !0;
                var Hu = new o,
                    Gu = new ir,
                    Vu = new ir,
                    ju = new ir;
                rr.prototype = Object.create(Ki.prototype), rr.prototype.constructor = rr, rr.prototype.isCatmullRomCurve3 = !0, rr.prototype.getPoint = function (a, b) {
                    b = b || new o;
                    var t = this.points,
                        e = t.length;
                    a *= e - (this.closed ? 0 : 1);
                    var n = Math.floor(a);
                    if (a -= n, this.closed ? n += 0 < n ? 0 : (Math.floor(Math.abs(n) / e) + 1) * e : 0 === a && n === e - 1 && (n = e - 2, a = 1), this.closed || 0 < n) var r = t[(n - 1) % e];
                    else Hu.subVectors(t[0], t[1]).add(t[0]), r = Hu;
                    var g = t[n % e],
                        c = t[(n + 1) % e];
                    if (this.closed || n + 2 < e ? t = t[(n + 2) % e] : (Hu.subVectors(t[e - 1], t[e - 2]).add(t[e - 1]), t = Hu), "centripetal" === this.curveType || "chordal" === this.curveType) {
                        var l = "chordal" === this.curveType ? .5 : .25;
                        e = Math.pow(r.distanceToSquared(g), l), 1e-4 > (n = Math.pow(g.distanceToSquared(c), l)) && (n = 1), 1e-4 > e && (e = n), 1e-4 > (l = Math.pow(c.distanceToSquared(t), l)) && (l = n), Gu.initNonuniformCatmullRom(r.x, g.x, c.x, t.x, e, n, l), Vu.initNonuniformCatmullRom(r.y, g.y, c.y, t.y, e, n, l), ju.initNonuniformCatmullRom(r.z, g.z, c.z, t.z, e, n, l)
                    } else "catmullrom" === this.curveType && (Gu.initCatmullRom(r.x, g.x, c.x, t.x, this.tension), Vu.initCatmullRom(r.y, g.y, c.y, t.y, this.tension), ju.initCatmullRom(r.z, g.z, c.z, t.z, this.tension));
                    return b.set(Gu.calc(a), Vu.calc(a), ju.calc(a)), b
                }, rr.prototype.copy = function (a) {
                    Ki.prototype.copy.call(this, a), this.points = [];
                    for (var b = 0, t = a.points.length; b < t; b++) this.points.push(a.points[b].clone());
                    return this.closed = a.closed, this.curveType = a.curveType, this.tension = a.tension, this
                }, rr.prototype.toJSON = function () {
                    var a = Ki.prototype.toJSON.call(this);
                    a.points = [];
                    for (var b = 0, t = this.points.length; b < t; b++) a.points.push(this.points[b].toArray());
                    return a.closed = this.closed, a.curveType = this.curveType, a.tension = this.tension, a
                }, rr.prototype.fromJSON = function (a) {
                    Ki.prototype.fromJSON.call(this, a), this.points = [];
                    for (var b = 0, t = a.points.length; b < t; b++) {
                        var e = a.points[b];
                        this.points.push((new o).fromArray(e))
                    }
                    return this.closed = a.closed, this.curveType = a.curveType, this.tension = a.tension, this
                }, ur.prototype = Object.create(Ki.prototype), ur.prototype.constructor = ur, ur.prototype.isCubicBezierCurve = !0, ur.prototype.getPoint = function (a, b) {
                    b = b || new n;
                    var t = this.v0,
                        e = this.v1,
                        r = this.v2,
                        o = this.v3;
                    return b.set(sr(a, t.x, e.x, r.x, o.x), sr(a, t.y, e.y, r.y, o.y)), b
                }, ur.prototype.copy = function (a) {
                    return Ki.prototype.copy.call(this, a), this.v0.copy(a.v0), this.v1.copy(a.v1), this.v2.copy(a.v2), this.v3.copy(a.v3), this
                }, ur.prototype.toJSON = function () {
                    var a = Ki.prototype.toJSON.call(this);
                    return a.v0 = this.v0.toArray(), a.v1 = this.v1.toArray(), a.v2 = this.v2.toArray(), a.v3 = this.v3.toArray(), a
                }, ur.prototype.fromJSON = function (a) {
                    return Ki.prototype.fromJSON.call(this, a), this.v0.fromArray(a.v0), this.v1.fromArray(a.v1), this.v2.fromArray(a.v2), this.v3.fromArray(a.v3), this
                }, cr.prototype = Object.create(Ki.prototype), cr.prototype.constructor = cr, cr.prototype.isCubicBezierCurve3 = !0, cr.prototype.getPoint = function (a, b) {
                    b = b || new o;
                    var t = this.v0,
                        e = this.v1,
                        n = this.v2,
                        r = this.v3;
                    return b.set(sr(a, t.x, e.x, n.x, r.x), sr(a, t.y, e.y, n.y, r.y), sr(a, t.z, e.z, n.z, r.z)), b
                }, cr.prototype.copy = function (a) {
                    return Ki.prototype.copy.call(this, a), this.v0.copy(a.v0), this.v1.copy(a.v1), this.v2.copy(a.v2), this.v3.copy(a.v3), this
                }, cr.prototype.toJSON = function () {
                    var a = Ki.prototype.toJSON.call(this);
                    return a.v0 = this.v0.toArray(), a.v1 = this.v1.toArray(), a.v2 = this.v2.toArray(), a.v3 = this.v3.toArray(), a
                }, cr.prototype.fromJSON = function (a) {
                    return Ki.prototype.fromJSON.call(this, a), this.v0.fromArray(a.v0), this.v1.fromArray(a.v1), this.v2.fromArray(a.v2), this.v3.fromArray(a.v3), this
                }, lr.prototype = Object.create(Ki.prototype), lr.prototype.constructor = lr, lr.prototype.isLineCurve = !0, lr.prototype.getPoint = function (a, b) {
                    return b = b || new n, 1 === a ? b.copy(this.v2) : (b.copy(this.v2).sub(this.v1), b.multiplyScalar(a).add(this.v1)), b
                }, lr.prototype.getPointAt = function (a, b) {
                    return this.getPoint(a, b)
                }, lr.prototype.getTangent = function () {
                    return this.v2.clone().sub(this.v1).normalize()
                }, lr.prototype.copy = function (a) {
                    return Ki.prototype.copy.call(this, a), this.v1.copy(a.v1), this.v2.copy(a.v2), this
                }, lr.prototype.toJSON = function () {
                    var a = Ki.prototype.toJSON.call(this);
                    return a.v1 = this.v1.toArray(), a.v2 = this.v2.toArray(), a
                }, lr.prototype.fromJSON = function (a) {
                    return Ki.prototype.fromJSON.call(this, a), this.v1.fromArray(a.v1), this.v2.fromArray(a.v2), this
                }, dr.prototype = Object.create(Ki.prototype), dr.prototype.constructor = dr, dr.prototype.isLineCurve3 = !0, dr.prototype.getPoint = function (a, b) {
                    return b = b || new o, 1 === a ? b.copy(this.v2) : (b.copy(this.v2).sub(this.v1), b.multiplyScalar(a).add(this.v1)), b
                }, dr.prototype.getPointAt = function (a, b) {
                    return this.getPoint(a, b)
                }, dr.prototype.copy = function (a) {
                    return Ki.prototype.copy.call(this, a), this.v1.copy(a.v1), this.v2.copy(a.v2), this
                }, dr.prototype.toJSON = function () {
                    var a = Ki.prototype.toJSON.call(this);
                    return a.v1 = this.v1.toArray(), a.v2 = this.v2.toArray(), a
                }, dr.prototype.fromJSON = function (a) {
                    return Ki.prototype.fromJSON.call(this, a), this.v1.fromArray(a.v1), this.v2.fromArray(a.v2), this
                }, pr.prototype = Object.create(Ki.prototype), pr.prototype.constructor = pr, pr.prototype.isQuadraticBezierCurve = !0, pr.prototype.getPoint = function (a, b) {
                    b = b || new n;
                    var t = this.v0,
                        e = this.v1,
                        r = this.v2;
                    return b.set(or(a, t.x, e.x, r.x), or(a, t.y, e.y, r.y)), b
                }, pr.prototype.copy = function (a) {
                    return Ki.prototype.copy.call(this, a), this.v0.copy(a.v0), this.v1.copy(a.v1), this.v2.copy(a.v2), this
                }, pr.prototype.toJSON = function () {
                    var a = Ki.prototype.toJSON.call(this);
                    return a.v0 = this.v0.toArray(), a.v1 = this.v1.toArray(), a.v2 = this.v2.toArray(), a
                }, pr.prototype.fromJSON = function (a) {
                    return Ki.prototype.fromJSON.call(this, a), this.v0.fromArray(a.v0), this.v1.fromArray(a.v1), this.v2.fromArray(a.v2), this
                }, fr.prototype = Object.create(Ki.prototype), fr.prototype.constructor = fr, fr.prototype.isQuadraticBezierCurve3 = !0, fr.prototype.getPoint = function (a, b) {
                    b = b || new o;
                    var t = this.v0,
                        e = this.v1,
                        n = this.v2;
                    return b.set(or(a, t.x, e.x, n.x), or(a, t.y, e.y, n.y), or(a, t.z, e.z, n.z)), b
                }, fr.prototype.copy = function (a) {
                    return Ki.prototype.copy.call(this, a), this.v0.copy(a.v0), this.v1.copy(a.v1), this.v2.copy(a.v2), this
                }, fr.prototype.toJSON = function () {
                    var a = Ki.prototype.toJSON.call(this);
                    return a.v0 = this.v0.toArray(), a.v1 = this.v1.toArray(), a.v2 = this.v2.toArray(), a
                }, fr.prototype.fromJSON = function (a) {
                    return Ki.prototype.fromJSON.call(this, a), this.v0.fromArray(a.v0), this.v1.fromArray(a.v1), this.v2.fromArray(a.v2), this
                }, mr.prototype = Object.create(Ki.prototype), mr.prototype.constructor = mr, mr.prototype.isSplineCurve = !0, mr.prototype.getPoint = function (a, b) {
                    b = b || new n;
                    var t = this.points,
                        e = (t.length - 1) * a;
                    e -= a = Math.floor(e);
                    var r = t[0 === a ? a : a - 1],
                        o = t[a],
                        g = t[a > t.length - 2 ? t.length - 1 : a + 1];
                    return t = t[a > t.length - 3 ? t.length - 1 : a + 2], b.set(ar(e, r.x, o.x, g.x, t.x), ar(e, r.y, o.y, g.y, t.y)), b
                }, mr.prototype.copy = function (a) {
                    Ki.prototype.copy.call(this, a), this.points = [];
                    for (var b = 0, t = a.points.length; b < t; b++) this.points.push(a.points[b].clone());
                    return this
                }, mr.prototype.toJSON = function () {
                    var a = Ki.prototype.toJSON.call(this);
                    a.points = [];
                    for (var b = 0, t = this.points.length; b < t; b++) a.points.push(this.points[b].toArray());
                    return a
                }, mr.prototype.fromJSON = function (a) {
                    Ki.prototype.fromJSON.call(this, a), this.points = [];
                    for (var b = 0, t = a.points.length; b < t; b++) {
                        var e = a.points[b];
                        this.points.push((new n).fromArray(e))
                    }
                    return this
                };
                var Wu = Object.freeze({
                    __proto__: null,
                    ArcCurve: nr,
                    CatmullRomCurve3: rr,
                    CubicBezierCurve: ur,
                    CubicBezierCurve3: cr,
                    EllipseCurve: er,
                    LineCurve: lr,
                    LineCurve3: dr,
                    QuadraticBezierCurve: pr,
                    QuadraticBezierCurve3: fr,
                    SplineCurve: mr
                });
                gr.prototype = Object.assign(Object.create(Ki.prototype), {
                    constructor: gr,
                    add: function (a) {
                        this.curves.push(a)
                    },
                    closePath: function () {
                        var a = this.curves[0].getPoint(0),
                            b = this.curves[this.curves.length - 1].getPoint(1);
                        a.equals(b) || this.curves.push(new lr(b, a))
                    },
                    getPoint: function (a) {
                        var b = a * this.getLength(),
                            t = this.getCurveLengths();
                        for (a = 0; a < t.length;) {
                            if (t[a] >= b) return b = t[a] - b, t = (a = this.curves[a]).getLength(), a.getPointAt(0 === t ? 0 : 1 - b / t);
                            a++
                        }
                        return null
                    },
                    getLength: function () {
                        var a = this.getCurveLengths();
                        return a[a.length - 1]
                    },
                    updateArcLengths: function () {
                        this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                    },
                    getCurveLengths: function () {
                        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                        for (var a = [], b = 0, t = 0, e = this.curves.length; t < e; t++) b += this.curves[t].getLength(), a.push(b);
                        return this.cacheLengths = a
                    },
                    getSpacedPoints: function (a) {
                        void 0 === a && (a = 40);
                        for (var b = [], t = 0; t <= a; t++) b.push(this.getPoint(t / a));
                        return this.autoClose && b.push(b[0]), b
                    },
                    getPoints: function (a) {
                        a = a || 12;
                        for (var t, b = [], e = 0, n = this.curves; e < n.length; e++) {
                            var r = n[e];
                            r = r.getPoints(r && r.isEllipseCurve ? 2 * a : r && (r.isLineCurve || r.isLineCurve3) ? 1 : r && r.isSplineCurve ? a * r.points.length : a);
                            for (var g = 0; g < r.length; g++) {
                                var o = r[g];
                                t && t.equals(o) || (b.push(o), t = o)
                            }
                        }
                        return this.autoClose && 1 < b.length && !b[b.length - 1].equals(b[0]) && b.push(b[0]), b
                    },
                    copy: function (a) {
                        Ki.prototype.copy.call(this, a), this.curves = [];
                        for (var b = 0, t = a.curves.length; b < t; b++) this.curves.push(a.curves[b].clone());
                        return this.autoClose = a.autoClose, this
                    },
                    toJSON: function () {
                        var a = Ki.prototype.toJSON.call(this);
                        a.autoClose = this.autoClose, a.curves = [];
                        for (var b = 0, t = this.curves.length; b < t; b++) a.curves.push(this.curves[b].toJSON());
                        return a
                    },
                    fromJSON: function (a) {
                        Ki.prototype.fromJSON.call(this, a), this.autoClose = a.autoClose, this.curves = [];
                        for (var b = 0, t = a.curves.length; b < t; b++) {
                            var e = a.curves[b];
                            this.curves.push((new Wu[e.type]).fromJSON(e))
                        }
                        return this
                    }
                }), vr.prototype = Object.assign(Object.create(gr.prototype), {
                    constructor: vr,
                    setFromPoints: function (a) {
                        this.moveTo(a[0].x, a[0].y);
                        for (var b = 1, t = a.length; b < t; b++) this.lineTo(a[b].x, a[b].y);
                        return this
                    },
                    moveTo: function (a, b) {
                        return this.currentPoint.set(a, b), this
                    },
                    lineTo: function (a, b) {
                        var t = new lr(this.currentPoint.clone(), new n(a, b));
                        return this.curves.push(t), this.currentPoint.set(a, b), this
                    },
                    quadraticCurveTo: function (a, b, t, e) {
                        return a = new pr(this.currentPoint.clone(), new n(a, b), new n(t, e)), this.curves.push(a), this.currentPoint.set(t, e), this
                    },
                    bezierCurveTo: function (a, b, t, e, r, o) {
                        return a = new ur(this.currentPoint.clone(), new n(a, b), new n(t, e), new n(r, o)), this.curves.push(a), this.currentPoint.set(r, o), this
                    },
                    splineThru: function (a) {
                        var b = [this.currentPoint.clone()].concat(a);
                        return b = new mr(b), this.curves.push(b), this.currentPoint.copy(a[a.length - 1]), this
                    },
                    arc: function (a, b, t, e, n, r) {
                        return this.absarc(a + this.currentPoint.x, b + this.currentPoint.y, t, e, n, r), this
                    },
                    absarc: function (a, b, t, e, n, r) {
                        return this.absellipse(a, b, t, t, e, n, r), this
                    },
                    ellipse: function (a, b, t, e, n, r, g, o) {
                        return this.absellipse(a + this.currentPoint.x, b + this.currentPoint.y, t, e, n, r, g, o), this
                    },
                    absellipse: function (a, b, t, e, n, r, g, o) {
                        return a = new er(a, b, t, e, n, r, g, o), 0 < this.curves.length && ((b = a.getPoint(0)).equals(this.currentPoint) || this.lineTo(b.x, b.y)), this.curves.push(a), a = a.getPoint(1), this.currentPoint.copy(a), this
                    },
                    copy: function (a) {
                        return gr.prototype.copy.call(this, a), this.currentPoint.copy(a.currentPoint), this
                    },
                    toJSON: function () {
                        var a = gr.prototype.toJSON.call(this);
                        return a.currentPoint = this.currentPoint.toArray(), a
                    },
                    fromJSON: function (a) {
                        return gr.prototype.fromJSON.call(this, a), this.currentPoint.fromArray(a.currentPoint), this
                    }
                }), yr.prototype = Object.assign(Object.create(vr.prototype), {
                    constructor: yr,
                    getPointsHoles: function (a) {
                        for (var b = [], t = 0, e = this.holes.length; t < e; t++) b[t] = this.holes[t].getPoints(a);
                        return b
                    },
                    extractPoints: function (a) {
                        return {
                            shape: this.getPoints(a),
                            holes: this.getPointsHoles(a)
                        }
                    },
                    copy: function (a) {
                        vr.prototype.copy.call(this, a), this.holes = [];
                        for (var b = 0, t = a.holes.length; b < t; b++) this.holes.push(a.holes[b].clone());
                        return this
                    },
                    toJSON: function () {
                        var a = vr.prototype.toJSON.call(this);
                        a.uuid = this.uuid, a.holes = [];
                        for (var b = 0, t = this.holes.length; b < t; b++) a.holes.push(this.holes[b].toJSON());
                        return a
                    },
                    fromJSON: function (a) {
                        vr.prototype.fromJSON.call(this, a), this.uuid = a.uuid, this.holes = [];
                        for (var b = 0, t = a.holes.length; b < t; b++) {
                            var e = a.holes[b];
                            this.holes.push((new vr).fromJSON(e))
                        }
                        return this
                    }
                }), _r.prototype = Object.assign(Object.create(_.prototype), {
                    constructor: _r,
                    isLight: !0,
                    copy: function (a) {
                        return _.prototype.copy.call(this, a), this.color.copy(a.color), this.intensity = a.intensity, this
                    },
                    toJSON: function (a) {
                        return (a = _.prototype.toJSON.call(this, a)).object.color = this.color.getHex(), a.object.intensity = this.intensity, void 0 !== this.groundColor && (a.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (a.object.distance = this.distance), void 0 !== this.angle && (a.object.angle = this.angle), void 0 !== this.decay && (a.object.decay = this.decay), void 0 !== this.penumbra && (a.object.penumbra = this.penumbra), void 0 !== this.shadow && (a.object.shadow = this.shadow.toJSON()), a
                    }
                }), xr.prototype = Object.assign(Object.create(_r.prototype), {
                    constructor: xr,
                    isHemisphereLight: !0,
                    copy: function (a) {
                        return _r.prototype.copy.call(this, a), this.groundColor.copy(a.groundColor), this
                    }
                }), Object.assign(wr.prototype, {
                    _projScreenMatrix: new m,
                    _lightPositionWorld: new o,
                    _lookTarget: new o,
                    getViewportCount: function () {
                        return this._viewportCount
                    },
                    getFrustum: function () {
                        return this._frustum
                    },
                    updateMatrices: function (a) {
                        var b = this.camera,
                            t = this.matrix,
                            e = this._projScreenMatrix,
                            n = this._lookTarget,
                            r = this._lightPositionWorld;
                        r.setFromMatrixPosition(a.matrixWorld), b.position.copy(r), n.setFromMatrixPosition(a.target.matrixWorld), b.lookAt(n), b.updateMatrixWorld(), e.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse), this._frustum.setFromMatrix(e), t.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), t.multiply(b.projectionMatrix), t.multiply(b.matrixWorldInverse)
                    },
                    getViewport: function (a) {
                        return this._viewports[a]
                    },
                    getFrameExtents: function () {
                        return this._frameExtents
                    },
                    copy: function (a) {
                        return this.camera = a.camera.clone(), this.bias = a.bias, this.radius = a.radius, this.mapSize.copy(a.mapSize), this
                    },
                    clone: function () {
                        return (new this.constructor).copy(this)
                    },
                    toJSON: function () {
                        var a = {};
                        return 0 !== this.bias && (a.bias = this.bias), 1 !== this.radius && (a.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (a.mapSize = this.mapSize.toArray()), a.camera = this.camera.toJSON(!1).object, delete a.camera.matrix, a
                    }
                }), Mr.prototype = Object.assign(Object.create(wr.prototype), {
                    constructor: Mr,
                    isSpotLightShadow: !0,
                    updateMatrices: function (a) {
                        var b = this.camera,
                            t = 2 * Va.RAD2DEG * a.angle,
                            e = this.mapSize.width / this.mapSize.height,
                            n = a.distance || b.far;
                        t === b.fov && e === b.aspect && n === b.far || (b.fov = t, b.aspect = e, b.far = n, b.updateProjectionMatrix()), wr.prototype.updateMatrices.call(this, a)
                    }
                }), Er.prototype = Object.assign(Object.create(_r.prototype), {
                    constructor: Er,
                    isSpotLight: !0,
                    copy: function (a) {
                        return _r.prototype.copy.call(this, a), this.distance = a.distance, this.angle = a.angle, this.penumbra = a.penumbra, this.decay = a.decay, this.target = a.target.clone(), this.shadow = a.shadow.clone(), this
                    }
                }), Tr.prototype = Object.assign(Object.create(wr.prototype), {
                    constructor: Tr,
                    isPointLightShadow: !0,
                    updateMatrices: function (a, b) {
                        void 0 === b && (b = 0);
                        var t = this.camera,
                            e = this.matrix,
                            n = this._lightPositionWorld,
                            r = this._lookTarget,
                            g = this._projScreenMatrix;
                        n.setFromMatrixPosition(a.matrixWorld), t.position.copy(n), r.copy(t.position), r.add(this._cubeDirections[b]), t.up.copy(this._cubeUps[b]), t.lookAt(r), t.updateMatrixWorld(), e.makeTranslation(-n.x, -n.y, -n.z), g.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromMatrix(g)
                    }
                }), Dr.prototype = Object.assign(Object.create(_r.prototype), {
                    constructor: Dr,
                    isPointLight: !0,
                    copy: function (a) {
                        return _r.prototype.copy.call(this, a), this.distance = a.distance, this.decay = a.decay, this.shadow = a.shadow.clone(), this
                    }
                }), Sr.prototype = Object.assign(Object.create(nt.prototype), {
                    constructor: Sr,
                    isOrthographicCamera: !0,
                    copy: function (a, b) {
                        return nt.prototype.copy.call(this, a, b), this.left = a.left, this.right = a.right, this.top = a.top, this.bottom = a.bottom, this.near = a.near, this.far = a.far, this.zoom = a.zoom, this.view = null === a.view ? null : Object.assign({}, a.view), this
                    },
                    setViewOffset: function (a, b, t, e, n, r) {
                        null === this.view && (this.view = {
                            enabled: !0,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1
                        }), this.view.enabled = !0, this.view.fullWidth = a, this.view.fullHeight = b, this.view.offsetX = t, this.view.offsetY = e, this.view.width = n, this.view.height = r, this.updateProjectionMatrix()
                    },
                    clearViewOffset: function () {
                        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                    },
                    updateProjectionMatrix: function () {
                        var a = (this.right - this.left) / (2 * this.zoom),
                            b = (this.top - this.bottom) / (2 * this.zoom),
                            t = (this.right + this.left) / 2,
                            e = (this.top + this.bottom) / 2,
                            n = t - a;
                        if (t += a, a = e + b, b = e - b, null !== this.view && this.view.enabled) {
                            t = this.zoom / (this.view.width / this.view.fullWidth), b = this.zoom / (this.view.height / this.view.fullHeight);
                            var r = (this.right - this.left) / this.view.width;
                            e = (this.top - this.bottom) / this.view.height, t = (n += this.view.offsetX / t * r) + this.view.width / t * r, b = (a -= this.view.offsetY / b * e) - this.view.height / b * e
                        }
                        this.projectionMatrix.makeOrthographic(n, t, a, b, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                    },
                    toJSON: function (a) {
                        return (a = _.prototype.toJSON.call(this, a)).object.zoom = this.zoom, a.object.left = this.left, a.object.right = this.right, a.object.top = this.top, a.object.bottom = this.bottom, a.object.near = this.near, a.object.far = this.far, null !== this.view && (a.object.view = Object.assign({}, this.view)), a
                    }
                }), Ar.prototype = Object.assign(Object.create(wr.prototype), {
                    constructor: Ar,
                    isDirectionalLightShadow: !0,
                    updateMatrices: function (a) {
                        wr.prototype.updateMatrices.call(this, a)
                    }
                }), Cr.prototype = Object.assign(Object.create(_r.prototype), {
                    constructor: Cr,
                    isDirectionalLight: !0,
                    copy: function (a) {
                        return _r.prototype.copy.call(this, a), this.target = a.target.clone(), this.shadow = a.shadow.clone(), this
                    }
                }), Lr.prototype = Object.assign(Object.create(_r.prototype), {
                    constructor: Lr,
                    isAmbientLight: !0
                }), Rr.prototype = Object.assign(Object.create(_r.prototype), {
                    constructor: Rr,
                    isRectAreaLight: !0,
                    copy: function (a) {
                        return _r.prototype.copy.call(this, a), this.width = a.width, this.height = a.height, this
                    },
                    toJSON: function (a) {
                        return (a = _r.prototype.toJSON.call(this, a)).object.width = this.width, a.object.height = this.height, a
                    }
                }), Pr.prototype = Object.assign(Object.create(Wi.prototype), {
                    constructor: Pr,
                    load: function (a, b, t, e) {
                        var n = this,
                            r = new Yi(n.manager);
                        r.setPath(n.path), r.load(a, (function (a) {
                            b(n.parse(JSON.parse(a)))
                        }), t, e)
                    },
                    parse: function (a) {
                        function b(a) {
                            return void 0 === t[a] && console.warn("THREE.MaterialLoader: Undefined texture", a), t[a]
                        }
                        var t = this.textures,
                            e = new Iu[a.type];
                        if (void 0 !== a.uuid && (e.uuid = a.uuid), void 0 !== a.name && (e.name = a.name), void 0 !== a.color && e.color.setHex(a.color), void 0 !== a.roughness && (e.roughness = a.roughness), void 0 !== a.metalness && (e.metalness = a.metalness), void 0 !== a.sheen && (e.sheen = (new A).setHex(a.sheen)), void 0 !== a.emissive && e.emissive.setHex(a.emissive), void 0 !== a.specular && e.specular.setHex(a.specular), void 0 !== a.shininess && (e.shininess = a.shininess), void 0 !== a.clearcoat && (e.clearcoat = a.clearcoat), void 0 !== a.clearcoatRoughness && (e.clearcoatRoughness = a.clearcoatRoughness), void 0 !== a.vertexColors && (e.vertexColors = a.vertexColors), void 0 !== a.fog && (e.fog = a.fog), void 0 !== a.flatShading && (e.flatShading = a.flatShading), void 0 !== a.blending && (e.blending = a.blending), void 0 !== a.combine && (e.combine = a.combine), void 0 !== a.side && (e.side = a.side), void 0 !== a.opacity && (e.opacity = a.opacity), void 0 !== a.transparent && (e.transparent = a.transparent), void 0 !== a.alphaTest && (e.alphaTest = a.alphaTest), void 0 !== a.depthTest && (e.depthTest = a.depthTest), void 0 !== a.depthWrite && (e.depthWrite = a.depthWrite), void 0 !== a.colorWrite && (e.colorWrite = a.colorWrite), void 0 !== a.stencilWrite && (e.stencilWrite = a.stencilWrite), void 0 !== a.stencilWriteMask && (e.stencilWriteMask = a.stencilWriteMask), void 0 !== a.stencilFunc && (e.stencilFunc = a.stencilFunc), void 0 !== a.stencilRef && (e.stencilRef = a.stencilRef), void 0 !== a.stencilFuncMask && (e.stencilFuncMask = a.stencilFuncMask), void 0 !== a.stencilFail && (e.stencilFail = a.stencilFail), void 0 !== a.stencilZFail && (e.stencilZFail = a.stencilZFail), void 0 !== a.stencilZPass && (e.stencilZPass = a.stencilZPass), void 0 !== a.wireframe && (e.wireframe = a.wireframe), void 0 !== a.wireframeLinewidth && (e.wireframeLinewidth = a.wireframeLinewidth), void 0 !== a.wireframeLinecap && (e.wireframeLinecap = a.wireframeLinecap), void 0 !== a.wireframeLinejoin && (e.wireframeLinejoin = a.wireframeLinejoin), void 0 !== a.rotation && (e.rotation = a.rotation), 1 !== a.linewidth && (e.linewidth = a.linewidth), void 0 !== a.dashSize && (e.dashSize = a.dashSize), void 0 !== a.gapSize && (e.gapSize = a.gapSize), void 0 !== a.scale && (e.scale = a.scale), void 0 !== a.polygonOffset && (e.polygonOffset = a.polygonOffset), void 0 !== a.polygonOffsetFactor && (e.polygonOffsetFactor = a.polygonOffsetFactor), void 0 !== a.polygonOffsetUnits && (e.polygonOffsetUnits = a.polygonOffsetUnits), void 0 !== a.skinning && (e.skinning = a.skinning), void 0 !== a.morphTargets && (e.morphTargets = a.morphTargets), void 0 !== a.morphNormals && (e.morphNormals = a.morphNormals), void 0 !== a.dithering && (e.dithering = a.dithering), void 0 !== a.visible && (e.visible = a.visible), void 0 !== a.toneMapped && (e.toneMapped = a.toneMapped), void 0 !== a.userData && (e.userData = a.userData), void 0 !== a.uniforms)
                            for (var r in a.uniforms) {
                                var l = a.uniforms[r];
                                switch (e.uniforms[r] = {}, l.type) {
                                    case "t":
                                        e.uniforms[r].value = b(l.value);
                                        break;
                                    case "c":
                                        e.uniforms[r].value = (new A).setHex(l.value);
                                        break;
                                    case "v2":
                                        e.uniforms[r].value = (new n).fromArray(l.value);
                                        break;
                                    case "v3":
                                        e.uniforms[r].value = (new o).fromArray(l.value);
                                        break;
                                    case "v4":
                                        e.uniforms[r].value = (new h).fromArray(l.value);
                                        break;
                                    case "m3":
                                        e.uniforms[r].value = (new c).fromArray(l.value);
                                    case "m4":
                                        e.uniforms[r].value = (new m).fromArray(l.value);
                                        break;
                                    default:
                                        e.uniforms[r].value = l.value
                                }
                            }
                        if (void 0 !== a.defines && (e.defines = a.defines), void 0 !== a.vertexShader && (e.vertexShader = a.vertexShader), void 0 !== a.fragmentShader && (e.fragmentShader = a.fragmentShader), void 0 !== a.extensions)
                            for (var g in a.extensions) e.extensions[g] = a.extensions[g];
                        return void 0 !== a.shading && (e.flatShading = 1 === a.shading), void 0 !== a.size && (e.size = a.size), void 0 !== a.sizeAttenuation && (e.sizeAttenuation = a.sizeAttenuation), void 0 !== a.map && (e.map = b(a.map)), void 0 !== a.matcap && (e.matcap = b(a.matcap)), void 0 !== a.alphaMap && (e.alphaMap = b(a.alphaMap), e.transparent = !0), void 0 !== a.bumpMap && (e.bumpMap = b(a.bumpMap)), void 0 !== a.bumpScale && (e.bumpScale = a.bumpScale), void 0 !== a.normalMap && (e.normalMap = b(a.normalMap)), void 0 !== a.normalMapType && (e.normalMapType = a.normalMapType), void 0 !== a.normalScale && (r = a.normalScale, !1 === Array.isArray(r) && (r = [r, r]), e.normalScale = (new n).fromArray(r)), void 0 !== a.displacementMap && (e.displacementMap = b(a.displacementMap)), void 0 !== a.displacementScale && (e.displacementScale = a.displacementScale), void 0 !== a.displacementBias && (e.displacementBias = a.displacementBias), void 0 !== a.roughnessMap && (e.roughnessMap = b(a.roughnessMap)), void 0 !== a.metalnessMap && (e.metalnessMap = b(a.metalnessMap)), void 0 !== a.emissiveMap && (e.emissiveMap = b(a.emissiveMap)), void 0 !== a.emissiveIntensity && (e.emissiveIntensity = a.emissiveIntensity), void 0 !== a.specularMap && (e.specularMap = b(a.specularMap)), void 0 !== a.envMap && (e.envMap = b(a.envMap)), void 0 !== a.envMapIntensity && (e.envMapIntensity = a.envMapIntensity), void 0 !== a.reflectivity && (e.reflectivity = a.reflectivity), void 0 !== a.refractionRatio && (e.refractionRatio = a.refractionRatio), void 0 !== a.lightMap && (e.lightMap = b(a.lightMap)), void 0 !== a.lightMapIntensity && (e.lightMapIntensity = a.lightMapIntensity), void 0 !== a.aoMap && (e.aoMap = b(a.aoMap)), void 0 !== a.aoMapIntensity && (e.aoMapIntensity = a.aoMapIntensity), void 0 !== a.gradientMap && (e.gradientMap = b(a.gradientMap)), void 0 !== a.clearcoatNormalMap && (e.clearcoatNormalMap = b(a.clearcoatNormalMap)), void 0 !== a.clearcoatNormalScale && (e.clearcoatNormalScale = (new n).fromArray(a.clearcoatNormalScale)), e
                    },
                    setTextures: function (a) {
                        return this.textures = a, this
                    }
                });
                var Yu = {
                    decodeText: function (a) {
                        if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(a);
                        for (var b = "", t = 0, e = a.length; t < e; t++) b += String.fromCharCode(a[t]);
                        try {
                            return decodeURIComponent(escape(b))
                        } catch (t) {
                            return b
                        }
                    },
                    extractUrlBase: function (a) {
                        var b = a.lastIndexOf("/");
                        return -1 === b ? "./" : a.substr(0, b + 1)
                    }
                };
                Or.prototype = Object.assign(Object.create(X.prototype), {
                    constructor: Or,
                    isInstancedBufferGeometry: !0,
                    copy: function (a) {
                        return X.prototype.copy.call(this, a), this.maxInstancedCount = a.maxInstancedCount, this
                    },
                    clone: function () {
                        return (new this.constructor).copy(this)
                    },
                    toJSON: function () {
                        var a = X.prototype.toJSON.call(this);
                        return a.maxInstancedCount = this.maxInstancedCount, a.isInstancedBufferGeometry = !0, a
                    }
                }), Fr.prototype = Object.assign(Object.create(N.prototype), {
                    constructor: Fr,
                    isInstancedBufferAttribute: !0,
                    copy: function (a) {
                        return N.prototype.copy.call(this, a), this.meshPerAttribute = a.meshPerAttribute, this
                    },
                    toJSON: function () {
                        var a = N.prototype.toJSON.call(this);
                        return a.meshPerAttribute = this.meshPerAttribute, a.isInstancedBufferAttribute = !0, a
                    }
                }), Nr.prototype = Object.assign(Object.create(Wi.prototype), {
                    constructor: Nr,
                    load: function (a, b, t, e) {
                        var n = this,
                            r = new Yi(n.manager);
                        r.setPath(n.path), r.load(a, (function (a) {
                            b(n.parse(JSON.parse(a)))
                        }), t, e)
                    },
                    parse: function (a) {
                        var b = a.isInstancedBufferGeometry ? new Or : new X,
                            t = a.data.index;
                        if (void 0 !== t) {
                            var e = new qu[t.type](t.array);
                            b.setIndex(new N(e, 1))
                        }
                        for (var n in t = a.data.attributes) {
                            var r = t[n];
                            e = new qu[r.type](r.array), e = new(r.isInstancedBufferAttribute ? Fr : N)(e, r.itemSize, r.normalized), void 0 !== r.name && (e.name = r.name), b.setAttribute(n, e)
                        }
                        var g = a.data.morphAttributes;
                        if (g)
                            for (n in g) {
                                var c = g[n],
                                    l = [];
                                t = 0;
                                for (var h = c.length; t < h; t++) r = c[t], e = new N(e = new qu[r.type](r.array), r.itemSize, r.normalized), void 0 !== r.name && (e.name = r.name), l.push(e);
                                b.morphAttributes[n] = l
                            }
                        if (a.data.morphTargetsRelative && (b.morphTargetsRelative = !0), void 0 !== (n = a.data.groups || a.data.drawcalls || a.data.offsets))
                            for (t = 0, r = n.length; t !== r; ++t) e = n[t], b.addGroup(e.start, e.count, e.materialIndex);
                        return void 0 !== (t = a.data.boundingSphere) && (n = new o, void 0 !== t.center && n.fromArray(t.center), b.boundingSphere = new E(n, t.radius)), a.name && (b.name = a.name), a.userData && (b.userData = a.userData), b
                    }
                });
                var qu = {
                    Int8Array: Int8Array,
                    Uint8Array: Uint8Array,
                    Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
                    Int16Array: Int16Array,
                    Uint16Array: Uint16Array,
                    Int32Array: Int32Array,
                    Uint32Array: Uint32Array,
                    Float32Array: Float32Array,
                    Float64Array: Float64Array
                };
                Ir.prototype = Object.assign(Object.create(Wi.prototype), {
                    constructor: Ir,
                    load: function (a, b, t, e) {
                        var n = this,
                            r = "" === this.path ? Yu.extractUrlBase(a) : this.path;
                        this.resourcePath = this.resourcePath || r, (r = new Yi(n.manager)).setPath(this.path), r.load(a, (function (t) {
                            var r = null;
                            try {
                                r = JSON.parse(t)
                            } catch (t) {
                                return void 0 !== e && e(t), void console.error("THREE:ObjectLoader: Can't parse " + a + ".", t.message)
                            }
                            void 0 === (t = r.metadata) || void 0 === t.type || "geometry" === t.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + a) : n.parse(r, b)
                        }), t, e)
                    },
                    parse: function (a, b) {
                        var t = this.parseShape(a.shapes);
                        t = this.parseGeometries(a.geometries, t);
                        var e = this.parseImages(a.images, (function () {
                            void 0 !== b && b(n)
                        }));
                        e = this.parseTextures(a.textures, e), e = this.parseMaterials(a.materials, e);
                        var n = this.parseObject(a.object, t, e);
                        return a.animations && (n.animations = this.parseAnimations(a.animations)), void 0 !== a.images && 0 !== a.images.length || void 0 === b || b(n), n
                    },
                    parseShape: function (a) {
                        var b = {};
                        if (void 0 !== a)
                            for (var t = 0, e = a.length; t < e; t++) {
                                var n = (new yr).fromJSON(a[t]);
                                b[n.uuid] = n
                            }
                        return b
                    },
                    parseGeometries: function (a, b) {
                        var t = {};
                        if (void 0 !== a)
                            for (var e = new Nr, n = 0, r = a.length; n < r; n++) {
                                var g = a[n];
                                switch (g.type) {
                                    case "PlaneGeometry":
                                    case "PlaneBufferGeometry":
                                        var o = new Nu[g.type](g.width, g.height, g.widthSegments, g.heightSegments);
                                        break;
                                    case "BoxGeometry":
                                    case "BoxBufferGeometry":
                                    case "CubeGeometry":
                                        o = new Nu[g.type](g.width, g.height, g.depth, g.widthSegments, g.heightSegments, g.depthSegments);
                                        break;
                                    case "CircleGeometry":
                                    case "CircleBufferGeometry":
                                        o = new Nu[g.type](g.radius, g.segments, g.thetaStart, g.thetaLength);
                                        break;
                                    case "CylinderGeometry":
                                    case "CylinderBufferGeometry":
                                        o = new Nu[g.type](g.radiusTop, g.radiusBottom, g.height, g.radialSegments, g.heightSegments, g.openEnded, g.thetaStart, g.thetaLength);
                                        break;
                                    case "ConeGeometry":
                                    case "ConeBufferGeometry":
                                        o = new Nu[g.type](g.radius, g.height, g.radialSegments, g.heightSegments, g.openEnded, g.thetaStart, g.thetaLength);
                                        break;
                                    case "SphereGeometry":
                                    case "SphereBufferGeometry":
                                        o = new Nu[g.type](g.radius, g.widthSegments, g.heightSegments, g.phiStart, g.phiLength, g.thetaStart, g.thetaLength);
                                        break;
                                    case "DodecahedronGeometry":
                                    case "DodecahedronBufferGeometry":
                                    case "IcosahedronGeometry":
                                    case "IcosahedronBufferGeometry":
                                    case "OctahedronGeometry":
                                    case "OctahedronBufferGeometry":
                                    case "TetrahedronGeometry":
                                    case "TetrahedronBufferGeometry":
                                        o = new Nu[g.type](g.radius, g.detail);
                                        break;
                                    case "RingGeometry":
                                    case "RingBufferGeometry":
                                        o = new Nu[g.type](g.innerRadius, g.outerRadius, g.thetaSegments, g.phiSegments, g.thetaStart, g.thetaLength);
                                        break;
                                    case "TorusGeometry":
                                    case "TorusBufferGeometry":
                                        o = new Nu[g.type](g.radius, g.tube, g.radialSegments, g.tubularSegments, g.arc);
                                        break;
                                    case "TorusKnotGeometry":
                                    case "TorusKnotBufferGeometry":
                                        o = new Nu[g.type](g.radius, g.tube, g.tubularSegments, g.radialSegments, g.p, g.q);
                                        break;
                                    case "TubeGeometry":
                                    case "TubeBufferGeometry":
                                        o = new Nu[g.type]((new Wu[g.path.type]).fromJSON(g.path), g.tubularSegments, g.radius, g.radialSegments, g.closed);
                                        break;
                                    case "LatheGeometry":
                                    case "LatheBufferGeometry":
                                        o = new Nu[g.type](g.points, g.segments, g.phiStart, g.phiLength);
                                        break;
                                    case "PolyhedronGeometry":
                                    case "PolyhedronBufferGeometry":
                                        o = new Nu[g.type](g.vertices, g.indices, g.radius, g.details);
                                        break;
                                    case "ShapeGeometry":
                                    case "ShapeBufferGeometry":
                                        o = [];
                                        for (var c = 0, l = g.shapes.length; c < l; c++) {
                                            var h = b[g.shapes[c]];
                                            o.push(h)
                                        }
                                        o = new Nu[g.type](o, g.curveSegments);
                                        break;
                                    case "ExtrudeGeometry":
                                    case "ExtrudeBufferGeometry":
                                        for (o = [], c = 0, l = g.shapes.length; c < l; c++) h = b[g.shapes[c]], o.push(h);
                                        void 0 !== (c = g.options.extrudePath) && (g.options.extrudePath = (new Wu[c.type]).fromJSON(c)), o = new Nu[g.type](o, g.options);
                                        break;
                                    case "BufferGeometry":
                                    case "InstancedBufferGeometry":
                                        o = e.parse(g);
                                        break;
                                    case "Geometry":
                                        "THREE" in window && "LegacyJSONLoader" in THREE ? o = (new THREE.LegacyJSONLoader).parse(g, this.resourcePath).geometry : console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                                        break;
                                    default:
                                        console.warn('THREE.ObjectLoader: Unsupported geometry type "' + g.type + '"');
                                        continue
                                }
                                o.uuid = g.uuid, void 0 !== g.name && (o.name = g.name), !0 === o.isBufferGeometry && void 0 !== g.userData && (o.userData = g.userData), t[g.uuid] = o
                            }
                        return t
                    },
                    parseMaterials: function (a, b) {
                        var t = {},
                            e = {};
                        if (void 0 !== a) {
                            var n = new Pr;
                            n.setTextures(b), b = 0;
                            for (var r = a.length; b < r; b++) {
                                var g = a[b];
                                if ("MultiMaterial" === g.type) {
                                    for (var o = [], c = 0; c < g.materials.length; c++) {
                                        var l = g.materials[c];
                                        void 0 === t[l.uuid] && (t[l.uuid] = n.parse(l)), o.push(t[l.uuid])
                                    }
                                    e[g.uuid] = o
                                } else void 0 === t[g.uuid] && (t[g.uuid] = n.parse(g)), e[g.uuid] = t[g.uuid]
                            }
                        }
                        return e
                    },
                    parseAnimations: function (a) {
                        for (var b = [], t = 0; t < a.length; t++) {
                            var e = a[t],
                                n = Gi.parse(e);
                            void 0 !== e.uuid && (n.uuid = e.uuid), b.push(n)
                        }
                        return b
                    },
                    parseImages: function (a, b) {
                        function t(a) {
                            return e.manager.itemStart(a), r.load(a, (function () {
                                e.manager.itemEnd(a)
                            }), void 0, (function () {
                                e.manager.itemError(a), e.manager.itemEnd(a)
                            }))
                        }
                        var e = this,
                            n = {};
                        if (void 0 !== a && 0 < a.length) {
                            var r = new Ji(b = new ji(b));
                            r.setCrossOrigin(this.crossOrigin), b = 0;
                            for (var g = a.length; b < g; b++) {
                                var o = a[b],
                                    c = o.url;
                                if (Array.isArray(c)) {
                                    n[o.uuid] = [];
                                    for (var l = 0, h = c.length; l < h; l++) {
                                        var p = c[l];
                                        p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p) ? p : e.resourcePath + p, n[o.uuid].push(t(p))
                                    }
                                } else p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(o.url) ? o.url : e.resourcePath + o.url, n[o.uuid] = t(p)
                            }
                        }
                        return n
                    },
                    parseTextures: function (a, b) {
                        function t(a, b) {
                            return "number" == typeof a ? a : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", a), b[a])
                        }
                        var e = {};
                        if (void 0 !== a)
                            for (var n = 0, r = a.length; n < r; n++) {
                                var g = a[n];
                                void 0 === g.image && console.warn('THREE.ObjectLoader: No "image" specified for', g.uuid), void 0 === b[g.image] && console.warn("THREE.ObjectLoader: Undefined image", g.image);
                                var o = Array.isArray(b[g.image]) ? new Tt(b[g.image]) : new l(b[g.image]);
                                o.needsUpdate = !0, o.uuid = g.uuid, void 0 !== g.name && (o.name = g.name), void 0 !== g.mapping && (o.mapping = t(g.mapping, Xu)), void 0 !== g.offset && o.offset.fromArray(g.offset), void 0 !== g.repeat && o.repeat.fromArray(g.repeat), void 0 !== g.center && o.center.fromArray(g.center), void 0 !== g.rotation && (o.rotation = g.rotation), void 0 !== g.wrap && (o.wrapS = t(g.wrap[0], Zu), o.wrapT = t(g.wrap[1], Zu)), void 0 !== g.format && (o.format = g.format), void 0 !== g.type && (o.type = g.type), void 0 !== g.encoding && (o.encoding = g.encoding), void 0 !== g.minFilter && (o.minFilter = t(g.minFilter, Ju)), void 0 !== g.magFilter && (o.magFilter = t(g.magFilter, Ju)), void 0 !== g.anisotropy && (o.anisotropy = g.anisotropy), void 0 !== g.flipY && (o.flipY = g.flipY), void 0 !== g.premultiplyAlpha && (o.premultiplyAlpha = g.premultiplyAlpha), void 0 !== g.unpackAlignment && (o.unpackAlignment = g.unpackAlignment), e[g.uuid] = o
                            }
                        return e
                    },
                    parseObject: function (a, b, t) {
                        function e(a) {
                            return void 0 === b[a] && console.warn("THREE.ObjectLoader: Undefined geometry", a), b[a]
                        }

                        function n(a) {
                            if (void 0 !== a) {
                                if (Array.isArray(a)) {
                                    for (var b = [], e = 0, n = a.length; e < n; e++) {
                                        var r = a[e];
                                        void 0 === t[r] && console.warn("THREE.ObjectLoader: Undefined material", r), b.push(t[r])
                                    }
                                    return b
                                }
                                return void 0 === t[a] && console.warn("THREE.ObjectLoader: Undefined material", a), t[a]
                            }
                        }
                        switch (a.type) {
                            case "Scene":
                                var r = new x;
                                void 0 !== a.background && Number.isInteger(a.background) && (r.background = new A(a.background)), void 0 !== a.fog && ("Fog" === a.fog.type ? r.fog = new qe(a.fog.color, a.fog.near, a.fog.far) : "FogExp2" === a.fog.type && (r.fog = new Ye(a.fog.color, a.fog.density)));
                                break;
                            case "PerspectiveCamera":
                                r = new it(a.fov, a.aspect, a.near, a.far), void 0 !== a.focus && (r.focus = a.focus), void 0 !== a.zoom && (r.zoom = a.zoom), void 0 !== a.filmGauge && (r.filmGauge = a.filmGauge), void 0 !== a.filmOffset && (r.filmOffset = a.filmOffset), void 0 !== a.view && (r.view = Object.assign({}, a.view));
                                break;
                            case "OrthographicCamera":
                                r = new Sr(a.left, a.right, a.top, a.bottom, a.near, a.far), void 0 !== a.zoom && (r.zoom = a.zoom), void 0 !== a.view && (r.view = Object.assign({}, a.view));
                                break;
                            case "AmbientLight":
                                r = new Lr(a.color, a.intensity);
                                break;
                            case "DirectionalLight":
                                r = new Cr(a.color, a.intensity);
                                break;
                            case "PointLight":
                                r = new Dr(a.color, a.intensity, a.distance, a.decay);
                                break;
                            case "RectAreaLight":
                                r = new Rr(a.color, a.intensity, a.width, a.height);
                                break;
                            case "SpotLight":
                                r = new Er(a.color, a.intensity, a.distance, a.angle, a.penumbra, a.decay);
                                break;
                            case "HemisphereLight":
                                r = new xr(a.color, a.groundColor, a.intensity);
                                break;
                            case "SkinnedMesh":
                                console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                            case "Mesh":
                                r = e(a.geometry);
                                var g = n(a.material);
                                r = r.bones && 0 < r.bones.length ? new tn(r, g) : new Z(r, g);
                                break;
                            case "InstancedMesh":
                                r = e(a.geometry), g = n(a.material);
                                var o = a.instanceMatrix;
                                (r = new rn(r, g, a.count)).instanceMatrix = new N(new Float32Array(o.array), 16);
                                break;
                            case "LOD":
                                r = new Ke;
                                break;
                            case "Line":
                                r = new on(e(a.geometry), n(a.material), a.mode);
                                break;
                            case "LineLoop":
                                r = new un(e(a.geometry), n(a.material));
                                break;
                            case "LineSegments":
                                r = new sn(e(a.geometry), n(a.material));
                                break;
                            case "PointCloud":
                            case "Points":
                                r = new ln(e(a.geometry), n(a.material));
                                break;
                            case "Sprite":
                                r = new $e(n(a.material));
                                break;
                            case "Group":
                                r = new Ve;
                                break;
                            default:
                                r = new _
                        }
                        if (r.uuid = a.uuid, void 0 !== a.name && (r.name = a.name), void 0 !== a.matrix ? (r.matrix.fromArray(a.matrix), void 0 !== a.matrixAutoUpdate && (r.matrixAutoUpdate = a.matrixAutoUpdate), r.matrixAutoUpdate && r.matrix.decompose(r.position, r.quaternion, r.scale)) : (void 0 !== a.position && r.position.fromArray(a.position), void 0 !== a.rotation && r.rotation.fromArray(a.rotation), void 0 !== a.quaternion && r.quaternion.fromArray(a.quaternion), void 0 !== a.scale && r.scale.fromArray(a.scale)), void 0 !== a.castShadow && (r.castShadow = a.castShadow), void 0 !== a.receiveShadow && (r.receiveShadow = a.receiveShadow), a.shadow && (void 0 !== a.shadow.bias && (r.shadow.bias = a.shadow.bias), void 0 !== a.shadow.radius && (r.shadow.radius = a.shadow.radius), void 0 !== a.shadow.mapSize && r.shadow.mapSize.fromArray(a.shadow.mapSize), void 0 !== a.shadow.camera && (r.shadow.camera = this.parseObject(a.shadow.camera))), void 0 !== a.visible && (r.visible = a.visible), void 0 !== a.frustumCulled && (r.frustumCulled = a.frustumCulled), void 0 !== a.renderOrder && (r.renderOrder = a.renderOrder), void 0 !== a.userData && (r.userData = a.userData), void 0 !== a.layers && (r.layers.mask = a.layers), void 0 !== a.children)
                            for (o = a.children, g = 0; g < o.length; g++) r.add(this.parseObject(o[g], b, t));
                        if ("LOD" === a.type)
                            for (void 0 !== a.autoUpdate && (r.autoUpdate = a.autoUpdate), a = a.levels, o = 0; o < a.length; o++) {
                                g = a[o];
                                var c = r.getObjectByProperty("uuid", g.object);
                                void 0 !== c && r.addLevel(c, g.distance)
                            }
                        return r
                    }
                });
                var Xu = {
                        UVMapping: 300,
                        CubeReflectionMapping: 301,
                        CubeRefractionMapping: 302,
                        EquirectangularReflectionMapping: 303,
                        EquirectangularRefractionMapping: 304,
                        SphericalReflectionMapping: 305,
                        CubeUVReflectionMapping: 306,
                        CubeUVRefractionMapping: 307
                    },
                    Zu = {
                        RepeatWrapping: 1e3,
                        ClampToEdgeWrapping: 1001,
                        MirroredRepeatWrapping: 1002
                    },
                    Ju = {
                        NearestFilter: 1003,
                        NearestMipmapNearestFilter: 1004,
                        NearestMipmapLinearFilter: 1005,
                        LinearFilter: 1006,
                        LinearMipmapNearestFilter: 1007,
                        LinearMipmapLinearFilter: 1008
                    };
                Br.prototype = Object.assign(Object.create(Wi.prototype), {
                    constructor: Br,
                    setOptions: function (a) {
                        return this.options = a, this
                    },
                    load: function (a, b, t, e) {
                        void 0 === a && (a = ""), void 0 !== this.path && (a = this.path + a), a = this.manager.resolveURL(a);
                        var n = this,
                            r = ku.get(a);
                        if (void 0 !== r) return n.manager.itemStart(a), setTimeout((function () {
                            b && b(r), n.manager.itemEnd(a)
                        }), 0), r;
                        fetch(a).then((function (a) {
                            return a.blob()
                        })).then((function (a) {
                            return void 0 === n.options ? createImageBitmap(a) : createImageBitmap(a, n.options)
                        })).then((function (t) {
                            ku.add(a, t), b && b(t), n.manager.itemEnd(a)
                        })).catch((function (b) {
                            e && e(b), n.manager.itemError(a), n.manager.itemEnd(a)
                        })), n.manager.itemStart(a)
                    }
                }), Object.assign(kr.prototype, {
                    moveTo: function (a, b) {
                        return this.currentPath = new vr, this.subPaths.push(this.currentPath), this.currentPath.moveTo(a, b), this
                    },
                    lineTo: function (a, b) {
                        return this.currentPath.lineTo(a, b), this
                    },
                    quadraticCurveTo: function (a, b, t, e) {
                        return this.currentPath.quadraticCurveTo(a, b, t, e), this
                    },
                    bezierCurveTo: function (a, b, t, e, n, r) {
                        return this.currentPath.bezierCurveTo(a, b, t, e, n, r), this
                    },
                    splineThru: function (a) {
                        return this.currentPath.splineThru(a), this
                    },
                    toShapes: function (a, b) {
                        function t(a) {
                            for (var b = [], t = 0, e = a.length; t < e; t++) {
                                var n = a[t],
                                    r = new yr;
                                r.curves = n.curves, b.push(r)
                            }
                            return b
                        }

                        function e(a, b) {
                            for (var t = b.length, e = !1, n = t - 1, r = 0; r < t; n = r++) {
                                var g = b[n],
                                    o = b[r],
                                    c = o.x - g.x,
                                    l = o.y - g.y;
                                if (Math.abs(l) > Number.EPSILON) {
                                    if (0 > l && (g = b[r], c = -c, o = b[n], l = -l), !(a.y < g.y || a.y > o.y))
                                        if (a.y === g.y) {
                                            if (a.x === g.x) return !0
                                        } else {
                                            if (0 == (n = l * (a.x - g.x) - c * (a.y - g.y))) return !0;
                                            0 > n || (e = !e)
                                        }
                                } else if (a.y === g.y && (o.x <= a.x && a.x <= g.x || g.x <= a.x && a.x <= o.x)) return !0
                            }
                            return e
                        }
                        var n = Ou.isClockWise,
                            r = this.subPaths;
                        if (0 === r.length) return [];
                        if (!0 === b) return t(r);
                        if (b = [], 1 === r.length) {
                            var g = r[0],
                                o = new yr;
                            return o.curves = g.curves, b.push(o), b
                        }
                        var c = !n(r[0].getPoints());
                        c = a ? !c : c, o = [];
                        var l = [],
                            h = [],
                            p = 0;
                        l[p] = void 0, h[p] = [];
                        for (var q = 0, d = r.length; q < d; q++) {
                            var f = (g = r[q]).getPoints(),
                                u = n(f);
                            (u = a ? !u : u) ? (!c && l[p] && p++, l[p] = {
                                s: new yr,
                                p: f
                            }, l[p].s.curves = g.curves, c && p++, h[p] = []) : h[p].push({
                                h: g,
                                p: f[0]
                            })
                        }
                        if (!l[0]) return t(r);
                        if (1 < l.length) {
                            for (q = !1, a = [], n = 0, r = l.length; n < r; n++) o[n] = [];
                            for (n = 0, r = l.length; n < r; n++)
                                for (g = h[n], u = 0; u < g.length; u++) {
                                    for (c = g[u], p = !0, f = 0; f < l.length; f++) e(c.p, l[f].p) && (n !== f && a.push({
                                        froms: n,
                                        tos: f,
                                        hole: u
                                    }), p ? (p = !1, o[f].push(c)) : q = !0);
                                    p && o[n].push(c)
                                }
                            0 < a.length && (q || (h = o))
                        }
                        for (q = 0, n = l.length; q < n; q++)
                            for (o = l[q].s, b.push(o), r = 0, g = (a = h[q]).length; r < g; r++) o.holes.push(a[r].h);
                        return b
                    }
                }), Object.assign(zr.prototype, {
                    isFont: !0,
                    generateShapes: function (a, b) {
                        void 0 === b && (b = 100);
                        var t = [],
                            e = b;
                        b = this.data;
                        var n = Array.from ? Array.from(a) : String(a).split("");
                        e /= b.resolution;
                        var r = (b.boundingBox.yMax - b.boundingBox.yMin + b.underlineThickness) * e;
                        a = [];
                        for (var g = 0, o = 0, c = 0; c < n.length; c++) {
                            var l = n[c];
                            if ("\n" === l) g = 0, o -= r;
                            else {
                                var h = l;
                                l = e;
                                var p = g,
                                    q = o,
                                    d = b,
                                    f = d.glyphs[h] || d.glyphs["?"];
                                if (f) {
                                    if (h = new kr, f.o)
                                        for (var u = 0, m = (d = f._cachedOutline || (f._cachedOutline = f.o.split(" "))).length; u < m;) switch (d[u++]) {
                                            case "m":
                                                var v = d[u++] * l + p,
                                                    y = d[u++] * l + q;
                                                h.moveTo(v, y);
                                                break;
                                            case "l":
                                                v = d[u++] * l + p, y = d[u++] * l + q, h.lineTo(v, y);
                                                break;
                                            case "q":
                                                var _ = d[u++] * l + p,
                                                    x = d[u++] * l + q,
                                                    w = d[u++] * l + p,
                                                    M = d[u++] * l + q;
                                                h.quadraticCurveTo(w, M, _, x);
                                                break;
                                            case "b":
                                                _ = d[u++] * l + p, x = d[u++] * l + q, w = d[u++] * l + p, M = d[u++] * l + q, v = d[u++] * l + p, y = d[u++] * l + q, h.bezierCurveTo(w, M, v, y, _, x)
                                        }
                                    l = {
                                        offsetX: f.ha * l,
                                        path: h
                                    }
                                } else console.error('THREE.Font: character "' + h + '" does not exists in font family ' + d.familyName + "."), l = void 0;
                                g += l.offsetX, a.push(l.path)
                            }
                        }
                        for (b = 0, n = a.length; b < n; b++) Array.prototype.push.apply(t, a[b].toShapes());
                        return t
                    }
                }), Ur.prototype = Object.assign(Object.create(Wi.prototype), {
                    constructor: Ur,
                    load: function (a, b, t, e) {
                        var n = this,
                            r = new Yi(this.manager);
                        r.setPath(this.path), r.load(a, (function (a) {
                            try {
                                var t = JSON.parse(a)
                            } catch (e) {
                                console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), t = JSON.parse(a.substring(65, a.length - 2))
                            }
                            a = n.parse(t), b && b(a)
                        }), t, e)
                    },
                    parse: function (a) {
                        return new zr(a)
                    }
                });
                var $u, Qu = {
                    getContext: function () {
                        return void 0 === $u && ($u = new(window.AudioContext || window.webkitAudioContext)), $u
                    },
                    setContext: function (a) {
                        $u = a
                    }
                };
                Hr.prototype = Object.assign(Object.create(Wi.prototype), {
                    constructor: Hr,
                    load: function (a, b, t, e) {
                        var n = new Yi(this.manager);
                        n.setResponseType("arraybuffer"), n.setPath(this.path), n.load(a, (function (a) {
                            a = a.slice(0), Qu.getContext().decodeAudioData(a, (function (a) {
                                b(a)
                            }))
                        }), t, e)
                    }
                }), Object.assign(Gr.prototype, {
                    isSphericalHarmonics3: !0,
                    set: function (a) {
                        for (var b = 0; 9 > b; b++) this.coefficients[b].copy(a[b]);
                        return this
                    },
                    zero: function () {
                        for (var a = 0; 9 > a; a++) this.coefficients[a].set(0, 0, 0);
                        return this
                    },
                    getAt: function (a, b) {
                        var t = a.x,
                            e = a.y;
                        a = a.z;
                        var n = this.coefficients;
                        return b.copy(n[0]).multiplyScalar(.282095), b.addScale(n[1], .488603 * e), b.addScale(n[2], .488603 * a), b.addScale(n[3], .488603 * t), b.addScale(n[4], 1.092548 * t * e), b.addScale(n[5], 1.092548 * e * a), b.addScale(n[6], .315392 * (3 * a * a - 1)), b.addScale(n[7], 1.092548 * t * a), b.addScale(n[8], .546274 * (t * t - e * e)), b
                    },
                    getIrradianceAt: function (a, b) {
                        var t = a.x,
                            e = a.y;
                        a = a.z;
                        var n = this.coefficients;
                        return b.copy(n[0]).multiplyScalar(.886227), b.addScale(n[1], 1.023328 * e), b.addScale(n[2], 1.023328 * a), b.addScale(n[3], 1.023328 * t), b.addScale(n[4], .858086 * t * e), b.addScale(n[5], .858086 * e * a), b.addScale(n[6], .743125 * a * a - .247708), b.addScale(n[7], .858086 * t * a), b.addScale(n[8], .429043 * (t * t - e * e)), b
                    },
                    add: function (a) {
                        for (var b = 0; 9 > b; b++) this.coefficients[b].add(a.coefficients[b]);
                        return this
                    },
                    scale: function (a) {
                        for (var b = 0; 9 > b; b++) this.coefficients[b].multiplyScalar(a);
                        return this
                    },
                    lerp: function (a, b) {
                        for (var t = 0; 9 > t; t++) this.coefficients[t].lerp(a.coefficients[t], b);
                        return this
                    },
                    equals: function (a) {
                        for (var b = 0; 9 > b; b++)
                            if (!this.coefficients[b].equals(a.coefficients[b])) return !1;
                        return !0
                    },
                    copy: function (a) {
                        return this.set(a.coefficients)
                    },
                    clone: function () {
                        return (new this.constructor).copy(this)
                    },
                    fromArray: function (a, b) {
                        void 0 === b && (b = 0);
                        for (var t = this.coefficients, e = 0; 9 > e; e++) t[e].fromArray(a, b + 3 * e);
                        return this
                    },
                    toArray: function (a, b) {
                        void 0 === a && (a = []), void 0 === b && (b = 0);
                        for (var t = this.coefficients, e = 0; 9 > e; e++) t[e].toArray(a, b + 3 * e);
                        return a
                    }
                }), Object.assign(Gr, {
                    getBasisAt: function (a, b) {
                        var t = a.x,
                            e = a.y;
                        a = a.z, b[0] = .282095, b[1] = .488603 * e, b[2] = .488603 * a, b[3] = .488603 * t, b[4] = 1.092548 * t * e, b[5] = 1.092548 * e * a, b[6] = .315392 * (3 * a * a - 1), b[7] = 1.092548 * t * a, b[8] = .546274 * (t * t - e * e)
                    }
                }), Vr.prototype = Object.assign(Object.create(_r.prototype), {
                    constructor: Vr,
                    isLightProbe: !0,
                    copy: function (a) {
                        return _r.prototype.copy.call(this, a), this.sh.copy(a.sh), this.intensity = a.intensity, this
                    },
                    toJSON: function (a) {
                        return _r.prototype.toJSON.call(this, a)
                    }
                }), jr.prototype = Object.assign(Object.create(Vr.prototype), {
                    constructor: jr,
                    isHemisphereLightProbe: !0,
                    copy: function (a) {
                        return Vr.prototype.copy.call(this, a), this
                    },
                    toJSON: function (a) {
                        return Vr.prototype.toJSON.call(this, a)
                    }
                }), Wr.prototype = Object.assign(Object.create(Vr.prototype), {
                    constructor: Wr,
                    isAmbientLightProbe: !0,
                    copy: function (a) {
                        return Vr.prototype.copy.call(this, a), this
                    },
                    toJSON: function (a) {
                        return Vr.prototype.toJSON.call(this, a)
                    }
                });
                var Ku = new m,
                    tc = new m;
                Object.assign(Yr.prototype, {
                    update: function (a) {
                        var b = this._cache;
                        if (b.focus !== a.focus || b.fov !== a.fov || b.aspect !== a.aspect * this.aspect || b.near !== a.near || b.far !== a.far || b.zoom !== a.zoom || b.eyeSep !== this.eyeSep) {
                            b.focus = a.focus, b.fov = a.fov, b.aspect = a.aspect * this.aspect, b.near = a.near, b.far = a.far, b.zoom = a.zoom, b.eyeSep = this.eyeSep;
                            var t = a.projectionMatrix.clone(),
                                e = b.eyeSep / 2,
                                n = e * b.near / b.focus,
                                r = b.near * Math.tan(Va.DEG2RAD * b.fov * .5) / b.zoom;
                            tc.elements[12] = -e, Ku.elements[12] = e, e = -r * b.aspect + n;
                            var g = r * b.aspect + n;
                            t.elements[0] = 2 * b.near / (g - e), t.elements[8] = (g + e) / (g - e), this.cameraL.projectionMatrix.copy(t), e = -r * b.aspect - n, g = r * b.aspect - n, t.elements[0] = 2 * b.near / (g - e), t.elements[8] = (g + e) / (g - e), this.cameraR.projectionMatrix.copy(t)
                        }
                        this.cameraL.matrixWorld.copy(a.matrixWorld).multiply(tc), this.cameraR.matrixWorld.copy(a.matrixWorld).multiply(Ku)
                    }
                }), Object.assign(qr.prototype, {
                    start: function () {
                        this.oldTime = this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.elapsedTime = 0, this.running = !0
                    },
                    stop: function () {
                        this.getElapsedTime(), this.autoStart = this.running = !1
                    },
                    getElapsedTime: function () {
                        return this.getDelta(), this.elapsedTime
                    },
                    getDelta: function () {
                        var a = 0;
                        if (this.autoStart && !this.running) return this.start(), 0;
                        if (this.running) {
                            var b = ("undefined" == typeof performance ? Date : performance).now();
                            a = (b - this.oldTime) / 1e3, this.oldTime = b, this.elapsedTime += a
                        }
                        return a
                    }
                });
                var ec = new o,
                    nc = new r,
                    ic = new o,
                    rc = new o;
                Xr.prototype = Object.assign(Object.create(_.prototype), {
                    constructor: Xr,
                    getInput: function () {
                        return this.gain
                    },
                    removeFilter: function () {
                        return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
                    },
                    getFilter: function () {
                        return this.filter
                    },
                    setFilter: function (a) {
                        return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = a, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
                    },
                    getMasterVolume: function () {
                        return this.gain.gain.value
                    },
                    setMasterVolume: function (a) {
                        return this.gain.gain.setTargetAtTime(a, this.context.currentTime, .01), this
                    },
                    updateMatrixWorld: function (a) {
                        _.prototype.updateMatrixWorld.call(this, a), a = this.context.listener;
                        var b = this.up;
                        if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(ec, nc, ic), rc.set(0, 0, -1).applyQuaternion(nc), a.positionX) {
                            var t = this.context.currentTime + this.timeDelta;
                            a.positionX.linearRampToValueAtTime(ec.x, t), a.positionY.linearRampToValueAtTime(ec.y, t), a.positionZ.linearRampToValueAtTime(ec.z, t), a.forwardX.linearRampToValueAtTime(rc.x, t), a.forwardY.linearRampToValueAtTime(rc.y, t), a.forwardZ.linearRampToValueAtTime(rc.z, t), a.upX.linearRampToValueAtTime(b.x, t), a.upY.linearRampToValueAtTime(b.y, t), a.upZ.linearRampToValueAtTime(b.z, t)
                        } else a.setPosition(ec.x, ec.y, ec.z), a.setOrientation(rc.x, rc.y, rc.z, b.x, b.y, b.z)
                    }
                }), Zr.prototype = Object.assign(Object.create(_.prototype), {
                    constructor: Zr,
                    getOutput: function () {
                        return this.gain
                    },
                    setNodeSource: function (a) {
                        return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = a, this.connect(), this
                    },
                    setMediaElementSource: function (a) {
                        return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(a), this.connect(), this
                    },
                    setMediaStreamSource: function (a) {
                        return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(a), this.connect(), this
                    },
                    setBuffer: function (a) {
                        return this.buffer = a, this.sourceType = "buffer", this.autoplay && this.play(), this
                    },
                    play: function (a) {
                        if (void 0 === a && (a = 0), !0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing.");
                        else {
                            if (!1 !== this.hasPlaybackControl) return this._startedAt = this.context.currentTime + a, (a = this.context.createBufferSource()).buffer = this.buffer, a.loop = this.loop, a.loopStart = this.loopStart, a.loopEnd = this.loopEnd, a.onended = this.onEnded.bind(this), a.start(this._startedAt, this._pausedAt + this.offset, this.duration), this.isPlaying = !0, this.source = a, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
                            console.warn("THREE.Audio: this Audio has no playback control.")
                        }
                    },
                    pause: function () {
                        if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._pausedAt = (this.context.currentTime - this._startedAt) * this.playbackRate, this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    },
                    stop: function () {
                        if (!1 !== this.hasPlaybackControl) return this._pausedAt = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    },
                    connect: function () {
                        if (0 < this.filters.length) {
                            this.source.connect(this.filters[0]);
                            for (var a = 1, b = this.filters.length; a < b; a++) this.filters[a - 1].connect(this.filters[a]);
                            this.filters[this.filters.length - 1].connect(this.getOutput())
                        } else this.source.connect(this.getOutput());
                        return this
                    },
                    disconnect: function () {
                        if (0 < this.filters.length) {
                            this.source.disconnect(this.filters[0]);
                            for (var a = 1, b = this.filters.length; a < b; a++) this.filters[a - 1].disconnect(this.filters[a]);
                            this.filters[this.filters.length - 1].disconnect(this.getOutput())
                        } else this.source.disconnect(this.getOutput());
                        return this
                    },
                    getFilters: function () {
                        return this.filters
                    },
                    setFilters: function (a) {
                        return a || (a = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = a, this.connect()) : this.filters = a, this
                    },
                    setDetune: function (a) {
                        if (this.detune = a, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                    },
                    getDetune: function () {
                        return this.detune
                    },
                    getFilter: function () {
                        return this.getFilters()[0]
                    },
                    setFilter: function (a) {
                        return this.setFilters(a ? [a] : [])
                    },
                    setPlaybackRate: function (a) {
                        if (!1 !== this.hasPlaybackControl) return this.playbackRate = a, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    },
                    getPlaybackRate: function () {
                        return this.playbackRate
                    },
                    onEnded: function () {
                        this.isPlaying = !1
                    },
                    getLoop: function () {
                        return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                    },
                    setLoop: function (a) {
                        if (!1 !== this.hasPlaybackControl) return this.loop = a, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    },
                    setLoopStart: function (a) {
                        return this.loopStart = a, this
                    },
                    setLoopEnd: function (a) {
                        return this.loopEnd = a, this
                    },
                    getVolume: function () {
                        return this.gain.gain.value
                    },
                    setVolume: function (a) {
                        return this.gain.gain.setTargetAtTime(a, this.context.currentTime, .01), this
                    }
                });
                var ac = new o,
                    oc = new r,
                    sc = new o,
                    uc = new o;
                Jr.prototype = Object.assign(Object.create(Zr.prototype), {
                    constructor: Jr,
                    getOutput: function () {
                        return this.panner
                    },
                    getRefDistance: function () {
                        return this.panner.refDistance
                    },
                    setRefDistance: function (a) {
                        return this.panner.refDistance = a, this
                    },
                    getRolloffFactor: function () {
                        return this.panner.rolloffFactor
                    },
                    setRolloffFactor: function (a) {
                        return this.panner.rolloffFactor = a, this
                    },
                    getDistanceModel: function () {
                        return this.panner.distanceModel
                    },
                    setDistanceModel: function (a) {
                        return this.panner.distanceModel = a, this
                    },
                    getMaxDistance: function () {
                        return this.panner.maxDistance
                    },
                    setMaxDistance: function (a) {
                        return this.panner.maxDistance = a, this
                    },
                    setDirectionalCone: function (a, b, t) {
                        return this.panner.coneInnerAngle = a, this.panner.coneOuterAngle = b, this.panner.coneOuterGain = t, this
                    },
                    updateMatrixWorld: function (a) {
                        if (_.prototype.updateMatrixWorld.call(this, a), !0 !== this.hasPlaybackControl || !1 !== this.isPlaying)
                            if (this.matrixWorld.decompose(ac, oc, sc), uc.set(0, 0, 1).applyQuaternion(oc), (a = this.panner).positionX) {
                                var b = this.context.currentTime + this.listener.timeDelta;
                                a.positionX.linearRampToValueAtTime(ac.x, b), a.positionY.linearRampToValueAtTime(ac.y, b), a.positionZ.linearRampToValueAtTime(ac.z, b), a.orientationX.linearRampToValueAtTime(uc.x, b), a.orientationY.linearRampToValueAtTime(uc.y, b), a.orientationZ.linearRampToValueAtTime(uc.z, b)
                            } else a.setPosition(ac.x, ac.y, ac.z), a.setOrientation(uc.x, uc.y, uc.z)
                    }
                }), Object.assign($r.prototype, {
                    getFrequencyData: function () {
                        return this.analyser.getByteFrequencyData(this.data), this.data
                    },
                    getAverageFrequency: function () {
                        for (var a = 0, b = this.getFrequencyData(), t = 0; t < b.length; t++) a += b[t];
                        return a / b.length
                    }
                }), Object.assign(Qr.prototype, {
                    accumulate: function (a, b) {
                        var t = this.buffer,
                            e = this.valueSize;
                        a = a * e + e;
                        var n = this.cumulativeWeight;
                        if (0 === n) {
                            for (n = 0; n !== e; ++n) t[a + n] = t[n];
                            n = b
                        } else n += b, this._mixBufferRegion(t, a, 0, b / n, e);
                        this.cumulativeWeight = n
                    },
                    apply: function (a) {
                        var b = this.valueSize,
                            t = this.buffer;
                        a = a * b + b;
                        var e = this.cumulativeWeight,
                            n = this.binding;
                        this.cumulativeWeight = 0, 1 > e && this._mixBufferRegion(t, a, 3 * b, 1 - e, b), e = b;
                        for (var r = b + b; e !== r; ++e)
                            if (t[e] !== t[e + b]) {
                                n.setValue(t, a);
                                break
                            }
                    },
                    saveOriginalState: function () {
                        var a = this.buffer,
                            b = this.valueSize,
                            t = 3 * b;
                        this.binding.getValue(a, t);
                        for (var e = b; e !== t; ++e) a[e] = a[t + e % b];
                        this.cumulativeWeight = 0
                    },
                    restoreOriginalState: function () {
                        this.binding.setValue(this.buffer, 3 * this.valueSize)
                    },
                    _select: function (a, b, t, e, n) {
                        if (.5 <= e)
                            for (e = 0; e !== n; ++e) a[b + e] = a[t + e]
                    },
                    _slerp: function (a, b, t, e) {
                        r.slerpFlat(a, b, a, b, a, t, e)
                    },
                    _lerp: function (a, b, t, e, n) {
                        for (var r = 1 - e, g = 0; g !== n; ++g) {
                            var o = b + g;
                            a[o] = a[o] * r + a[t + g] * e
                        }
                    }
                });
                var dl = /[\[\]\.:\/]/g,
                    cc = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
                    lc = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                    hc = /(WCOD+)?/.source.replace("WCOD", cc),
                    dc = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                    pc = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                    fc = new RegExp("^" + lc + hc + dc + pc + "$"),
                    mc = ["material", "materials", "bones"];
                Object.assign(Kr.prototype, {
                    getValue: function (a, b) {
                        this.bind();
                        var t = this._bindings[this._targetGroup.nCachedObjects_];
                        void 0 !== t && t.getValue(a, b)
                    },
                    setValue: function (a, b) {
                        for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].setValue(a, b)
                    },
                    bind: function () {
                        for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, t = a.length; b !== t; ++b) a[b].bind()
                    },
                    unbind: function () {
                        for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, t = a.length; b !== t; ++b) a[b].unbind()
                    }
                }), Object.assign(ta, {
                    Composite: Kr,
                    create: function (a, b, t) {
                        return a && a.isAnimationObjectGroup ? new ta.Composite(a, b, t) : new ta(a, b, t)
                    },
                    sanitizeNodeName: function (a) {
                        return a.replace(/\s/g, "_").replace(dl, "")
                    },
                    parseTrackName: function (a) {
                        var b = fc.exec(a);
                        if (!b) throw Error("PropertyBinding: Cannot parse trackName: " + a);
                        var t = (b = {
                            nodeName: b[2],
                            objectName: b[3],
                            objectIndex: b[4],
                            propertyName: b[5],
                            propertyIndex: b[6]
                        }).nodeName && b.nodeName.lastIndexOf(".");
                        if (void 0 !== t && -1 !== t) {
                            var e = b.nodeName.substring(t + 1); - 1 !== mc.indexOf(e) && (b.nodeName = b.nodeName.substring(0, t), b.objectName = e)
                        }
                        if (null === b.propertyName || 0 === b.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + a);
                        return b
                    },
                    findNode: function (a, b) {
                        if (!b || "" === b || "root" === b || "." === b || -1 === b || b === a.name || b === a.uuid) return a;
                        if (a.skeleton) {
                            var t = a.skeleton.getBoneByName(b);
                            if (void 0 !== t) return t
                        }
                        if (a.children) {
                            var e = function (a) {
                                for (var t = 0; t < a.length; t++) {
                                    var n = a[t];
                                    if (n.name === b || n.uuid === b || (n = e(n.children))) return n
                                }
                                return null
                            };
                            if (a = e(a.children)) return a
                        }
                        return null
                    }
                }), Object.assign(ta.prototype, {
                    _getValue_unavailable: function () {},
                    _setValue_unavailable: function () {},
                    BindingType: {
                        Direct: 0,
                        EntireArray: 1,
                        ArrayElement: 2,
                        HasFromToArray: 3
                    },
                    Versioning: {
                        None: 0,
                        NeedsUpdate: 1,
                        MatrixWorldNeedsUpdate: 2
                    },
                    GetterByBindingType: [function (a, b) {
                        a[b] = this.node[this.propertyName]
                    }, function (a, b) {
                        for (var t = this.resolvedProperty, e = 0, n = t.length; e !== n; ++e) a[b++] = t[e]
                    }, function (a, b) {
                        a[b] = this.resolvedProperty[this.propertyIndex]
                    }, function (a, b) {
                        this.resolvedProperty.toArray(a, b)
                    }],
                    SetterByBindingTypeAndVersioning: [
                        [function (a, b) {
                            this.targetObject[this.propertyName] = a[b]
                        }, function (a, b) {
                            this.targetObject[this.propertyName] = a[b], this.targetObject.needsUpdate = !0
                        }, function (a, b) {
                            this.targetObject[this.propertyName] = a[b], this.targetObject.matrixWorldNeedsUpdate = !0
                        }],
                        [function (a, b) {
                            for (var t = this.resolvedProperty, e = 0, n = t.length; e !== n; ++e) t[e] = a[b++]
                        }, function (a, b) {
                            for (var t = this.resolvedProperty, e = 0, n = t.length; e !== n; ++e) t[e] = a[b++];
                            this.targetObject.needsUpdate = !0
                        }, function (a, b) {
                            for (var t = this.resolvedProperty, e = 0, n = t.length; e !== n; ++e) t[e] = a[b++];
                            this.targetObject.matrixWorldNeedsUpdate = !0
                        }],
                        [function (a, b) {
                            this.resolvedProperty[this.propertyIndex] = a[b]
                        }, function (a, b) {
                            this.resolvedProperty[this.propertyIndex] = a[b], this.targetObject.needsUpdate = !0
                        }, function (a, b) {
                            this.resolvedProperty[this.propertyIndex] = a[b], this.targetObject.matrixWorldNeedsUpdate = !0
                        }],
                        [function (a, b) {
                            this.resolvedProperty.fromArray(a, b)
                        }, function (a, b) {
                            this.resolvedProperty.fromArray(a, b), this.targetObject.needsUpdate = !0
                        }, function (a, b) {
                            this.resolvedProperty.fromArray(a, b), this.targetObject.matrixWorldNeedsUpdate = !0
                        }]
                    ],
                    getValue: function (a, b) {
                        this.bind(), this.getValue(a, b)
                    },
                    setValue: function (a, b) {
                        this.bind(), this.setValue(a, b)
                    },
                    bind: function () {
                        var a = this.node,
                            b = this.parsedPath,
                            t = b.objectName,
                            e = b.propertyName,
                            n = b.propertyIndex;
                        if (a || (this.node = a = ta.findNode(this.rootNode, b.nodeName) || this.rootNode), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, a) {
                            if (t) {
                                var r = b.objectIndex;
                                switch (t) {
                                    case "materials":
                                        if (!a.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                        if (!a.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                        a = a.material.materials;
                                        break;
                                    case "bones":
                                        if (!a.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                        for (a = a.skeleton.bones, t = 0; t < a.length; t++)
                                            if (a[t].name === r) {
                                                r = t;
                                                break
                                            } break;
                                    default:
                                        if (void 0 === a[t]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                        a = a[t]
                                }
                                if (void 0 !== r) {
                                    if (void 0 === a[r]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, a);
                                    a = a[r]
                                }
                            }
                            if (void 0 === (r = a[e])) console.error("THREE.PropertyBinding: Trying to update property for track: " + b.nodeName + "." + e + " but it wasn't found.", a);
                            else {
                                if (b = this.Versioning.None, this.targetObject = a, void 0 !== a.needsUpdate ? b = this.Versioning.NeedsUpdate : void 0 !== a.matrixWorldNeedsUpdate && (b = this.Versioning.MatrixWorldNeedsUpdate), t = this.BindingType.Direct, void 0 !== n) {
                                    if ("morphTargetInfluences" === e) {
                                        if (!a.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                        if (a.geometry.isBufferGeometry) {
                                            if (!a.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                            for (t = 0; t < this.node.geometry.morphAttributes.position.length; t++)
                                                if (a.geometry.morphAttributes.position[t].name === n) {
                                                    n = t;
                                                    break
                                                }
                                        } else {
                                            if (!a.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                            for (t = 0; t < this.node.geometry.morphTargets.length; t++)
                                                if (a.geometry.morphTargets[t].name === n) {
                                                    n = t;
                                                    break
                                                }
                                        }
                                    }
                                    t = this.BindingType.ArrayElement, this.resolvedProperty = r, this.propertyIndex = n
                                } else void 0 !== r.fromArray && void 0 !== r.toArray ? (t = this.BindingType.HasFromToArray, this.resolvedProperty = r) : Array.isArray(r) ? (t = this.BindingType.EntireArray, this.resolvedProperty = r) : this.propertyName = e;
                                this.getValue = this.GetterByBindingType[t], this.setValue = this.SetterByBindingTypeAndVersioning[t][b]
                            }
                        } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
                    },
                    unbind: function () {
                        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                    }
                }), Object.assign(ta.prototype, {
                    _getValue_unbound: ta.prototype.getValue,
                    _setValue_unbound: ta.prototype.setValue
                }), Object.assign(ea.prototype, {
                    isAnimationObjectGroup: !0,
                    add: function () {
                        for (var a = this._objects, b = a.length, t = this.nCachedObjects_, e = this._indicesByUUID, n = this._paths, r = this._parsedPaths, g = this._bindings, o = g.length, c = void 0, l = 0, h = arguments.length; l !== h; ++l) {
                            var p = arguments[l],
                                q = p.uuid,
                                d = e[q];
                            if (void 0 === d) {
                                d = b++, e[q] = d, a.push(p), q = 0;
                                for (var f = o; q !== f; ++q) g[q].push(new ta(p, n[q], r[q]))
                            } else if (d < t) {
                                c = a[d];
                                var u = --t;
                                for (e[(f = a[u]).uuid] = d, a[d] = f, e[q] = u, a[u] = p, q = 0, f = o; q !== f; ++q) {
                                    var m = g[q],
                                        v = m[d];
                                    m[d] = m[u], void 0 === v && (v = new ta(p, n[q], r[q])), m[u] = v
                                }
                            } else a[d] !== c && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                        }
                        this.nCachedObjects_ = t
                    },
                    remove: function () {
                        for (var a = this._objects, b = this.nCachedObjects_, t = this._indicesByUUID, e = this._bindings, n = e.length, r = 0, g = arguments.length; r !== g; ++r) {
                            var o = arguments[r],
                                c = o.uuid,
                                l = t[c];
                            if (void 0 !== l && l >= b) {
                                var h = b++,
                                    p = a[h];
                                for (t[p.uuid] = l, a[l] = p, t[c] = h, a[h] = o, o = 0, c = n; o !== c; ++o) {
                                    var q = (p = e[o])[l];
                                    p[l] = p[h], p[h] = q
                                }
                            }
                        }
                        this.nCachedObjects_ = b
                    },
                    uncache: function () {
                        for (var a = this._objects, b = a.length, t = this.nCachedObjects_, e = this._indicesByUUID, n = this._bindings, r = n.length, g = 0, o = arguments.length; g !== o; ++g) {
                            var c = arguments[g].uuid,
                                l = e[c];
                            if (void 0 !== l)
                                if (delete e[c], l < t) {
                                    var h = a[c = --t],
                                        p = --b,
                                        q = a[p];
                                    for (e[h.uuid] = l, a[l] = h, e[q.uuid] = c, a[c] = q, a.pop(), h = 0, q = r; h !== q; ++h) {
                                        var d = n[h],
                                            f = d[p];
                                        d[l] = d[c], d[c] = f, d.pop()
                                    }
                                } else
                                    for (e[(q = a[p = --b]).uuid] = l, a[l] = q, a.pop(), h = 0, q = r; h !== q; ++h)(d = n[h])[l] = d[p], d.pop()
                        }
                        this.nCachedObjects_ = t
                    },
                    subscribe_: function (a, b) {
                        var t = this._bindingsIndicesByPath,
                            e = t[a],
                            n = this._bindings;
                        if (void 0 !== e) return n[e];
                        var r = this._paths,
                            g = this._parsedPaths,
                            o = this._objects,
                            c = this.nCachedObjects_,
                            l = Array(o.length);
                        for (e = n.length, t[a] = e, r.push(a), g.push(b), n.push(l), t = c, e = o.length; t !== e; ++t) l[t] = new ta(o[t], a, b);
                        return l
                    },
                    unsubscribe_: function (a) {
                        var b = this._bindingsIndicesByPath,
                            t = b[a];
                        if (void 0 !== t) {
                            var e = this._paths,
                                n = this._parsedPaths,
                                r = this._bindings,
                                g = r.length - 1,
                                o = r[g];
                            b[a[g]] = t, r[t] = o, r.pop(), n[t] = n[g], n.pop(), e[t] = e[g], e.pop()
                        }
                    }
                }), Object.assign(li.prototype, {
                    play: function () {
                        return this._mixer._activateAction(this), this
                    },
                    stop: function () {
                        return this._mixer._deactivateAction(this), this.reset()
                    },
                    reset: function () {
                        return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                    },
                    isRunning: function () {
                        return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                    },
                    isScheduled: function () {
                        return this._mixer._isActiveAction(this)
                    },
                    startAt: function (a) {
                        return this._startTime = a, this
                    },
                    setLoop: function (a, b) {
                        return this.loop = a, this.repetitions = b, this
                    },
                    setEffectiveWeight: function (a) {
                        return this.weight = a, this._effectiveWeight = this.enabled ? a : 0, this.stopFading()
                    },
                    getEffectiveWeight: function () {
                        return this._effectiveWeight
                    },
                    fadeIn: function (a) {
                        return this._scheduleFading(a, 0, 1)
                    },
                    fadeOut: function (a) {
                        return this._scheduleFading(a, 1, 0)
                    },
                    crossFadeFrom: function (a, b, t) {
                        if (a.fadeOut(b), this.fadeIn(b), t) {
                            t = this._clip.duration;
                            var e = a._clip.duration,
                                n = t / e;
                            a.warp(1, e / t, b), this.warp(n, 1, b)
                        }
                        return this
                    },
                    crossFadeTo: function (a, b, t) {
                        return a.crossFadeFrom(this, b, t)
                    },
                    stopFading: function () {
                        var a = this._weightInterpolant;
                        return null !== a && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(a)), this
                    },
                    setEffectiveTimeScale: function (a) {
                        return this.timeScale = a, this._effectiveTimeScale = this.paused ? 0 : a, this.stopWarping()
                    },
                    getEffectiveTimeScale: function () {
                        return this._effectiveTimeScale
                    },
                    setDuration: function (a) {
                        return this.timeScale = this._clip.duration / a, this.stopWarping()
                    },
                    syncWith: function (a) {
                        return this.time = a.time, this.timeScale = a.timeScale, this.stopWarping()
                    },
                    halt: function (a) {
                        return this.warp(this._effectiveTimeScale, 0, a)
                    },
                    warp: function (a, b, t) {
                        var e = this._mixer,
                            n = e.time,
                            r = this._timeScaleInterpolant,
                            g = this.timeScale;
                        return null === r && (this._timeScaleInterpolant = r = e._lendControlInterpolant()), e = r.parameterPositions, r = r.sampleValues, e[0] = n, e[1] = n + t, r[0] = a / g, r[1] = b / g, this
                    },
                    stopWarping: function () {
                        var a = this._timeScaleInterpolant;
                        return null !== a && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(a)), this
                    },
                    getMixer: function () {
                        return this._mixer
                    },
                    getClip: function () {
                        return this._clip
                    },
                    getRoot: function () {
                        return this._localRoot || this._mixer._root
                    },
                    _update: function (a, b, t, e) {
                        if (this.enabled) {
                            var n = this._startTime;
                            if (null !== n) {
                                if (0 > (b = (a - n) * t) || 0 === t) return;
                                this._startTime = null, b *= t
                            }
                            if (b *= this._updateTimeScale(a), t = this._updateTime(b), 0 < (a = this._updateWeight(a))) {
                                b = this._interpolants, n = this._propertyBindings;
                                for (var r = 0, g = b.length; r !== g; ++r) b[r].evaluate(t), n[r].accumulate(e, a)
                            }
                        } else this._updateWeight(a)
                    },
                    _updateWeight: function (a) {
                        var b = 0;
                        if (this.enabled) {
                            b = this.weight;
                            var t = this._weightInterpolant;
                            if (null !== t) {
                                var e = t.evaluate(a)[0];
                                b *= e, a > t.parameterPositions[1] && (this.stopFading(), 0 === e && (this.enabled = !1))
                            }
                        }
                        return this._effectiveWeight = b
                    },
                    _updateTimeScale: function (a) {
                        var b = 0;
                        if (!this.paused) {
                            b = this.timeScale;
                            var t = this._timeScaleInterpolant;
                            null !== t && (b *= t.evaluate(a)[0], a > t.parameterPositions[1] && (this.stopWarping(), 0 === b ? this.paused = !0 : this.timeScale = b))
                        }
                        return this._effectiveTimeScale = b
                    },
                    _updateTime: function (a) {
                        var b = this.time + a,
                            t = this._clip.duration,
                            e = this.loop,
                            n = this._loopCount,
                            r = 2202 === e;
                        if (0 === a) return -1 === n ? b : r && 1 == (1 & n) ? t - b : b;
                        if (2200 === e) t: {
                            if (-1 === n && (this._loopCount = 0, this._setEndings(!0, !0, !1)), b >= t) b = t;
                            else {
                                if (!(0 > b)) {
                                    this.time = b;
                                    break t
                                }
                                b = 0
                            }
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            this.time = b,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: 0 > a ? -1 : 1
                            })
                        }
                        else {
                            if (-1 === n && (0 <= a ? (n = 0, this._setEndings(!0, 0 === this.repetitions, r)) : this._setEndings(0 === this.repetitions, !0, r)), b >= t || 0 > b) {
                                b -= t * (e = Math.floor(b / t)), n += Math.abs(e);
                                var g = this.repetitions - n;
                                0 >= g ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = b = 0 < a ? t : 0, this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: 0 < a ? 1 : -1
                                })) : (1 === g ? (a = 0 > a, this._setEndings(a, !a, r)) : this._setEndings(!1, !1, r), this._loopCount = n, this.time = b, this._mixer.dispatchEvent({
                                    type: "loop",
                                    action: this,
                                    loopDelta: e
                                }))
                            } else this.time = b;
                            if (r && 1 == (1 & n)) return t - b
                        }
                        return b
                    },
                    _setEndings: function (a, b, t) {
                        var e = this._interpolantSettings;
                        t ? (e.endingStart = 2401, e.endingEnd = 2401) : (e.endingStart = a ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, e.endingEnd = b ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
                    },
                    _scheduleFading: function (a, b, t) {
                        var e = this._mixer,
                            n = e.time,
                            r = this._weightInterpolant;
                        return null === r && (this._weightInterpolant = r = e._lendControlInterpolant()), e = r.parameterPositions, r = r.sampleValues, e[0] = n, r[0] = b, e[1] = n + a, r[1] = t, this
                    }
                }), na.prototype = Object.assign(Object.create(e.prototype), {
                    constructor: na,
                    _bindAction: function (a, b) {
                        var t = a._localRoot || this._root,
                            e = a._clip.tracks,
                            n = e.length,
                            r = a._propertyBindings;
                        a = a._interpolants;
                        var g = t.uuid,
                            o = this._bindingsByRootAndName,
                            c = o[g];
                        for (void 0 === c && (c = {}, o[g] = c), o = 0; o !== n; ++o) {
                            var l = e[o],
                                h = l.name,
                                p = c[h];
                            if (void 0 === p) {
                                if (void 0 !== (p = r[o])) {
                                    null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, g, h));
                                    continue
                                }++(p = new Qr(ta.create(t, h, b && b._propertyBindings[o].binding.parsedPath), l.ValueTypeName, l.getValueSize())).referenceCount, this._addInactiveBinding(p, g, h)
                            }
                            r[o] = p, a[o].resultBuffer = p.buffer
                        }
                    },
                    _activateAction: function (a) {
                        if (!this._isActiveAction(a)) {
                            if (null === a._cacheIndex) {
                                var b = (a._localRoot || this._root).uuid,
                                    t = a._clip.uuid,
                                    e = this._actionsByClip[t];
                                this._bindAction(a, e && e.knownActions[0]), this._addInactiveAction(a, t, b)
                            }
                            for (t = 0, e = (b = a._propertyBindings).length; t !== e; ++t) {
                                var n = b[t];
                                0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
                            }
                            this._lendAction(a)
                        }
                    },
                    _deactivateAction: function (a) {
                        if (this._isActiveAction(a)) {
                            for (var b = a._propertyBindings, t = 0, e = b.length; t !== e; ++t) {
                                var n = b[t];
                                0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
                            }
                            this._takeBackAction(a)
                        }
                    },
                    _initMemoryManager: function () {
                        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                        var a = this;
                        this.stats = {
                            actions: {
                                get total() {
                                    return a._actions.length
                                },
                                get inUse() {
                                    return a._nActiveActions
                                }
                            },
                            bindings: {
                                get total() {
                                    return a._bindings.length
                                },
                                get inUse() {
                                    return a._nActiveBindings
                                }
                            },
                            controlInterpolants: {
                                get total() {
                                    return a._controlInterpolants.length
                                },
                                get inUse() {
                                    return a._nActiveControlInterpolants
                                }
                            }
                        }
                    },
                    _isActiveAction: function (a) {
                        return null !== (a = a._cacheIndex) && a < this._nActiveActions
                    },
                    _addInactiveAction: function (a, b, t) {
                        var e = this._actions,
                            n = this._actionsByClip,
                            r = n[b];
                        void 0 === r ? (r = {
                            knownActions: [a],
                            actionByRoot: {}
                        }, a._byClipCacheIndex = 0, n[b] = r) : (b = r.knownActions, a._byClipCacheIndex = b.length, b.push(a)), a._cacheIndex = e.length, e.push(a), r.actionByRoot[t] = a
                    },
                    _removeInactiveAction: function (a) {
                        var b = this._actions,
                            t = b[b.length - 1],
                            e = a._cacheIndex;
                        t._cacheIndex = e, b[e] = t, b.pop(), a._cacheIndex = null, b = a._clip.uuid;
                        var n = (e = (t = this._actionsByClip)[b]).knownActions,
                            r = n[n.length - 1],
                            g = a._byClipCacheIndex;
                        r._byClipCacheIndex = g, n[g] = r, n.pop(), a._byClipCacheIndex = null, delete e.actionByRoot[(a._localRoot || this._root).uuid], 0 === n.length && delete t[b], this._removeInactiveBindingsForAction(a)
                    },
                    _removeInactiveBindingsForAction: function (a) {
                        for (var b = 0, t = (a = a._propertyBindings).length; b !== t; ++b) {
                            var e = a[b];
                            0 == --e.referenceCount && this._removeInactiveBinding(e)
                        }
                    },
                    _lendAction: function (a) {
                        var b = this._actions,
                            t = a._cacheIndex,
                            e = this._nActiveActions++,
                            n = b[e];
                        a._cacheIndex = e, b[e] = a, n._cacheIndex = t, b[t] = n
                    },
                    _takeBackAction: function (a) {
                        var b = this._actions,
                            t = a._cacheIndex,
                            e = --this._nActiveActions,
                            n = b[e];
                        a._cacheIndex = e, b[e] = a, n._cacheIndex = t, b[t] = n
                    },
                    _addInactiveBinding: function (a, b, t) {
                        var e = this._bindingsByRootAndName,
                            n = e[b],
                            r = this._bindings;
                        void 0 === n && (n = {}, e[b] = n), n[t] = a, a._cacheIndex = r.length, r.push(a)
                    },
                    _removeInactiveBinding: function (a) {
                        var b = this._bindings,
                            t = a.binding,
                            e = t.rootNode.uuid;
                        t = t.path;
                        var n = this._bindingsByRootAndName,
                            r = n[e],
                            g = b[b.length - 1];
                        a = a._cacheIndex, g._cacheIndex = a, b[a] = g, b.pop(), delete r[t], 0 === Object.keys(r).length && delete n[e]
                    },
                    _lendBinding: function (a) {
                        var b = this._bindings,
                            t = a._cacheIndex,
                            e = this._nActiveBindings++,
                            n = b[e];
                        a._cacheIndex = e, b[e] = a, n._cacheIndex = t, b[t] = n
                    },
                    _takeBackBinding: function (a) {
                        var b = this._bindings,
                            t = a._cacheIndex,
                            e = --this._nActiveBindings,
                            n = b[e];
                        a._cacheIndex = e, b[e] = a, n._cacheIndex = t, b[t] = n
                    },
                    _lendControlInterpolant: function () {
                        var a = this._controlInterpolants,
                            b = this._nActiveControlInterpolants++,
                            t = a[b];
                        return void 0 === t && ((t = new Oi(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = b, a[b] = t), t
                    },
                    _takeBackControlInterpolant: function (a) {
                        var b = this._controlInterpolants,
                            t = a.__cacheIndex,
                            e = --this._nActiveControlInterpolants,
                            n = b[e];
                        a.__cacheIndex = e, b[e] = a, n.__cacheIndex = t, b[t] = n
                    },
                    _controlInterpolantsResultBuffer: new Float32Array(1),
                    clipAction: function (a, b) {
                        var t = b || this._root,
                            e = t.uuid;
                        a = null !== (t = "string" == typeof a ? Gi.findByName(t, a) : a) ? t.uuid : a;
                        var n = this._actionsByClip[a],
                            r = null;
                        if (void 0 !== n) {
                            if (void 0 !== (r = n.actionByRoot[e])) return r;
                            r = n.knownActions[0], null === t && (t = r._clip)
                        }
                        return null === t ? null : (b = new li(this, t, b), this._bindAction(b, r), this._addInactiveAction(b, a, e), b)
                    },
                    existingAction: function (a, b) {
                        var t = b || this._root;
                        return b = t.uuid, t = "string" == typeof a ? Gi.findByName(t, a) : a, void 0 !== (a = this._actionsByClip[t ? t.uuid : a]) && a.actionByRoot[b] || null
                    },
                    stopAllAction: function () {
                        for (var a = this._actions, b = this._nActiveActions, t = this._bindings, e = this._nActiveBindings, n = this._nActiveBindings = this._nActiveActions = 0; n !== b; ++n) a[n].reset();
                        for (n = 0; n !== e; ++n) t[n].useCount = 0;
                        return this
                    },
                    update: function (a) {
                        a *= this.timeScale;
                        for (var b = this._actions, t = this._nActiveActions, e = this.time += a, n = Math.sign(a), r = this._accuIndex ^= 1, g = 0; g !== t; ++g) b[g]._update(e, a, n, r);
                        for (a = this._bindings, b = this._nActiveBindings, g = 0; g !== b; ++g) a[g].apply(r);
                        return this
                    },
                    setTime: function (a) {
                        for (var b = this.time = 0; b < this._actions.length; b++) this._actions[b].time = 0;
                        return this.update(a)
                    },
                    getRoot: function () {
                        return this._root
                    },
                    uncacheClip: function (a) {
                        var b = this._actions;
                        a = a.uuid;
                        var t = this._actionsByClip,
                            e = t[a];
                        if (void 0 !== e) {
                            for (var n = 0, r = (e = e.knownActions).length; n !== r; ++n) {
                                var g = e[n];
                                this._deactivateAction(g);
                                var o = g._cacheIndex,
                                    c = b[b.length - 1];
                                g._cacheIndex = null, g._byClipCacheIndex = null, c._cacheIndex = o, b[o] = c, b.pop(), this._removeInactiveBindingsForAction(g)
                            }
                            delete t[a]
                        }
                    },
                    uncacheRoot: function (a) {
                        a = a.uuid;
                        var b = this._actionsByClip;
                        for (e in b) {
                            var t = b[e].actionByRoot[a];
                            void 0 !== t && (this._deactivateAction(t), this._removeInactiveAction(t))
                        }
                        var e = this._bindingsByRootAndName[a];
                        if (void 0 !== e)
                            for (var n in e)(a = e[n]).restoreOriginalState(), this._removeInactiveBinding(a)
                    },
                    uncacheAction: function (a, b) {
                        null !== (a = this.existingAction(a, b)) && (this._deactivateAction(a), this._removeInactiveAction(a))
                    }
                }), ia.prototype.clone = function () {
                    return new ia(void 0 === this.value.clone ? this.value : this.value.clone())
                }, ra.prototype = Object.assign(Object.create(Xe.prototype), {
                    constructor: ra,
                    isInstancedInterleavedBuffer: !0,
                    copy: function (a) {
                        return Xe.prototype.copy.call(this, a), this.meshPerAttribute = a.meshPerAttribute, this
                    }
                }), Object.assign(aa.prototype, {
                    linePrecision: 1,
                    set: function (a, b) {
                        this.ray.set(a, b)
                    },
                    setFromCamera: function (a, b) {
                        b && b.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(b.matrixWorld), this.ray.direction.set(a.x, a.y, .5).unproject(b).sub(this.ray.origin).normalize(), this.camera = b) : b && b.isOrthographicCamera ? (this.ray.origin.set(a.x, a.y, (b.near + b.far) / (b.near - b.far)).unproject(b), this.ray.direction.set(0, 0, -1).transformDirection(b.matrixWorld), this.camera = b) : console.error("THREE.Raycaster: Unsupported camera type.")
                    },
                    intersectObject: function (a, b, t) {
                        return sa(a, this, t = t || [], b), t.sort(oa), t
                    },
                    intersectObjects: function (a, b, t) {
                        if (t = t || [], !1 === Array.isArray(a)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), t;
                        for (var e = 0, n = a.length; e < n; e++) sa(a[e], this, t, b);
                        return t.sort(oa), t
                    }
                }), Object.assign(ua.prototype, {
                    set: function (a, b, t) {
                        return this.radius = a, this.phi = b, this.theta = t, this
                    },
                    clone: function () {
                        return (new this.constructor).copy(this)
                    },
                    copy: function (a) {
                        return this.radius = a.radius, this.phi = a.phi, this.theta = a.theta, this
                    },
                    makeSafe: function () {
                        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
                    },
                    setFromVector3: function (a) {
                        return this.setFromCartesianCoords(a.x, a.y, a.z)
                    },
                    setFromCartesianCoords: function (a, b, t) {
                        return this.radius = Math.sqrt(a * a + b * b + t * t), 0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(a, t), this.phi = Math.acos(Va.clamp(b / this.radius, -1, 1))), this
                    }
                }), Object.assign(ca.prototype, {
                    set: function (a, b, t) {
                        return this.radius = a, this.theta = b, this.y = t, this
                    },
                    clone: function () {
                        return (new this.constructor).copy(this)
                    },
                    copy: function (a) {
                        return this.radius = a.radius, this.theta = a.theta, this.y = a.y, this
                    },
                    setFromVector3: function (a) {
                        return this.setFromCartesianCoords(a.x, a.y, a.z)
                    },
                    setFromCartesianCoords: function (a, b, t) {
                        return this.radius = Math.sqrt(a * a + t * t), this.theta = Math.atan2(a, t), this.y = b, this
                    }
                });
                var gc = new n;
                Object.assign(la.prototype, {
                    set: function (a, b) {
                        return this.min.copy(a), this.max.copy(b), this
                    },
                    setFromPoints: function (a) {
                        this.makeEmpty();
                        for (var b = 0, t = a.length; b < t; b++) this.expandByPoint(a[b]);
                        return this
                    },
                    setFromCenterAndSize: function (a, b) {
                        return b = gc.copy(b).multiplyScalar(.5), this.min.copy(a).sub(b), this.max.copy(a).add(b), this
                    },
                    clone: function () {
                        return (new this.constructor).copy(this)
                    },
                    copy: function (a) {
                        return this.min.copy(a.min), this.max.copy(a.max), this
                    },
                    makeEmpty: function () {
                        return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                    },
                    isEmpty: function () {
                        return this.max.x < this.min.x || this.max.y < this.min.y
                    },
                    getCenter: function (a) {
                        return void 0 === a && (console.warn("THREE.Box2: .getCenter() target is now required"), a = new n), this.isEmpty() ? a.set(0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5)
                    },
                    getSize: function (a) {
                        return void 0 === a && (console.warn("THREE.Box2: .getSize() target is now required"), a = new n), this.isEmpty() ? a.set(0, 0) : a.subVectors(this.max, this.min)
                    },
                    expandByPoint: function (a) {
                        return this.min.min(a), this.max.max(a), this
                    },
                    expandByVector: function (a) {
                        return this.min.sub(a), this.max.add(a), this
                    },
                    expandByScalar: function (a) {
                        return this.min.addScalar(-a), this.max.addScalar(a), this
                    },
                    containsPoint: function (a) {
                        return !(a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y)
                    },
                    containsBox: function (a) {
                        return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y
                    },
                    getParameter: function (a, b) {
                        return void 0 === b && (console.warn("THREE.Box2: .getParameter() target is now required"), b = new n), b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y))
                    },
                    intersectsBox: function (a) {
                        return !(a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y)
                    },
                    clampPoint: function (a, b) {
                        return void 0 === b && (console.warn("THREE.Box2: .clampPoint() target is now required"), b = new n), b.copy(a).clamp(this.min, this.max)
                    },
                    distanceToPoint: function (a) {
                        return gc.copy(a).clamp(this.min, this.max).sub(a).length()
                    },
                    intersect: function (a) {
                        return this.min.max(a.min), this.max.min(a.max), this
                    },
                    union: function (a) {
                        return this.min.min(a.min), this.max.max(a.max), this
                    },
                    translate: function (a) {
                        return this.min.add(a), this.max.add(a), this
                    },
                    equals: function (a) {
                        return a.min.equals(this.min) && a.max.equals(this.max)
                    }
                });
                var vc = new o,
                    yc = new o;
                Object.assign(ha.prototype, {
                    set: function (a, b) {
                        return this.start.copy(a), this.end.copy(b), this
                    },
                    clone: function () {
                        return (new this.constructor).copy(this)
                    },
                    copy: function (a) {
                        return this.start.copy(a.start), this.end.copy(a.end), this
                    },
                    getCenter: function (a) {
                        return void 0 === a && (console.warn("THREE.Line3: .getCenter() target is now required"), a = new o), a.addVectors(this.start, this.end).multiplyScalar(.5)
                    },
                    delta: function (a) {
                        return void 0 === a && (console.warn("THREE.Line3: .delta() target is now required"), a = new o), a.subVectors(this.end, this.start)
                    },
                    distanceSq: function () {
                        return this.start.distanceToSquared(this.end)
                    },
                    distance: function () {
                        return this.start.distanceTo(this.end)
                    },
                    at: function (a, b) {
                        return void 0 === b && (console.warn("THREE.Line3: .at() target is now required"), b = new o), this.delta(b).multiplyScalar(a).add(this.start)
                    },
                    closestPointToPointParameter: function (a, b) {
                        return vc.subVectors(a, this.start), yc.subVectors(this.end, this.start), a = yc.dot(yc), a = yc.dot(vc) / a, b && (a = Va.clamp(a, 0, 1)), a
                    },
                    closestPointToPoint: function (a, b, t) {
                        return a = this.closestPointToPointParameter(a, b), void 0 === t && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), t = new o), this.delta(t).multiplyScalar(a).add(this.start)
                    },
                    applyMatrix4: function (a) {
                        return this.start.applyMatrix4(a), this.end.applyMatrix4(a), this
                    },
                    equals: function (a) {
                        return a.start.equals(this.start) && a.end.equals(this.end)
                    }
                }), da.prototype = Object.create(_.prototype), da.prototype.constructor = da, da.prototype.isImmediateRenderObject = !0;
                var _c = new o;
                pa.prototype = Object.create(_.prototype), pa.prototype.constructor = pa, pa.prototype.dispose = function () {
                    this.cone.geometry.dispose(), this.cone.material.dispose()
                }, pa.prototype.update = function () {
                    this.light.updateMatrixWorld();
                    var a = this.light.distance ? this.light.distance : 1e3,
                        b = a * Math.tan(this.light.angle);
                    this.cone.scale.set(b, b, a), _c.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(_c), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                };
                var xc = new o,
                    bc = new m,
                    th = new m;
                fa.prototype = Object.create(sn.prototype), fa.prototype.constructor = fa, fa.prototype.updateMatrixWorld = function (a) {
                    var b = this.bones,
                        t = this.geometry,
                        e = t.getAttribute("position");
                    th.getInverse(this.root.matrixWorld);
                    for (var n = 0, r = 0; n < b.length; n++) {
                        var g = b[n];
                        g.parent && g.parent.isBone && (bc.multiplyMatrices(th, g.matrixWorld), xc.setFromMatrixPosition(bc), e.setXYZ(r, xc.x, xc.y, xc.z), bc.multiplyMatrices(th, g.parent.matrixWorld), xc.setFromMatrixPosition(bc), e.setXYZ(r + 1, xc.x, xc.y, xc.z), r += 2)
                    }
                    t.getAttribute("position").needsUpdate = !0, _.prototype.updateMatrixWorld.call(this, a)
                }, ma.prototype = Object.create(Z.prototype), ma.prototype.constructor = ma, ma.prototype.dispose = function () {
                    this.geometry.dispose(), this.material.dispose()
                }, ma.prototype.update = function () {
                    void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
                };
                var wc = new o,
                    Mc = new A,
                    Ec = new A;
                ga.prototype = Object.create(_.prototype), ga.prototype.constructor = ga, ga.prototype.dispose = function () {
                    this.children[0].geometry.dispose(), this.children[0].material.dispose()
                }, ga.prototype.update = function () {
                    var a = this.children[0];
                    if (void 0 !== this.color) this.material.color.set(this.color);
                    else {
                        var b = a.geometry.getAttribute("color");
                        Mc.copy(this.light.color), Ec.copy(this.light.groundColor);
                        for (var t = 0, e = b.count; t < e; t++) {
                            var n = t < e / 2 ? Mc : Ec;
                            b.setXYZ(t, n.r, n.g, n.b)
                        }
                        b.needsUpdate = !0
                    }
                    a.lookAt(wc.setFromMatrixPosition(this.light.matrixWorld).negate())
                }, va.prototype = Object.assign(Object.create(sn.prototype), {
                    constructor: va,
                    copy: function (a) {
                        return sn.prototype.copy.call(this, a), this.geometry.copy(a.geometry), this.material.copy(a.material), this
                    },
                    clone: function () {
                        return (new this.constructor).copy(this)
                    }
                }), ya.prototype = Object.create(sn.prototype), ya.prototype.constructor = ya;
                var Tc = new o,
                    Dc = new o,
                    Sc = new o;
                _a.prototype = Object.create(_.prototype), _a.prototype.constructor = _a, _a.prototype.dispose = function () {
                    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
                }, _a.prototype.update = function () {
                    Tc.setFromMatrixPosition(this.light.matrixWorld), Dc.setFromMatrixPosition(this.light.target.matrixWorld), Sc.subVectors(Dc, Tc), this.lightPlane.lookAt(Dc), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Dc), this.targetLine.scale.z = Sc.length()
                };
                var Ac = new o,
                    Cc = new nt;
                xa.prototype = Object.create(sn.prototype), xa.prototype.constructor = xa, xa.prototype.update = function () {
                    var a = this.geometry,
                        b = this.pointMap;
                    Cc.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), ba("c", b, a, Cc, 0, 0, -1), ba("t", b, a, Cc, 0, 0, 1), ba("n1", b, a, Cc, -1, -1, -1), ba("n2", b, a, Cc, 1, -1, -1), ba("n3", b, a, Cc, -1, 1, -1), ba("n4", b, a, Cc, 1, 1, -1), ba("f1", b, a, Cc, -1, -1, 1), ba("f2", b, a, Cc, 1, -1, 1), ba("f3", b, a, Cc, -1, 1, 1), ba("f4", b, a, Cc, 1, 1, 1), ba("u1", b, a, Cc, .7, 1.1, -1), ba("u2", b, a, Cc, -.7, 1.1, -1), ba("u3", b, a, Cc, 0, 2, -1), ba("cf1", b, a, Cc, -1, 0, 1), ba("cf2", b, a, Cc, 1, 0, 1), ba("cf3", b, a, Cc, 0, -1, 1), ba("cf4", b, a, Cc, 0, 1, 1), ba("cn1", b, a, Cc, -1, 0, -1), ba("cn2", b, a, Cc, 1, 0, -1), ba("cn3", b, a, Cc, 0, -1, -1), ba("cn4", b, a, Cc, 0, 1, -1), a.getAttribute("position").needsUpdate = !0
                };
                var Lc = new w;
                wa.prototype = Object.create(sn.prototype), wa.prototype.constructor = wa, wa.prototype.update = function (a) {
                    if (void 0 !== a && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Lc.setFromObject(this.object), !Lc.isEmpty()) {
                        a = Lc.min;
                        var b = Lc.max,
                            t = this.geometry.attributes.position,
                            e = t.array;
                        e[0] = b.x, e[1] = b.y, e[2] = b.z, e[3] = a.x, e[4] = b.y, e[5] = b.z, e[6] = a.x, e[7] = a.y, e[8] = b.z, e[9] = b.x, e[10] = a.y, e[11] = b.z, e[12] = b.x, e[13] = b.y, e[14] = a.z, e[15] = a.x, e[16] = b.y, e[17] = a.z, e[18] = a.x, e[19] = a.y, e[20] = a.z, e[21] = b.x, e[22] = a.y, e[23] = a.z, t.needsUpdate = !0, this.geometry.computeBoundingSphere()
                    }
                }, wa.prototype.setFromObject = function (a) {
                    return this.object = a, this.update(), this
                }, wa.prototype.copy = function (a) {
                    return sn.prototype.copy.call(this, a), this.object = a.object, this
                }, wa.prototype.clone = function () {
                    return (new this.constructor).copy(this)
                }, Ma.prototype = Object.create(sn.prototype), Ma.prototype.constructor = Ma, Ma.prototype.updateMatrixWorld = function (a) {
                    var b = this.box;
                    b.isEmpty() || (b.getCenter(this.position), b.getSize(this.scale), this.scale.multiplyScalar(.5), _.prototype.updateMatrixWorld.call(this, a))
                }, Ea.prototype = Object.create(on.prototype), Ea.prototype.constructor = Ea, Ea.prototype.updateMatrixWorld = function (a) {
                    var b = -this.plane.constant;
                    1e-8 > Math.abs(b) && (b = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, b), this.children[0].material.side = 0 > b ? 1 : 0, this.lookAt(this.plane.normal), _.prototype.updateMatrixWorld.call(this, a)
                };
                var Rc, Pc, Oc = new o;
                Ta.prototype = Object.create(_.prototype), Ta.prototype.constructor = Ta, Ta.prototype.setDirection = function (a) {
                    .99999 < a.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > a.y ? this.quaternion.set(1, 0, 0, 0) : (Oc.set(a.z, 0, -a.x).normalize(), this.quaternion.setFromAxisAngle(Oc, Math.acos(a.y)))
                }, Ta.prototype.setLength = function (a, b, t) {
                    void 0 === b && (b = .2 * a), void 0 === t && (t = .2 * b), this.line.scale.set(1, Math.max(1e-4, a - b), 1), this.line.updateMatrix(), this.cone.scale.set(t, b, t), this.cone.position.y = a, this.cone.updateMatrix()
                }, Ta.prototype.setColor = function (a) {
                    this.line.material.color.set(a), this.cone.material.color.set(a)
                }, Ta.prototype.copy = function (a) {
                    return _.prototype.copy.call(this, a, !1), this.line.copy(a.line), this.cone.copy(a.cone), this
                }, Ta.prototype.clone = function () {
                    return (new this.constructor).copy(this)
                }, Da.prototype = Object.create(sn.prototype), Da.prototype.constructor = Da;
                var a, Fc = Math.pow(2, 8),
                    Nc = [.125, .215, .35, .446, .526, .582],
                    Ic = 5 + Nc.length,
                    Bc = {
                        3e3: 0,
                        3001: 1,
                        3002: 2,
                        3004: 3,
                        3005: 4,
                        3006: 5,
                        3007: 6
                    },
                    kc = new Sr,
                    zc = ((a = new wi({
                        defines: {
                            n: a = 20
                        },
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            samples: {
                                value: 1
                            },
                            weights: {
                                value: new Float32Array(a)
                            },
                            latitudinal: {
                                value: !1
                            },
                            dTheta: {
                                value: 0
                            },
                            mipInt: {
                                value: 0
                            },
                            poleAxis: {
                                value: new o(0, 1, 0)
                            },
                            inputEncoding: {
                                value: Bc[3e3]
                            },
                            outputEncoding: {
                                value: Bc[3e3]
                            }
                        },
                        vertexShader: "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.x *= -1.0;\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.y *= -1.0;\n\t} else if (face == 5.0) {\n\t\tdirection.xz *= -1.0;\n\t}\n\treturn direction;\n}\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t",
                        fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i >= samples)\n\t\t\tbreak;\n\t\tfor (int dir = -1; dir < 2; dir += 2) {\n\t\t\tif (i == 0 && dir == 1)\n\t\t\t\tcontinue;\n\t\t\tvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n\t\t\tif (all(equal(axis, vec3(0.0))))\n\t\t\t\taxis = cross(vec3(0.0, 1.0, 0.0), vOutputDirection);\n\t\t\taxis = normalize(axis);\n\t\t\tfloat theta = dTheta * float(dir * i);\n\t\t\tfloat cosTheta = cos(theta);\n\t\t\t// Rodrigues' axis-angle rotation\n\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross(axis, vOutputDirection) * sin(theta)\n\t\t\t\t\t+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n\t\t\tgl_FragColor.rgb +=\n\t\t\t\t\tweights[i] * bilinearCubeUV(envMap, sampleDirection, mipInt);\n\t\t}\n\t}\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t",
                        blending: 0,
                        depthTest: !1,
                        depthWrite: !1
                    })).type = "SphericalGaussianBlur", a),
                    Uc = null,
                    Hc = null,
                    Gc = function () {
                        for (var a = [], b = [], t = [], e = 8, n = 0; n < Ic; n++) {
                            var r = Math.pow(2, e);
                            b.push(r);
                            var g = 1 / r;
                            4 < n ? g = Nc[n - 8 + 4 - 1] : 0 == n && (g = 0), t.push(g);
                            var o = [r = -(g = 1 / (r - 1)) / 2, r, g = 1 + g / 2, r, g, g, r, r, g, g, r, g];
                            r = new Float32Array(108), g = new Float32Array(72);
                            for (var c = new Float32Array(36), l = 0; 6 > l; l++) {
                                var h = l % 3 * 2 / 3 - 1,
                                    p = 2 < l ? 0 : -1;
                                r.set([h, p, 0, h + 2 / 3, p, 0, h + 2 / 3, p + 1, 0, h, p, 0, h + 2 / 3, p + 1, 0, h, p + 1, 0], 18 * l), g.set(o, 12 * l), c.set([l, l, l, l, l, l], 6 * l)
                            }(o = new X).setAttribute("position", new N(r, 3)), o.setAttribute("uv", new N(g, 2)), o.setAttribute("faceIndex", new N(c, 1)), a.push(o), 4 < e && e--
                        }
                        return {
                            _lodPlanes: a,
                            _sizeLods: b,
                            _sigmas: t
                        }
                    }(),
                    Vc = Gc._lodPlanes,
                    jc = Gc._sizeLods,
                    Wc = Gc._sigmas,
                    Yc = null,
                    qc = null,
                    Xc = (1 + Math.sqrt(5)) / 2,
                    Zc = 1 / Xc,
                    Jc = [new o(1, 1, 1), new o(-1, 1, 1), new o(1, 1, -1), new o(-1, 1, -1), new o(0, Xc, Zc), new o(0, Xc, -Zc), new o(Zc, 0, Xc), new o(-Zc, 0, Xc), new o(Xc, Zc, 0), new o(-Xc, Zc, 0)];
                Sa.prototype = {
                    constructor: Sa,
                    fromScene: function (a, b, t, e) {
                        void 0 === b && (b = 0), void 0 === t && (t = .1), void 0 === e && (e = 100);
                        var n = Aa();
                        t = new it(90, 1, t, e), e = [1, 1, 1, 1, -1, 1];
                        var r = [1, 1, -1, -1, -1, 1],
                            g = qc.outputEncoding,
                            o = qc.toneMapping,
                            c = qc.toneMappingExposure,
                            l = qc.getClearColor(),
                            h = qc.getClearAlpha();
                        qc.toneMapping = 1, qc.toneMappingExposure = 1, qc.outputEncoding = 3e3, a.scale.z *= -1;
                        var p = a.background;
                        if (p && p.isColor) {
                            p.convertSRGBToLinear();
                            var q = Math.min(Math.max(Math.ceil(Math.log2(Math.max(p.r, p.g, p.b))), -128), 127);
                            p = p.multiplyScalar(Math.pow(2, -q)), qc.setClearColor(p, (q + 128) / 255), a.background = null
                        }
                        for (qc.setRenderTarget(n), p = 0; 6 > p; p++) 0 == (q = p % 3) ? (t.up.set(0, e[p], 0), t.lookAt(r[p], 0, 0)) : 1 == q ? (t.up.set(0, 0, e[p]), t.lookAt(0, r[p], 0)) : (t.up.set(0, e[p], 0), t.lookAt(0, 0, r[p])), Pa(q * Fc, 2 < p ? Fc : 0, Fc, Fc), qc.render(a, t);
                        return qc.toneMapping = o, qc.toneMappingExposure = c, qc.outputEncoding = g, qc.setClearColor(l, h), a.scale.z *= -1, 0 < b && Fa(n, 0, 0, b), Oa(n), Ca(), n.scissorTest = !1, n
                    },
                    fromEquirectangular: function (a) {
                        return a.magFilter = 1003, a.minFilter = 1003, a.generateMipmaps = !1, this.fromCubemap(a)
                    },
                    fromCubemap: function (a) {
                        var b = Aa(a),
                            t = new x;
                        a.isCubeTexture ? null == Hc && (Hc = Ba()) : null == Uc && (Uc = Ia());
                        var e = a.isCubeTexture ? Hc : Uc;
                        return t.add(new Z(Vc[0], e)), (e = e.uniforms).envMap.value = a, a.isCubeTexture || e.texelSize.value.set(1 / a.image.width, 1 / a.image.height), e.inputEncoding.value = Bc[a.encoding], e.outputEncoding.value = Bc[a.encoding], qc.setRenderTarget(b), Pa(0, 0, 3 * Fc, 2 * Fc), qc.render(t, kc), Oa(b), Ca(), b.scissorTest = !1, b
                    },
                    compileCubemapShader: function () {
                        null == Hc && La(Hc = Ba())
                    },
                    compileEquirectangularShader: function () {
                        null == Uc && La(Uc = Ia())
                    },
                    dispose: function () {
                        zc.dispose(), null != Hc && Hc.dispose(), null != Uc && Uc.dispose();
                        for (var a = 0; a < Vc.length; a++) Vc[a].dispose()
                    }
                }, Ki.create = function (a, b) {
                    return console.log("THREE.Curve.create() has been deprecated"), a.prototype = Object.create(Ki.prototype), a.prototype.constructor = a, a.prototype.getPoint = b, a
                }, Object.assign(gr.prototype, {
                    createPointsGeometry: function (a) {
                        return console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."), a = this.getPoints(a), this.createGeometry(a)
                    },
                    createSpacedPointsGeometry: function (a) {
                        return console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."), a = this.getSpacedPoints(a), this.createGeometry(a)
                    },
                    createGeometry: function (a) {
                        console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                        for (var b = new Q, t = 0, e = a.length; t < e; t++) {
                            var n = a[t];
                            b.vertices.push(new o(n.x, n.y, n.z || 0))
                        }
                        return b
                    }
                }), Object.assign(vr.prototype, {
                    fromPoints: function (a) {
                        return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(a)
                    }
                }), ka.prototype = Object.create(rr.prototype), za.prototype = Object.create(rr.prototype), Ua.prototype = Object.create(rr.prototype), Object.assign(Ua.prototype, {
                    initFromArray: function () {
                        console.error("THREE.Spline: .initFromArray() has been removed.")
                    },
                    getControlPointsArray: function () {
                        console.error("THREE.Spline: .getControlPointsArray() has been removed.")
                    },
                    reparametrizeByArcLength: function () {
                        console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
                    }
                }), va.prototype.setColors = function () {
                    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
                }, fa.prototype.update = function () {
                    console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
                }, Object.assign(Wi.prototype, {
                    extractUrlBase: function (a) {
                        return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Yu.extractUrlBase(a)
                    }
                }), Wi.Handlers = {
                    add: function () {
                        console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
                    },
                    get: function () {
                        console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
                    }
                }, Object.assign(Ir.prototype, {
                    setTexturePath: function (a) {
                        return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(a)
                    }
                }), Object.assign(la.prototype, {
                    center: function (a) {
                        return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(a)
                    },
                    empty: function () {
                        return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                    },
                    isIntersectionBox: function (a) {
                        return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(a)
                    },
                    size: function (a) {
                        return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(a)
                    }
                }), Object.assign(w.prototype, {
                    center: function (a) {
                        return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(a)
                    },
                    empty: function () {
                        return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                    },
                    isIntersectionBox: function (a) {
                        return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(a)
                    },
                    isIntersectionSphere: function (a) {
                        return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(a)
                    },
                    size: function (a) {
                        return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(a)
                    }
                }), ha.prototype.center = function (a) {
                    return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(a)
                }, Object.assign(Va, {
                    random16: function () {
                        return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
                    },
                    nearestPowerOfTwo: function (a) {
                        return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Va.floorPowerOfTwo(a)
                    },
                    nextPowerOfTwo: function (a) {
                        return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Va.ceilPowerOfTwo(a)
                    }
                }), Object.assign(c.prototype, {
                    flattenToArrayOffset: function (a, b) {
                        return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(a, b)
                    },
                    multiplyVector3: function (a) {
                        return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), a.applyMatrix3(this)
                    },
                    multiplyVector3Array: function () {
                        console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
                    },
                    applyToBuffer: function (a) {
                        return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(a)
                    },
                    applyToVector3Array: function () {
                        console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
                    }
                }), Object.assign(m.prototype, {
                    extractPosition: function (a) {
                        return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(a)
                    },
                    flattenToArrayOffset: function (a, b) {
                        return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(a, b)
                    },
                    getPosition: function () {
                        return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new o).setFromMatrixColumn(this, 3)
                    },
                    setRotationFromQuaternion: function (a) {
                        return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(a)
                    },
                    multiplyToArray: function () {
                        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
                    },
                    multiplyVector3: function (a) {
                        return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), a.applyMatrix4(this)
                    },
                    multiplyVector4: function (a) {
                        return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), a.applyMatrix4(this)
                    },
                    multiplyVector3Array: function () {
                        console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
                    },
                    rotateAxis: function (a) {
                        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), a.transformDirection(this)
                    },
                    crossVector: function (a) {
                        return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), a.applyMatrix4(this)
                    },
                    translate: function () {
                        console.error("THREE.Matrix4: .translate() has been removed.")
                    },
                    rotateX: function () {
                        console.error("THREE.Matrix4: .rotateX() has been removed.")
                    },
                    rotateY: function () {
                        console.error("THREE.Matrix4: .rotateY() has been removed.")
                    },
                    rotateZ: function () {
                        console.error("THREE.Matrix4: .rotateZ() has been removed.")
                    },
                    rotateByAxis: function () {
                        console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
                    },
                    applyToBuffer: function (a) {
                        return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(a)
                    },
                    applyToVector3Array: function () {
                        console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
                    },
                    makeFrustum: function (a, b, t, e, n, r) {
                        return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(a, b, e, t, n, r)
                    }
                }), D.prototype.isIntersectionLine = function (a) {
                    return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(a)
                }, r.prototype.multiplyVector3 = function (a) {
                    return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), a.applyQuaternion(this)
                }, Object.assign(T.prototype, {
                    isIntersectionBox: function (a) {
                        return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(a)
                    },
                    isIntersectionPlane: function (a) {
                        return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(a)
                    },
                    isIntersectionSphere: function (a) {
                        return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(a)
                    }
                }), Object.assign(S.prototype, {
                    area: function () {
                        return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
                    },
                    barycoordFromPoint: function (a, b) {
                        return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(a, b)
                    },
                    midpoint: function (a) {
                        return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(a)
                    },
                    normal: function (a) {
                        return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(a)
                    },
                    plane: function (a) {
                        return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(a)
                    }
                }), Object.assign(S, {
                    barycoordFromPoint: function (a, b, t, e, n) {
                        return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), S.getBarycoord(a, b, t, e, n)
                    },
                    normal: function (a, b, t, e) {
                        return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), S.getNormal(a, b, t, e)
                    }
                }), Object.assign(yr.prototype, {
                    extractAllPoints: function (a) {
                        return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(a)
                    },
                    extrude: function (a) {
                        return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Kn(this, a)
                    },
                    makeGeometry: function (a) {
                        return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new hi(this, a)
                    }
                }), Object.assign(n.prototype, {
                    fromAttribute: function (a, b, t) {
                        return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(a, b, t)
                    },
                    distanceToManhattan: function (a) {
                        return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(a)
                    },
                    lengthManhattan: function () {
                        return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                    }
                }), Object.assign(o.prototype, {
                    setEulerFromRotationMatrix: function () {
                        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
                    },
                    setEulerFromQuaternion: function () {
                        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
                    },
                    getPositionFromMatrix: function (a) {
                        return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(a)
                    },
                    getScaleFromMatrix: function (a) {
                        return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(a)
                    },
                    getColumnFromMatrix: function (a, b) {
                        return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(b, a)
                    },
                    applyProjection: function (a) {
                        return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(a)
                    },
                    fromAttribute: function (a, b, t) {
                        return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(a, b, t)
                    },
                    distanceToManhattan: function (a) {
                        return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(a)
                    },
                    lengthManhattan: function () {
                        return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                    }
                }), Object.assign(h.prototype, {
                    fromAttribute: function (a, b, t) {
                        return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(a, b, t)
                    },
                    lengthManhattan: function () {
                        return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                    }
                }), Object.assign(Q.prototype, {
                    computeTangents: function () {
                        console.error("THREE.Geometry: .computeTangents() has been removed.")
                    },
                    computeLineDistances: function () {
                        console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
                    }
                }), Object.assign(_.prototype, {
                    getChildByName: function (a) {
                        return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(a)
                    },
                    renderDepth: function () {
                        console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
                    },
                    translate: function (a, b) {
                        return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(b, a)
                    },
                    getWorldRotation: function () {
                        console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
                    }
                }), Object.defineProperties(_.prototype, {
                    eulerOrder: {
                        get: function () {
                            return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                        },
                        set: function (a) {
                            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = a
                        }
                    },
                    useQuaternion: {
                        get: function () {
                            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                        },
                        set: function () {
                            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                        }
                    }
                }), Object.assign(Z.prototype, {
                    setDrawMode: function () {
                        console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                    }
                }), Object.defineProperties(Z.prototype, {
                    drawMode: {
                        get: function () {
                            return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0
                        },
                        set: function () {
                            console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                        }
                    }
                }), Object.defineProperties(Ke.prototype, {
                    objects: {
                        get: function () {
                            return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                        }
                    }
                }), Object.defineProperty(en.prototype, "useVertexTexture", {
                    get: function () {
                        console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                    },
                    set: function () {
                        console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                    }
                }), tn.prototype.initBones = function () {
                    console.error("THREE.SkinnedMesh: initBones() has been removed.")
                }, Object.defineProperty(Ki.prototype, "__arcLengthDivisions", {
                    get: function () {
                        return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
                    },
                    set: function (a) {
                        console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = a
                    }
                }), it.prototype.setLens = function (a, b) {
                    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== b && (this.filmGauge = b), this.setFocalLength(a)
                }, Object.defineProperties(_r.prototype, {
                    onlyShadow: {
                        set: function () {
                            console.warn("THREE.Light: .onlyShadow has been removed.")
                        }
                    },
                    shadowCameraFov: {
                        set: function (a) {
                            console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = a
                        }
                    },
                    shadowCameraLeft: {
                        set: function (a) {
                            console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = a
                        }
                    },
                    shadowCameraRight: {
                        set: function (a) {
                            console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = a
                        }
                    },
                    shadowCameraTop: {
                        set: function (a) {
                            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = a
                        }
                    },
                    shadowCameraBottom: {
                        set: function (a) {
                            console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = a
                        }
                    },
                    shadowCameraNear: {
                        set: function (a) {
                            console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = a
                        }
                    },
                    shadowCameraFar: {
                        set: function (a) {
                            console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = a
                        }
                    },
                    shadowCameraVisible: {
                        set: function () {
                            console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                        }
                    },
                    shadowBias: {
                        set: function (a) {
                            console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = a
                        }
                    },
                    shadowDarkness: {
                        set: function () {
                            console.warn("THREE.Light: .shadowDarkness has been removed.")
                        }
                    },
                    shadowMapWidth: {
                        set: function (a) {
                            console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = a
                        }
                    },
                    shadowMapHeight: {
                        set: function (a) {
                            console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = a
                        }
                    }
                }), Object.defineProperties(N.prototype, {
                    length: {
                        get: function () {
                            return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                        }
                    },
                    dynamic: {
                        get: function () {
                            return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), 35048 === this.usage
                        },
                        set: function () {
                            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(35048)
                        }
                    }
                }), Object.assign(N.prototype, {
                    setDynamic: function (a) {
                        return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === a ? 35048 : 35044), this
                    },
                    copyIndicesArray: function () {
                        console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
                    },
                    setArray: function () {
                        console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
                    }
                }), Object.assign(X.prototype, {
                    addIndex: function (a) {
                        console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(a)
                    },
                    addAttribute: function (a, b, t) {
                        return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), b && b.isBufferAttribute || b && b.isInterleavedBufferAttribute ? "index" === a ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(b), this) : this.setAttribute(a, b) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(a, new N(b, t)))
                    },
                    addDrawCall: function (a, b, t) {
                        void 0 !== t && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(a, b)
                    },
                    clearDrawCalls: function () {
                        console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
                    },
                    computeTangents: function () {
                        console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
                    },
                    computeOffsets: function () {
                        console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
                    },
                    removeAttribute: function (a) {
                        return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(a)
                    }
                }), Object.defineProperties(X.prototype, {
                    drawcalls: {
                        get: function () {
                            return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                        }
                    },
                    offsets: {
                        get: function () {
                            return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                        }
                    }
                }), Object.defineProperties(Xe.prototype, {
                    dynamic: {
                        get: function () {
                            return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), 35048 === this.usage
                        },
                        set: function (a) {
                            console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(a)
                        }
                    }
                }), Object.assign(Xe.prototype, {
                    setDynamic: function (a) {
                        return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === a ? 35048 : 35044), this
                    },
                    setArray: function () {
                        console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
                    }
                }), Object.assign(ti.prototype, {
                    getArrays: function () {
                        console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
                    },
                    addShapeList: function () {
                        console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
                    },
                    addShape: function () {
                        console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
                    }
                }), Object.defineProperties(ia.prototype, {
                    dynamic: {
                        set: function () {
                            console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                        }
                    },
                    onUpdate: {
                        value: function () {
                            return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
                        }
                    }
                }), Object.defineProperties(O.prototype, {
                    wrapAround: {
                        get: function () {
                            console.warn("THREE.Material: .wrapAround has been removed.")
                        },
                        set: function () {
                            console.warn("THREE.Material: .wrapAround has been removed.")
                        }
                    },
                    overdraw: {
                        get: function () {
                            console.warn("THREE.Material: .overdraw has been removed.")
                        },
                        set: function () {
                            console.warn("THREE.Material: .overdraw has been removed.")
                        }
                    },
                    wrapRGB: {
                        get: function () {
                            return console.warn("THREE.Material: .wrapRGB has been removed."), new A
                        }
                    },
                    shading: {
                        get: function () {
                            console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                        },
                        set: function (a) {
                            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === a
                        }
                    },
                    stencilMask: {
                        get: function () {
                            return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
                        },
                        set: function (a) {
                            console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = a
                        }
                    }
                }), Object.defineProperties(Ti.prototype, {
                    metal: {
                        get: function () {
                            return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
                        },
                        set: function () {
                            console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                        }
                    }
                }), Object.defineProperties(et.prototype, {
                    derivatives: {
                        get: function () {
                            return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                        },
                        set: function (a) {
                            console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = a
                        }
                    }
                }), Object.assign(We.prototype, {
                    clearTarget: function (a, b, t, e) {
                        console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(a), this.clear(b, t, e)
                    },
                    animate: function (a) {
                        console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(a)
                    },
                    getCurrentRenderTarget: function () {
                        return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
                    },
                    getMaxAnisotropy: function () {
                        return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
                    },
                    getPrecision: function () {
                        return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
                    },
                    resetGLState: function () {
                        return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
                    },
                    supportsFloatTextures: function () {
                        return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
                    },
                    supportsHalfFloatTextures: function () {
                        return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
                    },
                    supportsStandardDerivatives: function () {
                        return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
                    },
                    supportsCompressedTextureS3TC: function () {
                        return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
                    },
                    supportsCompressedTexturePVRTC: function () {
                        return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
                    },
                    supportsBlendMinMax: function () {
                        return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
                    },
                    supportsVertexTextures: function () {
                        return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
                    },
                    supportsInstancedArrays: function () {
                        return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
                    },
                    enableScissorTest: function (a) {
                        console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(a)
                    },
                    initMaterial: function () {
                        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
                    },
                    addPrePlugin: function () {
                        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
                    },
                    addPostPlugin: function () {
                        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
                    },
                    updateShadowMap: function () {
                        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
                    },
                    setFaceCulling: function () {
                        console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
                    },
                    allocTextureUnit: function () {
                        console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
                    },
                    setTexture: function () {
                        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
                    },
                    setTexture2D: function () {
                        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
                    },
                    setTextureCube: function () {
                        console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
                    },
                    getActiveMipMapLevel: function () {
                        return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
                    }
                }), Object.defineProperties(We.prototype, {
                    shadowMapEnabled: {
                        get: function () {
                            return this.shadowMap.enabled
                        },
                        set: function (a) {
                            console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = a
                        }
                    },
                    shadowMapType: {
                        get: function () {
                            return this.shadowMap.type
                        },
                        set: function (a) {
                            console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = a
                        }
                    },
                    shadowMapCullFace: {
                        get: function () {
                            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                        },
                        set: function () {
                            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                        }
                    },
                    context: {
                        get: function () {
                            return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
                        }
                    },
                    vr: {
                        get: function () {
                            return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
                        }
                    },
                    gammaInput: {
                        get: function () {
                            return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
                        },
                        set: function () {
                            console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
                        }
                    },
                    gammaOutput: {
                        get: function () {
                            return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
                        },
                        set: function (a) {
                            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === a ? 3001 : 3e3
                        }
                    }
                }), Object.defineProperties(Ie.prototype, {
                    cullFace: {
                        get: function () {
                            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                        },
                        set: function () {
                            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                        }
                    },
                    renderReverseSided: {
                        get: function () {
                            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                        },
                        set: function () {
                            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                        }
                    },
                    renderSingleSided: {
                        get: function () {
                            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                        },
                        set: function () {
                            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                        }
                    }
                }), Object.defineProperties(ot.prototype, {
                    activeCubeFace: {
                        set: function () {
                            console.warn("THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().")
                        }
                    },
                    activeMipMapLevel: {
                        set: function () {
                            console.warn("THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().")
                        }
                    }
                }), Object.defineProperties(d.prototype, {
                    wrapS: {
                        get: function () {
                            return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                        },
                        set: function (a) {
                            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = a
                        }
                    },
                    wrapT: {
                        get: function () {
                            return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                        },
                        set: function (a) {
                            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = a
                        }
                    },
                    magFilter: {
                        get: function () {
                            return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                        },
                        set: function (a) {
                            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = a
                        }
                    },
                    minFilter: {
                        get: function () {
                            return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                        },
                        set: function (a) {
                            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = a
                        }
                    },
                    anisotropy: {
                        get: function () {
                            return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                        },
                        set: function (a) {
                            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = a
                        }
                    },
                    offset: {
                        get: function () {
                            return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                        },
                        set: function (a) {
                            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = a
                        }
                    },
                    repeat: {
                        get: function () {
                            return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                        },
                        set: function (a) {
                            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = a
                        }
                    },
                    format: {
                        get: function () {
                            return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                        },
                        set: function (a) {
                            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = a
                        }
                    },
                    type: {
                        get: function () {
                            return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                        },
                        set: function (a) {
                            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = a
                        }
                    },
                    generateMipmaps: {
                        get: function () {
                            return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                        },
                        set: function (a) {
                            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = a
                        }
                    }
                }), Object.defineProperties(Zr.prototype, {
                    load: {
                        value: function (a) {
                            console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                            var b = this;
                            return (new Hr).load(a, (function (a) {
                                b.setBuffer(a)
                            })), this
                        }
                    },
                    startTime: {
                        set: function () {
                            console.warn("THREE.Audio: .startTime is now .play( delay ).")
                        }
                    }
                }), $r.prototype.getData = function () {
                    return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
                }, at.prototype.updateCubeMap = function (a, b) {
                    return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(a, b)
                }, Xa.crossOrigin = void 0, Xa.loadTexture = function (a, b, t, e) {
                    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                    var n = new Qi;
                    return n.setCrossOrigin(this.crossOrigin), a = n.load(a, t, void 0, e), b && (a.mapping = b), a
                }, Xa.loadTextureCube = function (a, b, t, e) {
                    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                    var n = new $i;
                    return n.setCrossOrigin(this.crossOrigin), a = n.load(a, t, void 0, e), b && (a.mapping = b), a
                }, Xa.loadCompressedTexture = function () {
                    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
                }, Xa.loadCompressedTextureCube = function () {
                    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
                }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                    detail: {
                        revision: "112"
                    }
                })), t.ACESFilmicToneMapping = 5, t.AddEquation = 100, t.AddOperation = 2, t.AdditiveBlending = 2, t.AlphaFormat = 1021, t.AlwaysDepth = 1, t.AlwaysStencilFunc = 519, t.AmbientLight = Lr, t.AmbientLightProbe = Wr, t.AnimationClip = Gi, t.AnimationLoader = qi, t.AnimationMixer = na, t.AnimationObjectGroup = ea, t.AnimationUtils = Bu, t.ArcCurve = nr, t.ArrayCamera = Ge, t.ArrowHelper = Ta, t.Audio = Zr, t.AudioAnalyser = $r, t.AudioContext = Qu, t.AudioListener = Xr, t.AudioLoader = Hr, t.AxesHelper = Da, t.AxisHelper = function (a) {
                    return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new Da(a)
                }, t.BackSide = 1, t.BasicDepthPacking = 3200, t.BasicShadowMap = 0, t.BinaryTextureLoader = function (a) {
                    return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Zi(a)
                }, t.Bone = nn, t.BooleanKeyframeTrack = Ii, t.BoundingBoxHelper = function (a, b) {
                    return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new wa(a, b)
                }, t.Box2 = la, t.Box3 = w, t.Box3Helper = Ma, t.BoxBufferGeometry = Ps, t.BoxGeometry = Rs, t.BoxHelper = wa, t.BufferAttribute = N, t.BufferGeometry = X, t.BufferGeometryLoader = Nr, t.ByteType = 1010, t.Cache = ku, t.Camera = nt, t.CameraHelper = xa, t.CanvasRenderer = function () {
                    console.error("THREE.CanvasRenderer has been removed")
                }, t.CanvasTexture = fn, t.CatmullRomCurve3 = rr, t.CineonToneMapping = 4, t.CircleBufferGeometry = xi, t.CircleGeometry = _i, t.ClampToEdgeWrapping = 1001, t.Clock = qr, t.ClosedSplineCurve3 = ka, t.Color = A, t.ColorKeyframeTrack = Bi, t.CompressedTexture = pn, t.CompressedTextureLoader = Xi, t.ConeBufferGeometry = yi, t.ConeGeometry = vi, t.CubeCamera = at, t.CubeGeometry = Rs, t.CubeReflectionMapping = 301, t.CubeRefractionMapping = 302, t.CubeTexture = Tt, t.CubeTextureLoader = $i, t.CubeUVReflectionMapping = 306, t.CubeUVRefractionMapping = 307, t.CubicBezierCurve = ur, t.CubicBezierCurve3 = cr, t.CubicInterpolant = Pi, t.CullFaceBack = 1, t.CullFaceFront = 2, t.CullFaceFrontBack = 3, t.CullFaceNone = 0, t.Curve = Ki, t.CurvePath = gr, t.CustomBlending = 5, t.CylinderBufferGeometry = gi, t.CylinderGeometry = mi, t.Cylindrical = ca, t.DataTexture = st, t.DataTexture2DArray = Dt, t.DataTexture3D = St, t.DataTextureLoader = Zi, t.DecrementStencilOp = 7683, t.DecrementWrapStencilOp = 34056, t.DefaultLoadingManager = zu, t.DepthFormat = 1026, t.DepthStencilFormat = 1027, t.DepthTexture = mn, t.DirectionalLight = Cr, t.DirectionalLightHelper = _a, t.DirectionalLightShadow = Ar, t.DiscreteInterpolant = Fi, t.DodecahedronBufferGeometry = An, t.DodecahedronGeometry = Sn, t.DoubleSide = 2, t.DstAlphaFactor = 206, t.DstColorFactor = 208, t.DynamicBufferAttribute = function (a, b) {
                    return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new N(a, b).setDynamic(!0)
                }, t.DynamicCopyUsage = 35050, t.DynamicDrawUsage = 35048, t.DynamicReadUsage = 35049, t.EdgesGeometry = fi, t.EdgesHelper = function (a, b) {
                    return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new sn(new fi(a.geometry), new an({
                        color: void 0 !== b ? b : 16777215
                    }))
                }, t.EllipseCurve = er, t.EqualDepth = 4, t.EqualStencilFunc = 514, t.EquirectangularReflectionMapping = 303, t.EquirectangularRefractionMapping = 304, t.Euler = v, t.EventDispatcher = e, t.ExtrudeBufferGeometry = ti, t.ExtrudeGeometry = Kn, t.Face3 = P, t.Face4 = function (a, b, t, e, n, r, g) {
                    return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new P(a, b, t, n, r, g)
                }, t.FaceColors = 1, t.FileLoader = Yi, t.FlatShading = 1, t.Float32Attribute = function (a, b) {
                    return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new V(a, b)
                }, t.Float32BufferAttribute = V, t.Float64Attribute = function (a, b) {
                    return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new j(a, b)
                }, t.Float64BufferAttribute = j, t.FloatType = 1015, t.Fog = qe, t.FogExp2 = Ye, t.Font = zr, t.FontLoader = Ur, t.FrontFaceDirectionCCW = 1, t.FrontFaceDirectionCW = 0, t.FrontSide = 0, t.Frustum = ut, t.GammaEncoding = 3007, t.Geometry = Q, t.GeometryUtils = {
                    merge: function (a, b, t) {
                        if (console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), b.isMesh) {
                            b.matrixAutoUpdate && b.updateMatrix();
                            var e = b.matrix;
                            b = b.geometry
                        }
                        a.merge(b, e, t)
                    },
                    center: function (a) {
                        return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), a.center()
                    }
                }, t.GreaterDepth = 6, t.GreaterEqualDepth = 5, t.GreaterEqualStencilFunc = 518, t.GreaterStencilFunc = 516, t.GridHelper = va, t.Group = Ve, t.HalfFloatType = 1016, t.HemisphereLight = xr, t.HemisphereLightHelper = ga, t.HemisphereLightProbe = jr, t.IcosahedronBufferGeometry = Dn, t.IcosahedronGeometry = Tn, t.ImageBitmapLoader = Br, t.ImageLoader = Ji, t.ImageUtils = Xa, t.ImmediateRenderObject = da, t.IncrementStencilOp = 7682, t.IncrementWrapStencilOp = 34055, t.InstancedBufferAttribute = Fr, t.InstancedBufferGeometry = Or, t.InstancedInterleavedBuffer = ra, t.InstancedMesh = rn, t.Int16Attribute = function (a, b) {
                    return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new z(a, b)
                }, t.Int16BufferAttribute = z, t.Int32Attribute = function (a, b) {
                    return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new H(a, b)
                }, t.Int32BufferAttribute = H, t.Int8Attribute = function (a, b) {
                    return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new I(a, b)
                }, t.Int8BufferAttribute = I, t.IntType = 1013, t.InterleavedBuffer = Xe, t.InterleavedBufferAttribute = Ze, t.Interpolant = Ri, t.InterpolateDiscrete = 2300, t.InterpolateLinear = 2301, t.InterpolateSmooth = 2302, t.InvertStencilOp = 5386, t.JSONLoader = function () {
                    console.error("THREE.JSONLoader has been removed.")
                }, t.KeepStencilOp = 7680, t.KeyframeTrack = Ni, t.LOD = Ke, t.LatheBufferGeometry = ci, t.LatheGeometry = ui, t.Layers = y, t.LensFlare = function () {
                    console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
                }, t.LessDepth = 2, t.LessEqualDepth = 3, t.LessEqualStencilFunc = 515, t.LessStencilFunc = 513, t.Light = _r, t.LightProbe = Vr, t.LightShadow = wr, t.Line = on, t.Line3 = ha, t.LineBasicMaterial = an, t.LineCurve = lr, t.LineCurve3 = dr, t.LineDashedMaterial = Li, t.LineLoop = un, t.LinePieces = 1, t.LineSegments = sn, t.LineStrip = 0, t.LinearEncoding = 3e3, t.LinearFilter = 1006, t.LinearInterpolant = Oi, t.LinearMipMapLinearFilter = 1008, t.LinearMipMapNearestFilter = 1007, t.LinearMipmapLinearFilter = 1008, t.LinearMipmapNearestFilter = 1007, t.LinearToneMapping = 1, t.Loader = Wi, t.LoaderUtils = Yu, t.LoadingManager = ji, t.LogLuvEncoding = 3003, t.LoopOnce = 2200, t.LoopPingPong = 2202, t.LoopRepeat = 2201, t.LuminanceAlphaFormat = 1025, t.LuminanceFormat = 1024, t.MOUSE = {
                    LEFT: 0,
                    MIDDLE: 1,
                    RIGHT: 2,
                    ROTATE: 0,
                    DOLLY: 1,
                    PAN: 2
                }, t.Material = O, t.MaterialLoader = Pr, t.Math = Va, t.Matrix3 = c, t.Matrix4 = m, t.MaxEquation = 104, t.Mesh = Z, t.MeshBasicMaterial = F, t.MeshDepthMaterial = Fe, t.MeshDistanceMaterial = Ne, t.MeshFaceMaterial = function (a) {
                    return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), a
                }, t.MeshLambertMaterial = Ai, t.MeshMatcapMaterial = Ci, t.MeshNormalMaterial = Si, t.MeshPhongMaterial = Ti, t.MeshPhysicalMaterial = Ei, t.MeshStandardMaterial = Mi, t.MeshToonMaterial = Di, t.MinEquation = 103, t.MirroredRepeatWrapping = 1002, t.MixOperation = 1, t.MultiMaterial = function (a) {
                    return void 0 === a && (a = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), a.isMultiMaterial = !0, a.materials = a, a.clone = function () {
                        return a.slice()
                    }, a
                }, t.MultiplyBlending = 4, t.MultiplyOperation = 0, t.NearestFilter = 1003, t.NearestMipMapLinearFilter = 1005, t.NearestMipMapNearestFilter = 1004, t.NearestMipmapLinearFilter = 1005, t.NearestMipmapNearestFilter = 1004, t.NeverDepth = 0, t.NeverStencilFunc = 512, t.NoBlending = 0, t.NoColors = 0, t.NoToneMapping = 0, t.NormalBlending = 1, t.NotEqualDepth = 7, t.NotEqualStencilFunc = 517, t.NumberKeyframeTrack = ki, t.Object3D = _, t.ObjectLoader = Ir, t.ObjectSpaceNormalMap = 1, t.OctahedronBufferGeometry = En, t.OctahedronGeometry = Mn, t.OneFactor = 201, t.OneMinusDstAlphaFactor = 207, t.OneMinusDstColorFactor = 209, t.OneMinusSrcAlphaFactor = 205, t.OneMinusSrcColorFactor = 203, t.OrthographicCamera = Sr, t.PCFShadowMap = 1, t.PCFSoftShadowMap = 2, t.PMREMGenerator = Sa, t.ParametricBufferGeometry = yn, t.ParametricGeometry = vn, t.Particle = function (a) {
                    return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new $e(a)
                }, t.ParticleBasicMaterial = function (a) {
                    return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new cn(a)
                }, t.ParticleSystem = function (a, b) {
                    return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new ln(a, b)
                }, t.ParticleSystemMaterial = function (a) {
                    return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new cn(a)
                }, t.Path = vr, t.PerspectiveCamera = it, t.Plane = D, t.PlaneBufferGeometry = pt, t.PlaneGeometry = ht, t.PlaneHelper = Ea, t.PointCloud = function (a, b) {
                    return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new ln(a, b)
                }, t.PointCloudMaterial = function (a) {
                    return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new cn(a)
                }, t.PointLight = Dr, t.PointLightHelper = ma, t.Points = ln, t.PointsMaterial = cn, t.PolarGridHelper = ya, t.PolyhedronBufferGeometry = xn, t.PolyhedronGeometry = _n, t.PositionalAudio = Jr, t.PropertyBinding = ta, t.PropertyMixer = Qr, t.QuadraticBezierCurve = pr, t.QuadraticBezierCurve3 = fr, t.Quaternion = r, t.QuaternionKeyframeTrack = Ui, t.QuaternionLinearInterpolant = zi, t.REVISION = "112", t.RGBADepthPacking = 3201, t.RGBAFormat = 1023, t.RGBAIntegerFormat = 1033, t.RGBA_ASTC_10x10_Format = 37819, t.RGBA_ASTC_10x5_Format = 37816, t.RGBA_ASTC_10x6_Format = 37817, t.RGBA_ASTC_10x8_Format = 37818, t.RGBA_ASTC_12x10_Format = 37820, t.RGBA_ASTC_12x12_Format = 37821, t.RGBA_ASTC_4x4_Format = 37808, t.RGBA_ASTC_5x4_Format = 37809, t.RGBA_ASTC_5x5_Format = 37810, t.RGBA_ASTC_6x5_Format = 37811, t.RGBA_ASTC_6x6_Format = 37812, t.RGBA_ASTC_8x5_Format = 37813, t.RGBA_ASTC_8x6_Format = 37814, t.RGBA_ASTC_8x8_Format = 37815, t.RGBA_PVRTC_2BPPV1_Format = 35843, t.RGBA_PVRTC_4BPPV1_Format = 35842, t.RGBA_S3TC_DXT1_Format = 33777, t.RGBA_S3TC_DXT3_Format = 33778, t.RGBA_S3TC_DXT5_Format = 33779, t.RGBDEncoding = 3006, t.RGBEEncoding = 3002, t.RGBEFormat = 1023, t.RGBFormat = 1022, t.RGBIntegerFormat = 1032, t.RGBM16Encoding = 3005, t.RGBM7Encoding = 3004, t.RGB_ETC1_Format = 36196, t.RGB_PVRTC_2BPPV1_Format = 35841, t.RGB_PVRTC_4BPPV1_Format = 35840, t.RGB_S3TC_DXT1_Format = 33776, t.RGFormat = 1030, t.RGIntegerFormat = 1031, t.RawShaderMaterial = wi, t.Ray = T, t.Raycaster = aa, t.RectAreaLight = Rr, t.RedFormat = 1028, t.RedIntegerFormat = 1029, t.ReinhardToneMapping = 2, t.RepeatWrapping = 1e3, t.ReplaceStencilOp = 7681, t.ReverseSubtractEquation = 102, t.RingBufferGeometry = si, t.RingGeometry = oi, t.Scene = x, t.SceneUtils = {
                    createMultiMaterialObject: function () {
                        console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                    },
                    detach: function () {
                        console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                    },
                    attach: function () {
                        console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                    }
                }, t.ShaderChunk = Is, t.ShaderLib = ks, t.ShaderMaterial = et, t.ShadowMaterial = bi, t.Shape = yr, t.ShapeBufferGeometry = di, t.ShapeGeometry = hi, t.ShapePath = kr, t.ShapeUtils = Ou, t.ShortType = 1011, t.Skeleton = en, t.SkeletonHelper = fa, t.SkinnedMesh = tn, t.SmoothShading = 2, t.Sphere = E, t.SphereBufferGeometry = ai, t.SphereGeometry = ri, t.Spherical = ua, t.SphericalHarmonics3 = Gr, t.SphericalReflectionMapping = 305, t.Spline = Ua, t.SplineCurve = mr, t.SplineCurve3 = za, t.SpotLight = Er, t.SpotLightHelper = pa, t.SpotLightShadow = Mr, t.Sprite = $e, t.SpriteMaterial = Je, t.SrcAlphaFactor = 204, t.SrcAlphaSaturateFactor = 210, t.SrcColorFactor = 202, t.StaticCopyUsage = 35046, t.StaticDrawUsage = 35044, t.StaticReadUsage = 35045, t.StereoCamera = Yr, t.StreamCopyUsage = 35042, t.StreamDrawUsage = 35040, t.StreamReadUsage = 35041, t.StringKeyframeTrack = Hi, t.SubtractEquation = 101, t.SubtractiveBlending = 3, t.TOUCH = {
                    ROTATE: 0,
                    PAN: 1,
                    DOLLY_PAN: 2,
                    DOLLY_ROTATE: 3
                }, t.TangentSpaceNormalMap = 0, t.TetrahedronBufferGeometry = wn, t.TetrahedronGeometry = bn, t.TextBufferGeometry = ii, t.TextGeometry = ni, t.Texture = l, t.TextureLoader = Qi, t.TorusBufferGeometry = Fn, t.TorusGeometry = On, t.TorusKnotBufferGeometry = Pn, t.TorusKnotGeometry = Rn, t.Triangle = S, t.TriangleFanDrawMode = 2, t.TriangleStripDrawMode = 1, t.TrianglesDrawMode = 0, t.TubeBufferGeometry = Ln, t.TubeGeometry = Cn, t.UVMapping = 300, t.Uint16Attribute = function (a, b) {
                    return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new U(a, b)
                }, t.Uint16BufferAttribute = U, t.Uint32Attribute = function (a, b) {
                    return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new G(a, b)
                }, t.Uint32BufferAttribute = G, t.Uint8Attribute = function (a, b) {
                    return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new B(a, b)
                }, t.Uint8BufferAttribute = B, t.Uint8ClampedAttribute = function (a, b) {
                    return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new k(a, b)
                }, t.Uint8ClampedBufferAttribute = k, t.Uncharted2ToneMapping = 3, t.Uniform = ia, t.UniformsLib = Bs, t.UniformsUtils = Os, t.UnsignedByteType = 1009, t.UnsignedInt248Type = 1020, t.UnsignedIntType = 1014, t.UnsignedShort4444Type = 1017, t.UnsignedShort5551Type = 1018, t.UnsignedShort565Type = 1019, t.UnsignedShortType = 1012, t.VSMShadowMap = 3, t.Vector2 = n, t.Vector3 = o, t.Vector4 = h, t.VectorKeyframeTrack = dd, t.Vertex = function (a, b, t) {
                    return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new o(a, b, t)
                }, t.VertexColors = 2, t.VideoTexture = dn, t.WebGLMultisampleRenderTarget = f, t.WebGLRenderTarget = d, t.WebGLRenderTargetCube = ot, t.WebGLRenderer = We, t.WebGLUtils = ze, t.WireframeGeometry = gn, t.WireframeHelper = function (a, b) {
                    return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new sn(new gn(a.geometry), new an({
                        color: void 0 !== b ? b : 16777215
                    }))
                }, t.WrapAroundEnding = 2402, t.XHRLoader = function (a) {
                    return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Yi(a)
                }, t.ZeroCurvatureEnding = 2400, t.ZeroFactor = 200, t.ZeroSlopeEnding = 2401, t.ZeroStencilOp = 0, t.sRGBEncoding = 3001, Object.defineProperty(t, "__esModule", {
                    value: !0
                })
            }(e)
        },
        153: function (t, e, n) {
            "use strict";
            e.a = function (t, e) {
                return e = e || {}, new Promise((function (n, r) {
                    var s = new XMLHttpRequest,
                        o = [],
                        u = [],
                        i = {},
                        a = function () {
                            return {
                                ok: 2 == (s.status / 100 | 0),
                                statusText: s.statusText,
                                status: s.status,
                                url: s.responseURL,
                                text: function () {
                                    return Promise.resolve(s.responseText)
                                },
                                json: function () {
                                    return Promise.resolve(JSON.parse(s.responseText))
                                },
                                blob: function () {
                                    return Promise.resolve(new Blob([s.response]))
                                },
                                clone: a,
                                headers: {
                                    keys: function () {
                                        return o
                                    },
                                    entries: function () {
                                        return u
                                    },
                                    get: function (t) {
                                        return i[t.toLowerCase()]
                                    },
                                    has: function (t) {
                                        return t.toLowerCase() in i
                                    }
                                }
                            }
                        };
                    for (var c in s.open(e.method || "get", t, !0), s.onload = function () {
                            s.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, (function (t, e, n) {
                                o.push(e = e.toLowerCase()), u.push([e, n]), i[e] = i[e] ? i[e] + "," + n : n
                            })), n(a())
                        }, s.onerror = r, s.withCredentials = "include" == e.credentials, e.headers) s.setRequestHeader(c, e.headers[c]);
                    s.send(e.body || null)
                }))
            }
        },
        154: function (t, e, n) {
            "use strict";
            var r = function (t) {
                return function (t) {
                    return !!t && "object" == typeof t
                }(t) && ! function (t) {
                    var e = Object.prototype.toString.call(t);
                    return "[object RegExp]" === e || "[object Date]" === e || function (t) {
                        return t.$$typeof === o
                    }(t)
                }(t)
            };
            var o = "function" == typeof Symbol && Symbol.for ? Symbol.for("react.element") : 60103;

            function c(t, e) {
                return !1 !== e.clone && e.isMergeableObject(t) ? m((n = t, Array.isArray(n) ? [] : {}), t, e) : t;
                var n
            }

            function l(t, source, e) {
                return t.concat(source).map((function (element) {
                    return c(element, e)
                }))
            }

            function h(t) {
                return Object.keys(t).concat(function (t) {
                    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(t).filter((function (symbol) {
                        return t.propertyIsEnumerable(symbol)
                    })) : []
                }(t))
            }

            function d(object, t) {
                try {
                    return t in object
                } catch (t) {
                    return !1
                }
            }

            function f(t, source, e) {
                var n = {};
                return e.isMergeableObject(t) && h(t).forEach((function (r) {
                    n[r] = c(t[r], e)
                })), h(source).forEach((function (r) {
                    (function (t, e) {
                        return d(t, e) && !(Object.hasOwnProperty.call(t, e) && Object.propertyIsEnumerable.call(t, e))
                    })(t, r) || (d(t, r) && e.isMergeableObject(source[r]) ? n[r] = function (t, e) {
                        if (!e.customMerge) return m;
                        var n = e.customMerge(t);
                        return "function" == typeof n ? n : m
                    }(r, e)(t[r], source[r], e) : n[r] = c(source[r], e))
                })), n
            }

            function m(t, source, e) {
                (e = e || {}).arrayMerge = e.arrayMerge || l, e.isMergeableObject = e.isMergeableObject || r, e.cloneUnlessOtherwiseSpecified = c;
                var n = Array.isArray(source);
                return n === Array.isArray(t) ? n ? e.arrayMerge(t, source, e) : f(t, source, e) : c(source, e)
            }
            m.all = function (t, e) {
                if (!Array.isArray(t)) throw new Error("first argument should be an array");
                return t.reduce((function (t, n) {
                    return m(t, n, e)
                }), {})
            };
            var v = m;
            t.exports = v
        },
        164: function (t, e) {
            function n(t) {
                return null !== t && "object" == typeof t && !Array.isArray(t)
            }
            t.exports = function t(e, r) {
                if (!n(e)) return t({}, r);
                if (!n(r)) return t(e, {});
                var o = Object.assign({}, r);
                return Object.keys(e).forEach(r => {
                    if ("__proto__" !== r && "constructor" !== r) {
                        var c = e[r];
                        null !== c && (n(c) && n(o[r]) ? o[r] = t(c, o[r]) : o[r] = c)
                    }
                }), o
            }
        },
        205: function (t, e, n) {
            "use strict";
            t.exports = function (t, e) {
                return e || (e = {}), "string" != typeof (t = t && t.__esModule ? t.default : t) ? t : (/^['"].*['"]$/.test(t) && (t = t.slice(1, -1)), e.hash && (t += e.hash), /["'() \t\n]/.test(t) || e.needQuotes ? '"'.concat(t.replace(/"/g, '\\"').replace(/\n/g, "\\n"), '"') : t)
            }
        },
        286: function (t, e, n) {
            "use strict";
            n.r(e), n.d(e, "ScrollToPlugin", (function () {
                return T
            })), n.d(e, "default", (function () {
                return T
            }));
            var r, o, c, l, h, d, f, m = function () {
                    return "undefined" != typeof window
                },
                v = function () {
                    return r || m() && (r = window.gsap) && r.registerPlugin && r
                },
                y = function (t) {
                    return "string" == typeof t
                },
                _ = function (element, t) {
                    var e = "x" === t ? "Width" : "Height",
                        n = "scroll" + e,
                        r = "client" + e;
                    return element === c || element === l || element === h ? Math.max(l[n], h[n]) - (c["inner" + e] || l[r] || h[r]) : element[n] - element["offset" + e]
                },
                x = function (t, e) {
                    var p = "scroll" + ("x" === e ? "Left" : "Top");
                    return t === c && (null != t.pageXOffset ? p = "page" + e.toUpperCase() + "Offset" : t = null != l[p] ? l : h),
                        function () {
                            return t[p]
                        }
                },
                w = function (element, t) {
                    var rect = d(element)[0].getBoundingClientRect(),
                        e = !t || t === c || t === h,
                        n = e ? {
                            top: l.clientTop - (c.pageYOffset || l.scrollTop || h.scrollTop || 0),
                            left: l.clientLeft - (c.pageXOffset || l.scrollLeft || h.scrollLeft || 0)
                        } : t.getBoundingClientRect(),
                        r = {
                            x: rect.left - n.left,
                            y: rect.top - n.top
                        };
                    return !e && t && (r.x += x(t, "x")(), r.y += x(t, "y")()), r
                },
                M = function (t, e, n, r) {
                    return isNaN(t) ? y(t) && "=" === t.charAt(1) ? parseFloat(t.substr(2)) * ("-" === t.charAt(0) ? -1 : 1) + r : "max" === t ? _(e, n) : Math.min(_(e, n), w(t, e)[n]) : parseFloat(t)
                },
                E = function () {
                    r = v(), m() && r && document.body && (c = window, h = document.body, l = document.documentElement, d = r.utils.toArray, r.config({
                        autoKillThreshold: 7
                    }), f = r.config(), o = 1)
                },
                T = {
                    version: "3.0.2",
                    name: "scrollTo",
                    rawVars: 1,
                    register: function (t) {
                        r = t, E()
                    },
                    init: function (t, e, n, r, l) {
                        o || E();
                        this.isWin = t === c, this.target = t, this.tween = n, "object" != typeof e ? y((e = {
                            y: e
                        }).y) && "max" !== e.y && "=" !== e.y.charAt(1) && (e.x = e.y) : e.nodeType && (e = {
                            y: e,
                            x: e
                        }), this.vars = e, this.autoKill = !!e.autoKill, this.getX = x(t, "x"), this.getY = x(t, "y"), this.x = this.xPrev = this.getX(), this.y = this.yPrev = this.getY(), null != e.x ? (this.add(this, "x", this.x, M(e.x, t, "x", this.x) - (e.offsetX || 0), r, l, Math.round), this._props.push("scrollTo_x")) : this.skipX = 1, null != e.y ? (this.add(this, "y", this.y, M(e.y, t, "y", this.y) - (e.offsetY || 0), r, l, Math.round), this._props.push("scrollTo_y")) : this.skipY = 1
                    },
                    render: function (t, data) {
                        for (var e, n, r, o, l, h = data._pt, d = data.target, m = data.tween, v = data.autoKill, y = data.xPrev, x = data.yPrev, w = data.isWin; h;) h.r(t, h.d), h = h._next;
                        e = w || !data.skipX ? data.getX() : y, r = (n = w || !data.skipY ? data.getY() : x) - x, o = e - y, l = f.autoKillThreshold, data.x < 0 && (data.x = 0), data.y < 0 && (data.y = 0), v && (!data.skipX && (o > l || o < -l) && e < _(d, "x") && (data.skipX = 1), !data.skipY && (r > l || r < -l) && n < _(d, "y") && (data.skipY = 1), data.skipX && data.skipY && (m.kill(), data.vars.onAutoKill && data.vars.onAutoKill.apply(m, data.vars.onAutoKillParams || []))), w ? c.scrollTo(data.skipX ? e : data.x, data.skipY ? n : data.y) : (data.skipY || (d.scrollTop = data.y), data.skipX || (d.scrollLeft = data.x)), data.xPrev = data.x, data.yPrev = data.y
                    },
                    kill: function (t) {
                        var e = "scrollTo" === t;
                        (e || "scrollTo_x" === t) && (this.skipX = 1), (e || "scrollTo_y" === t) && (this.skipY = 1)
                    }
                };
            T.max = _, T.getOffset = w, T.buildGetter = x, v() && r.registerPlugin(T)
        },
        288: function (t, e) {
            THREE.OrbitControls = function (object, t) {
                var e, n, r, o, c;
                void 0 === t && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'), t === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), this.object = object, this.domElement = t, this.enabled = !0, this.target = new THREE.Vector3, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !1, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.enableKeys = !0, this.keys = {
                    LEFT: 37,
                    UP: 38,
                    RIGHT: 39,
                    BOTTOM: 40
                }, this.mouseButtons = {
                    LEFT: THREE.MOUSE.ROTATE,
                    MIDDLE: THREE.MOUSE.DOLLY,
                    RIGHT: THREE.MOUSE.PAN
                }, this.touches = {
                    ONE: THREE.TOUCH.ROTATE,
                    TWO: THREE.TOUCH.DOLLY_PAN
                }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = function () {
                    return _.phi
                }, this.getAzimuthalAngle = function () {
                    return _.theta
                }, this.saveState = function () {
                    l.target0.copy(l.target), l.position0.copy(l.object.position), l.zoom0 = l.object.zoom
                }, this.reset = function () {
                    l.target.copy(l.target0), l.object.position.copy(l.position0), l.object.zoom = l.zoom0, l.object.updateProjectionMatrix(), l.dispatchEvent(h), l.update(), v = m.NONE
                }, this.update = (e = new THREE.Vector3, n = (new THREE.Quaternion).setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0)), r = n.clone().inverse(), o = new THREE.Vector3, c = new THREE.Quaternion, function () {
                    var t = l.object.position;
                    return e.copy(t).sub(l.target), e.applyQuaternion(n), _.setFromVector3(e), l.autoRotate && v === m.NONE && N(2 * Math.PI / 60 / 60 * l.autoRotateSpeed), l.enableDamping ? (_.theta += x.theta * l.dampingFactor, _.phi += x.phi * l.dampingFactor) : (_.theta += x.theta, _.phi += x.phi), _.theta = Math.max(l.minAzimuthAngle, Math.min(l.maxAzimuthAngle, _.theta)), _.phi = Math.max(l.minPolarAngle, Math.min(l.maxPolarAngle, _.phi)), _.makeSafe(), _.radius *= w, _.radius = Math.max(l.minDistance, Math.min(l.maxDistance, _.radius)), !0 === l.enableDamping ? l.target.addScaledVector(M, l.dampingFactor) : l.target.add(M), e.setFromSpherical(_), e.applyQuaternion(r), t.copy(l.target).add(e), l.object.lookAt(l.target), !0 === l.enableDamping ? (x.theta *= 1 - l.dampingFactor, x.phi *= 1 - l.dampingFactor, M.multiplyScalar(1 - l.dampingFactor)) : (x.set(0, 0, 0), M.set(0, 0, 0)), w = 1, !!(E || o.distanceToSquared(l.object.position) > y || 8 * (1 - c.dot(l.object.quaternion)) > y) && (l.dispatchEvent(h), o.copy(l.object.position), c.copy(l.object.quaternion), E = !1, !0)
                }), this.dispose = function () {
                    l.domElement.removeEventListener("contextmenu", st, !1), l.domElement.removeEventListener("mousedown", Q, !1), l.domElement.removeEventListener("wheel", et, !1), l.domElement.removeEventListener("touchstart", it, !1), l.domElement.removeEventListener("touchend", ot, !1), l.domElement.removeEventListener("touchmove", at, !1), document.removeEventListener("mousemove", K, !1), document.removeEventListener("mouseup", tt, !1), l.domElement.removeEventListener("keydown", nt, !1)
                };
                var l = this,
                    h = {
                        type: "change"
                    },
                    d = {
                        type: "start"
                    },
                    f = {
                        type: "end"
                    },
                    m = {
                        NONE: -1,
                        ROTATE: 0,
                        DOLLY: 1,
                        PAN: 2,
                        TOUCH_ROTATE: 3,
                        TOUCH_PAN: 4,
                        TOUCH_DOLLY_PAN: 5,
                        TOUCH_DOLLY_ROTATE: 6
                    },
                    v = m.NONE,
                    y = 1e-6,
                    _ = new THREE.Spherical,
                    x = new THREE.Spherical,
                    w = 1,
                    M = new THREE.Vector3,
                    E = !1,
                    T = new THREE.Vector2,
                    D = new THREE.Vector2,
                    S = new THREE.Vector2,
                    A = new THREE.Vector2,
                    C = new THREE.Vector2,
                    L = new THREE.Vector2,
                    R = new THREE.Vector2,
                    P = new THREE.Vector2,
                    O = new THREE.Vector2;

                function F() {
                    return Math.pow(.95, l.zoomSpeed)
                }

                function N(t) {
                    x.theta -= t
                }

                function I(t) {
                    x.phi -= t
                }
                var B, k = (B = new THREE.Vector3, function (t, e) {
                        B.setFromMatrixColumn(e, 0), B.multiplyScalar(-t), M.add(B)
                    }),
                    z = function () {
                        var t = new THREE.Vector3;
                        return function (e, n) {
                            !0 === l.screenSpacePanning ? t.setFromMatrixColumn(n, 1) : (t.setFromMatrixColumn(n, 0), t.crossVectors(l.object.up, t)), t.multiplyScalar(e), M.add(t)
                        }
                    }(),
                    U = function () {
                        var t = new THREE.Vector3;
                        return function (e, n) {
                            var element = l.domElement;
                            if (l.object.isPerspectiveCamera) {
                                var r = l.object.position;
                                t.copy(r).sub(l.target);
                                var o = t.length();
                                o *= Math.tan(l.object.fov / 2 * Math.PI / 180), k(2 * e * o / element.clientHeight, l.object.matrix), z(2 * n * o / element.clientHeight, l.object.matrix)
                            } else l.object.isOrthographicCamera ? (k(e * (l.object.right - l.object.left) / l.object.zoom / element.clientWidth, l.object.matrix), z(n * (l.object.top - l.object.bottom) / l.object.zoom / element.clientHeight, l.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), l.enablePan = !1)
                        }
                    }();

                function H(t) {
                    l.object.isPerspectiveCamera ? w /= t : l.object.isOrthographicCamera ? (l.object.zoom = Math.max(l.minZoom, Math.min(l.maxZoom, l.object.zoom * t)), l.object.updateProjectionMatrix(), E = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), l.enableZoom = !1)
                }

                function G(t) {
                    l.object.isPerspectiveCamera ? w *= t : l.object.isOrthographicCamera ? (l.object.zoom = Math.max(l.minZoom, Math.min(l.maxZoom, l.object.zoom / t)), l.object.updateProjectionMatrix(), E = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), l.enableZoom = !1)
                }

                function V(t) {
                    T.set(t.clientX, t.clientY)
                }

                function j(t) {
                    A.set(t.clientX, t.clientY)
                }

                function W(t) {
                    if (1 == t.touches.length) T.set(t.touches[0].pageX, t.touches[0].pageY);
                    else {
                        var e = .5 * (t.touches[0].pageX + t.touches[1].pageX),
                            n = .5 * (t.touches[0].pageY + t.touches[1].pageY);
                        T.set(e, n)
                    }
                }

                function Y(t) {
                    if (1 == t.touches.length) A.set(t.touches[0].pageX, t.touches[0].pageY);
                    else {
                        var e = .5 * (t.touches[0].pageX + t.touches[1].pageX),
                            n = .5 * (t.touches[0].pageY + t.touches[1].pageY);
                        A.set(e, n)
                    }
                }

                function X(t) {
                    var e = t.touches[0].pageX - t.touches[1].pageX,
                        n = t.touches[0].pageY - t.touches[1].pageY,
                        r = Math.sqrt(e * e + n * n);
                    R.set(0, r)
                }

                function Z(t) {
                    if (1 == t.touches.length) D.set(t.touches[0].pageX, t.touches[0].pageY);
                    else {
                        var e = .5 * (t.touches[0].pageX + t.touches[1].pageX),
                            n = .5 * (t.touches[0].pageY + t.touches[1].pageY);
                        D.set(e, n)
                    }
                    S.subVectors(D, T).multiplyScalar(l.rotateSpeed);
                    var element = l.domElement;
                    N(2 * Math.PI * S.x / element.clientHeight), I(2 * Math.PI * S.y / element.clientHeight), T.copy(D)
                }

                function J(t) {
                    if (1 == t.touches.length) C.set(t.touches[0].pageX, t.touches[0].pageY);
                    else {
                        var e = .5 * (t.touches[0].pageX + t.touches[1].pageX),
                            n = .5 * (t.touches[0].pageY + t.touches[1].pageY);
                        C.set(e, n)
                    }
                    L.subVectors(C, A).multiplyScalar(l.panSpeed), U(L.x, L.y), A.copy(C)
                }

                function $(t) {
                    var e = t.touches[0].pageX - t.touches[1].pageX,
                        n = t.touches[0].pageY - t.touches[1].pageY,
                        r = Math.sqrt(e * e + n * n);
                    P.set(0, r), O.set(0, Math.pow(P.y / R.y, l.zoomSpeed)), H(O.y), R.copy(P)
                }

                function Q(t) {
                    if (!1 !== l.enabled) {
                        switch (t.preventDefault(), l.domElement.focus ? l.domElement.focus() : window.focus(), t.button) {
                            case 0:
                                switch (l.mouseButtons.LEFT) {
                                    case THREE.MOUSE.ROTATE:
                                        if (t.ctrlKey || t.metaKey || t.shiftKey) {
                                            if (!1 === l.enablePan) return;
                                            j(t), v = m.PAN
                                        } else {
                                            if (!1 === l.enableRotate) return;
                                            V(t), v = m.ROTATE
                                        }
                                        break;
                                    case THREE.MOUSE.PAN:
                                        if (t.ctrlKey || t.metaKey || t.shiftKey) {
                                            if (!1 === l.enableRotate) return;
                                            V(t), v = m.ROTATE
                                        } else {
                                            if (!1 === l.enablePan) return;
                                            j(t), v = m.PAN
                                        }
                                        break;
                                    default:
                                        v = m.NONE
                                }
                                break;
                            case 1:
                                switch (l.mouseButtons.MIDDLE) {
                                    case THREE.MOUSE.DOLLY:
                                        if (!1 === l.enableZoom) return;
                                        ! function (t) {
                                            R.set(t.clientX, t.clientY)
                                        }(t), v = m.DOLLY;
                                        break;
                                    default:
                                        v = m.NONE
                                }
                                break;
                            case 2:
                                switch (l.mouseButtons.RIGHT) {
                                    case THREE.MOUSE.ROTATE:
                                        if (!1 === l.enableRotate) return;
                                        V(t), v = m.ROTATE;
                                        break;
                                    case THREE.MOUSE.PAN:
                                        if (!1 === l.enablePan) return;
                                        j(t), v = m.PAN;
                                        break;
                                    default:
                                        v = m.NONE
                                }
                        }
                        v !== m.NONE && (document.addEventListener("mousemove", K, !1), document.addEventListener("mouseup", tt, !1), l.dispatchEvent(d))
                    }
                }

                function K(t) {
                    if (!1 !== l.enabled) switch (t.preventDefault(), v) {
                        case m.ROTATE:
                            if (!1 === l.enableRotate) return;
                            ! function (t) {
                                D.set(t.clientX, t.clientY), S.subVectors(D, T).multiplyScalar(l.rotateSpeed);
                                var element = l.domElement;
                                N(2 * Math.PI * S.x / element.clientHeight), I(2 * Math.PI * S.y / element.clientHeight), T.copy(D), l.update()
                            }(t);
                            break;
                        case m.DOLLY:
                            if (!1 === l.enableZoom) return;
                            ! function (t) {
                                P.set(t.clientX, t.clientY), O.subVectors(P, R), O.y > 0 ? H(F()) : O.y < 0 && G(F()), R.copy(P), l.update()
                            }(t);
                            break;
                        case m.PAN:
                            if (!1 === l.enablePan) return;
                            ! function (t) {
                                C.set(t.clientX, t.clientY), L.subVectors(C, A).multiplyScalar(l.panSpeed), U(L.x, L.y), A.copy(C), l.update()
                            }(t)
                    }
                }

                function tt(t) {
                    !1 !== l.enabled && (document.removeEventListener("mousemove", K, !1), document.removeEventListener("mouseup", tt, !1), l.dispatchEvent(f), v = m.NONE)
                }

                function et(t) {
                    !1 === l.enabled || !1 === l.enableZoom || v !== m.NONE && v !== m.ROTATE || (t.preventDefault(), t.stopPropagation(), l.dispatchEvent(d), function (t) {
                        t.deltaY < 0 ? G(F()) : t.deltaY > 0 && H(F()), l.update()
                    }(t), l.dispatchEvent(f))
                }

                function nt(t) {
                    !1 !== l.enabled && !1 !== l.enableKeys && !1 !== l.enablePan && function (t) {
                        var e = !1;
                        switch (t.keyCode) {
                            case l.keys.UP:
                                U(0, l.keyPanSpeed), e = !0;
                                break;
                            case l.keys.BOTTOM:
                                U(0, -l.keyPanSpeed), e = !0;
                                break;
                            case l.keys.LEFT:
                                U(l.keyPanSpeed, 0), e = !0;
                                break;
                            case l.keys.RIGHT:
                                U(-l.keyPanSpeed, 0), e = !0
                        }
                        e && (t.preventDefault(), l.update())
                    }(t)
                }

                function it(t) {
                    if (!1 !== l.enabled) {
                        switch (t.preventDefault(), t.touches.length) {
                            case 1:
                                switch (l.touches.ONE) {
                                    case THREE.TOUCH.ROTATE:
                                        if (!1 === l.enableRotate) return;
                                        W(t), v = m.TOUCH_ROTATE;
                                        break;
                                    case THREE.TOUCH.PAN:
                                        if (!1 === l.enablePan) return;
                                        Y(t), v = m.TOUCH_PAN;
                                        break;
                                    default:
                                        v = m.NONE
                                }
                                break;
                            case 2:
                                switch (l.touches.TWO) {
                                    case THREE.TOUCH.DOLLY_PAN:
                                        if (!1 === l.enableZoom && !1 === l.enablePan) return;
                                        ! function (t) {
                                            l.enableZoom && X(t), l.enablePan && Y(t)
                                        }(t), v = m.TOUCH_DOLLY_PAN;
                                        break;
                                    case THREE.TOUCH.DOLLY_ROTATE:
                                        if (!1 === l.enableZoom && !1 === l.enableRotate) return;
                                        ! function (t) {
                                            l.enableZoom && X(t), l.enableRotate && W(t)
                                        }(t), v = m.TOUCH_DOLLY_ROTATE;
                                        break;
                                    default:
                                        v = m.NONE
                                }
                                break;
                            default:
                                v = m.NONE
                        }
                        v !== m.NONE && l.dispatchEvent(d)
                    }
                }

                function at(t) {
                    if (!1 !== l.enabled) switch (t.preventDefault(), t.stopPropagation(), v) {
                        case m.TOUCH_ROTATE:
                            if (!1 === l.enableRotate) return;
                            Z(t), l.update();
                            break;
                        case m.TOUCH_PAN:
                            if (!1 === l.enablePan) return;
                            J(t), l.update();
                            break;
                        case m.TOUCH_DOLLY_PAN:
                            if (!1 === l.enableZoom && !1 === l.enablePan) return;
                            ! function (t) {
                                l.enableZoom && $(t), l.enablePan && J(t)
                            }(t), l.update();
                            break;
                        case m.TOUCH_DOLLY_ROTATE:
                            if (!1 === l.enableZoom && !1 === l.enableRotate) return;
                            ! function (t) {
                                l.enableZoom && $(t), l.enableRotate && Z(t)
                            }(t), l.update();
                            break;
                        default:
                            v = m.NONE
                    }
                }

                function ot(t) {
                    !1 !== l.enabled && (l.dispatchEvent(f), v = m.NONE)
                }

                function st(t) {
                    !1 !== l.enabled && t.preventDefault()
                }
                l.domElement.addEventListener("contextmenu", st, !1), l.domElement.addEventListener("mousedown", Q, !1), l.domElement.addEventListener("wheel", et, !1), l.domElement.addEventListener("touchstart", it, !1), l.domElement.addEventListener("touchend", ot, !1), l.domElement.addEventListener("touchmove", at, !1), l.domElement.addEventListener("keydown", nt, !1), -1 === l.domElement.tabIndex && (l.domElement.tabIndex = 0), this.update()
            }, THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype), THREE.OrbitControls.prototype.constructor = THREE.OrbitControls, THREE.MapControls = function (object, t) {
                THREE.OrbitControls.call(this, object, t), this.mouseButtons.LEFT = THREE.MOUSE.PAN, this.mouseButtons.RIGHT = THREE.MOUSE.ROTATE, this.touches.ONE = THREE.TOUCH.PAN, this.touches.TWO = THREE.TOUCH.DOLLY_ROTATE
            }, THREE.MapControls.prototype = Object.create(THREE.EventDispatcher.prototype), THREE.MapControls.prototype.constructor = THREE.MapControls
        },
        289: function (t, e) {
            var n, r, o;
            THREE.EffectComposer = function (t, e) {
                if (this.renderer = t, void 0 === e) {
                    var n = {
                            minFilter: THREE.LinearFilter,
                            magFilter: THREE.LinearFilter,
                            format: THREE.RGBAFormat,
                            stencilBuffer: !1
                        },
                        r = t.getSize(new THREE.Vector2);
                    this._pixelRatio = t.getPixelRatio(), this._width = r.width, this._height = r.height, (e = new THREE.WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, n)).texture.name = "EffectComposer.rt1"
                } else this._pixelRatio = 1, this._width = e.width, this._height = e.height;
                this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], void 0 === THREE.CopyShader && console.error("THREE.EffectComposer relies on THREE.CopyShader"), void 0 === THREE.ShaderPass && console.error("THREE.EffectComposer relies on THREE.ShaderPass"), this.copyPass = new THREE.ShaderPass(THREE.CopyShader), this.clock = new THREE.Clock
            }, Object.assign(THREE.EffectComposer.prototype, {
                swapBuffers: function () {
                    var t = this.readBuffer;
                    this.readBuffer = this.writeBuffer, this.writeBuffer = t
                },
                addPass: function (t) {
                    this.passes.push(t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
                },
                insertPass: function (t, e) {
                    this.passes.splice(e, 0, t)
                },
                isLastEnabledPass: function (t) {
                    for (var i = t + 1; i < this.passes.length; i++)
                        if (this.passes[i].enabled) return !1;
                    return !0
                },
                render: function (t) {
                    void 0 === t && (t = this.clock.getDelta());
                    var e, i, n = this.renderer.getRenderTarget(),
                        r = !1,
                        o = this.passes.length;
                    for (i = 0; i < o; i++)
                        if (!1 !== (e = this.passes[i]).enabled) {
                            if (e.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i), e.render(this.renderer, this.writeBuffer, this.readBuffer, t, r), e.needsSwap) {
                                if (r) {
                                    var c = this.renderer.getContext(),
                                        l = this.renderer.state.buffers.stencil;
                                    l.setFunc(c.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t), l.setFunc(c.EQUAL, 1, 4294967295)
                                }
                                this.swapBuffers()
                            }
                            void 0 !== THREE.MaskPass && (e instanceof THREE.MaskPass ? r = !0 : e instanceof THREE.ClearMaskPass && (r = !1))
                        } this.renderer.setRenderTarget(n)
                },
                reset: function (t) {
                    if (void 0 === t) {
                        var e = this.renderer.getSize(new THREE.Vector2);
                        this._pixelRatio = this.renderer.getPixelRatio(), this._width = e.width, this._height = e.height, (t = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
                    }
                    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2
                },
                setSize: function (t, e) {
                    this._width = t, this._height = e;
                    var n = this._width * this._pixelRatio,
                        r = this._height * this._pixelRatio;
                    this.renderTarget1.setSize(n, r), this.renderTarget2.setSize(n, r);
                    for (var i = 0; i < this.passes.length; i++) this.passes[i].setSize(n, r)
                },
                setPixelRatio: function (t) {
                    this._pixelRatio = t, this.setSize(this._width, this._height)
                }
            }), THREE.Pass = function () {
                this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1
            }, Object.assign(THREE.Pass.prototype, {
                setSize: function () {},
                render: function () {
                    console.error("THREE.Pass: .render() must be implemented in derived pass.")
                }
            }), THREE.Pass.FullScreenQuad = (n = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1), r = new THREE.PlaneBufferGeometry(2, 2), o = function (t) {
                this._mesh = new THREE.Mesh(r, t)
            }, Object.defineProperty(o.prototype, "material", {
                get: function () {
                    return this._mesh.material
                },
                set: function (t) {
                    this._mesh.material = t
                }
            }), Object.assign(o.prototype, {
                dispose: function () {
                    this._mesh.geometry.dispose()
                },
                render: function (t) {
                    t.render(this._mesh, n)
                }
            }), o)
        },
        290: function (t, e) {
            THREE.ShaderPass = function (t, e) {
                THREE.Pass.call(this), this.textureID = void 0 !== e ? e : "tDiffuse", t instanceof THREE.ShaderMaterial ? (this.uniforms = t.uniforms, this.material = t) : t && (this.uniforms = THREE.UniformsUtils.clone(t.uniforms), this.material = new THREE.ShaderMaterial({
                    defines: Object.assign({}, t.defines),
                    uniforms: this.uniforms,
                    vertexShader: t.vertexShader,
                    fragmentShader: t.fragmentShader
                })), this.fsQuad = new THREE.Pass.FullScreenQuad(this.material)
            }, THREE.ShaderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
                constructor: THREE.ShaderPass,
                render: function (t, e, n) {
                    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), this.fsQuad.render(t))
                }
            })
        },
        291: function (t, e) {
            THREE.MaskPass = function (t, e) {
                THREE.Pass.call(this), this.scene = t, this.camera = e, this.clear = !0, this.needsSwap = !1, this.inverse = !1
            }, THREE.MaskPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
                constructor: THREE.MaskPass,
                render: function (t, e, n) {
                    var r, o, c = t.getContext(),
                        l = t.state;
                    l.buffers.color.setMask(!1), l.buffers.depth.setMask(!1), l.buffers.color.setLocked(!0), l.buffers.depth.setLocked(!0), this.inverse ? (r = 0, o = 1) : (r = 1, o = 0), l.buffers.stencil.setTest(!0), l.buffers.stencil.setOp(c.REPLACE, c.REPLACE, c.REPLACE), l.buffers.stencil.setFunc(c.ALWAYS, r, 4294967295), l.buffers.stencil.setClear(o), l.buffers.stencil.setLocked(!0), t.setRenderTarget(n), this.clear && t.clear(), t.render(this.scene, this.camera), t.setRenderTarget(e), this.clear && t.clear(), t.render(this.scene, this.camera), l.buffers.color.setLocked(!1), l.buffers.depth.setLocked(!1), l.buffers.stencil.setLocked(!1), l.buffers.stencil.setFunc(c.EQUAL, 1, 4294967295), l.buffers.stencil.setOp(c.KEEP, c.KEEP, c.KEEP), l.buffers.stencil.setLocked(!0)
                }
            }), THREE.ClearMaskPass = function () {
                THREE.Pass.call(this), this.needsSwap = !1
            }, THREE.ClearMaskPass.prototype = Object.create(THREE.Pass.prototype), Object.assign(THREE.ClearMaskPass.prototype, {
                render: function (t) {
                    t.state.buffers.stencil.setLocked(!1), t.state.buffers.stencil.setTest(!1)
                }
            })
        },
        292: function (t, e) {
            THREE.RenderPass = function (t, e, n, r, o) {
                THREE.Pass.call(this), this.scene = t, this.camera = e, this.overrideMaterial = n, this.clearColor = r, this.clearAlpha = void 0 !== o ? o : 0, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1
            }, THREE.RenderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
                constructor: THREE.RenderPass,
                render: function (t, e, n) {
                    var r, o, c = t.autoClear;
                    t.autoClear = !1, this.scene.overrideMaterial = this.overrideMaterial, this.clearColor && (r = t.getClearColor().getHex(), o = t.getClearAlpha(), t.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && t.clearDepth(), t.setRenderTarget(this.renderToScreen ? null : n), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), t.render(this.scene, this.camera), this.clearColor && t.setClearColor(r, o), this.scene.overrideMaterial = null, t.autoClear = c
                }
            })
        },
        293: function (t, e) {
            THREE.CopyShader = {
                uniforms: {
                    tDiffuse: {
                        value: null
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: ["varying vec2 vUv;", "void main() {", "\tvUv = uv;", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
                fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "\tvec4 texel = texture2D( tDiffuse, vUv );", "\tgl_FragColor = opacity * texel;", "}"].join("\n")
            }
        },
        309: function (t, e, n) {
            "use strict";

            function r(t) {
                if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t
            }

            function o(t, e) {
                t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
            }
            n.r(e);
            var c, l, h, d, f, m, v, y, _, x, w, M, E, T, D, S, A, C, L, R, P, O, F, N, I = {
                    autoSleep: 120,
                    force3D: "auto",
                    nullTargetWarn: 1,
                    units: {
                        lineHeight: ""
                    }
                },
                B = {
                    duration: .5,
                    overwrite: !1,
                    delay: 0
                },
                k = 1e-8,
                z = 2 * Math.PI,
                U = z / 4,
                H = 0,
                G = Math.sqrt,
                V = Math.cos,
                j = Math.sin,
                W = function (t) {
                    return "string" == typeof t
                },
                Y = function (t) {
                    return "function" == typeof t
                },
                X = function (t) {
                    return "number" == typeof t
                },
                Z = function (t) {
                    return void 0 === t
                },
                J = function (t) {
                    return "object" == typeof t
                },
                $ = function (t) {
                    return !1 !== t
                },
                Q = function () {
                    return "undefined" != typeof window
                },
                K = function (t) {
                    return Y(t) || W(t)
                },
                tt = Array.isArray,
                et = /(?:-?\.?\d|\.)+/gi,
                nt = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi,
                it = /[-+=\.]*\d+(?:\.|e-|e)*\d*/gi,
                at = /\(([^()]+)\)/i,
                ot = /[\+-]=-?[\.\d]+/,
                st = /[#\-+\.]*\b[a-z\d-=+%.]+/gi,
                ut = {},
                ct = {},
                lt = function (t) {
                    return (ct = Bt(t, ut)) && dn
                },
                ht = function (t, e) {
                    return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()")
                },
                pt = function (t, e) {
                    return !e && console.warn(t)
                },
                ft = function (t, e) {
                    return t && (ut[t] = e) && ct && (ct[t] = e) || ut
                },
                mt = function () {
                    return 0
                },
                gt = {},
                vt = [],
                yt = {},
                _t = {},
                xt = {},
                bt = 30,
                wt = [],
                Mt = "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
                Et = function (t) {
                    var e, i, n = t[0];
                    if (J(n) || Y(n) || (t = [t]), !(e = (n._gsap || {}).harness)) {
                        for (i = wt.length; i-- && !wt[i].targetTest(n););
                        e = wt[i]
                    }
                    for (i = t.length; i--;) t[i] && (t[i]._gsap || (t[i]._gsap = new Ie(t[i], e))) || t.splice(i, 1);
                    return t
                },
                Tt = function (t) {
                    return t._gsap || Et(ae(t))[0]._gsap
                },
                Dt = function (t, e) {
                    var n = t[e];
                    return Y(n) ? t[e]() : Z(n) && t.getAttribute(e) || n
                },
                St = function (t, e) {
                    return (t = t.split(",")).forEach(e) || t
                },
                At = function (t) {
                    return Math.round(1e4 * t) / 1e4
                },
                Ct = function (t, e) {
                    for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n;);
                    return i < n
                },
                Lt = function (t, e, n) {
                    var i, r = X(t[1]),
                        o = (r ? 2 : 1) + (e < 2 ? 0 : 1),
                        c = t[o];
                    return r && (c.duration = t[1]), 1 === e ? (c.runBackwards = 1, c.immediateRender = $(c.immediateRender)) : 2 === e && (i = t[o - 1], c.startAt = i, c.immediateRender = $(c.immediateRender)), c.parent = n, c
                },
                Rt = function () {
                    var i, t, e = vt.length,
                        a = vt.slice(0);
                    for (yt = {}, vt.length = 0, i = 0; i < e; i++)(t = a[i]) && t._lazy && (t.render(t._lazy[0], t._lazy[1], !0)._lazy = 0)
                },
                Pt = function (t, time, e, n) {
                    vt.length && Rt(), t.render(time, e, n), vt.length && Rt()
                },
                Ot = function (t) {
                    var e = parseFloat(t);
                    return e || 0 === e ? e : t
                },
                Ft = function (p) {
                    return p
                },
                Nt = function (t, e) {
                    for (var p in e) p in t || (t[p] = e[p]);
                    return t
                },
                It = function (t, e) {
                    for (var p in e) p in t || "duration" === p || "ease" === p || (t[p] = e[p])
                },
                Bt = function (base, t) {
                    for (var p in t) base[p] = t[p];
                    return base
                },
                kt = function t(base, e) {
                    for (var p in e) base[p] = J(e[p]) ? t(base[p] || (base[p] = {}), e[p]) : e[p];
                    return base
                },
                zt = function (t, e) {
                    var p, n = {};
                    for (p in t) p in e || (n[p] = t[p]);
                    return n
                },
                Ut = function (t) {
                    var e = t.parent || c,
                        n = t.keyframes ? It : Nt;
                    if ($(t.inherit))
                        for (; e;) n(t, e.vars.defaults), e = e.parent;
                    return t
                },
                Ht = function (t, e, n, r) {
                    void 0 === n && (n = "_first"), void 0 === r && (r = "_last");
                    var o = e._prev,
                        c = e._next;
                    o ? o._next = c : t[n] === e && (t[n] = c), c ? c._prev = o : t[r] === e && (t[r] = o), e._dp = t, e._next = e._prev = e.parent = null
                },
                Gt = function (t, e) {
                    !t.parent || e && !t.parent.autoRemoveChildren || t.parent.remove(t), t._act = 0
                },
                Vt = function (t) {
                    for (var a = t; a;) a._dirty = 1, a = a.parent;
                    return t
                },
                jt = function (t) {
                    for (var e = t.parent; e && e.parent;) e._dirty = 1, e.totalDuration(), e = e.parent;
                    return t
                },
                Wt = function t(e) {
                    return !e || e._ts && t(e.parent)
                },
                Yt = function (t) {
                    return t._repeat ? ~~(t._tTime / (t = t.duration() + t._rDelay)) * t : 0
                },
                qt = function (t, e) {
                    return e._ts > 0 ? (t - e._start) * e._ts : (e._dirty ? e.totalDuration() : e._tDur) + (t - e._start) * e._ts
                },
                Xt = function (t, e, n) {
                    if (e.parent && Gt(e), e._start = n + e._delay, e._end = e._start + (e.totalDuration() / e._ts || 0), function (t, e, n, r, o) {
                            void 0 === n && (n = "_first"), void 0 === r && (r = "_last");
                            var c, l = t[r];
                            if (o)
                                for (c = e[o]; l && l[o] > c;) l = l._prev;
                            l ? (e._next = l._next, l._next = e) : (e._next = t[n], t[n] = e), e._next ? e._next._prev = e : t[r] = e, e._prev = l, e.parent = t
                        }(t, e, "_first", "_last", t._sort ? "_start" : 0), t._recent = e, e._time || !e._dur && e._initted) {
                        var r = (t.rawTime() - e._start) * e._ts;
                        (!e._dur || te(0, e.totalDuration(), r) - e._tTime > k) && e.render(r, !0)
                    }
                    if (Vt(t), t._dp && t._time >= t._dur && t._ts && t._dur < t.duration())
                        for (var o = t; o._dp;) o.totalTime(o._tTime, !0), o = o._dp;
                    return t
                },
                Zt = function (t, e, n, r) {
                    return Ve(t, e), t._initted ? !n && t._pt && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) ? (vt.push(t), t._lazy = [e, r], 1) : void 0 : 1
                },
                Jt = function (t) {
                    if (t instanceof ke) return Vt(t);
                    var e = t._repeat;
                    return t._tDur = e ? e < 0 ? 1e20 : At(t._dur * (e + 1) + t._rDelay * e) : t._dur, Vt(t.parent), t
                },
                $t = {
                    _start: 0,
                    endTime: mt
                },
                Qt = function t(e, n, r) {
                    var i, o, c = e.labels,
                        l = e._recent || $t,
                        h = e.duration() >= 1e8 ? l.endTime(!1) : e._dur;
                    return W(n) && (isNaN(n) || n in c) ? "<" === (i = n.charAt(0)) || ">" === i ? ("<" === i ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) : (i = n.indexOf("=")) < 0 ? (n in c || (c[n] = h), c[n]) : (o = +(n.charAt(i - 1) + n.substr(i + 1)), i > 1 ? t(e, n.substr(0, i - 1)) + o : h + o) : null == n ? h : +n
                },
                Kt = function (t, e) {
                    return t || 0 === t ? e(t) : e
                },
                te = function (t, e, n) {
                    return n < t ? t : n > e ? e : n
                },
                ee = function (t) {
                    return (t + "").substr((parseFloat(t) + "").length)
                },
                ne = [].slice,
                ie = function (t) {
                    return t && J(t) && "length" in t && t.length - 1 in t && J(t[0]) && !t.nodeType && t !== l
                },
                re = function (t, e, n) {
                    return void 0 === n && (n = []), t.forEach((function (t) {
                        var r;
                        return W(t) && !e || ie(t) ? (r = n).push.apply(r, ae(t)) : n.push(t)
                    })) || n
                },
                ae = function (t, e) {
                    return !W(t) || e || !h && Te() ? tt(t) ? re(t, e) : ie(t) ? ne.call(t, 0) : t ? [t] : [] : ne.call(d.querySelectorAll(t), 0)
                },
                oe = function (t) {
                    if (Y(t)) return t;
                    var e = J(t) ? t : {
                            each: t
                        },
                        n = Re(e.ease),
                        r = e.from || 0,
                        base = parseFloat(e.base) || 0,
                        o = {},
                        c = r > 0 && r < 1,
                        l = isNaN(r) || c,
                        h = e.axis,
                        d = r,
                        f = r;
                    return W(r) ? d = f = {
                            center: .5,
                            edges: .5,
                            end: 1
                        } [r] || 0 : !c && l && (d = r[0], f = r[1]),
                        function (i, t, a) {
                            var c, m, v, y, _, x, w, M, E, T = (a || e).length,
                                D = o[T];
                            if (!D) {
                                if (!(E = "auto" === e.grid ? 0 : (e.grid || [1, 1e8])[1])) {
                                    for (w = -1e8; w < (w = a[E++].getBoundingClientRect().left) && E < T;);
                                    E--
                                }
                                for (D = o[T] = [], c = l ? Math.min(E, T) * d - .5 : r % E, m = l ? T * f / E - .5 : r / E | 0, w = 0, M = 1e8, x = 0; x < T; x++) v = x % E - c, y = m - (x / E | 0), D[x] = _ = h ? Math.abs("y" === h ? y : v) : G(v * v + y * y), _ > w && (w = _), _ < M && (M = _);
                                D.max = w - M, D.min = M, D.v = T = (parseFloat(e.amount) || parseFloat(e.each) * (E > T ? T - 1 : h ? "y" === h ? T / E : E : Math.max(E, T / E)) || 0) * ("edges" === r ? -1 : 1), D.b = T < 0 ? base - T : base, D.u = ee(e.amount || e.each) || 0, n = n && T < 0 ? Le(n) : n
                            }
                            return T = (D[i] - D.min) / D.max || 0, At(D.b + (n ? n(T) : T) * D.v) + D.u
                        }
                },
                se = function (t) {
                    var p = t < 1 ? Math.pow(10, (t + "").length - 2) : 1;
                    return function (e) {
                        return ~~(Math.round(parseFloat(e) / t) * t * p) / p + (X(e) ? 0 : ee(e))
                    }
                },
                ue = function (t, e) {
                    var n, r, o = tt(t);
                    return !o && J(t) && (n = o = t.radius || 1e8, t = ae(t.values), (r = !X(t[0])) && (n *= n)), Kt(e, o ? function (e) {
                        for (var o, c, l = parseFloat(r ? e.x : e), h = parseFloat(r ? e.y : 0), d = 1e8, f = 0, i = t.length; i--;)(o = r ? (o = t[i].x - l) * o + (c = t[i].y - h) * c : Math.abs(t[i] - l)) < d && (d = o, f = i);
                        return f = !n || d <= n ? t[f] : e, r || f === e || X(e) ? f : f + ee(e)
                    } : se(t))
                },
                ce = function (t, e, n, r) {
                    return Kt(tt(t) ? !e : !r, (function () {
                        return tt(t) ? t[~~(Math.random() * t.length)] : (n = n || 1e-5) && (r = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && ~~(Math.round((t + Math.random() * (e - t)) / n) * n * r) / r
                    }))
                },
                le = function (a, t, e) {
                    return Kt(e, (function (e) {
                        return a[~~t(e)]
                    }))
                },
                he = function (t) {
                    for (var i, e, n, r, o = 0, s = ""; ~(i = t.indexOf("random(", o));) n = t.indexOf(")", i), r = "[" === t.charAt(i + 7), e = t.substr(i + 7, n - i - 7).match(r ? st : et), s += t.substr(o, i - o) + ce(r ? e : +e[0], +e[1], +e[2] || 1e-5), o = n + 1;
                    return s + t.substr(o, t.length - o)
                },
                de = function (t, e, n, r, o) {
                    var c = e - t,
                        l = r - n;
                    return Kt(o, (function (e) {
                        return n + (e - t) / c * l
                    }))
                },
                pe = function (t, e, n) {
                    var p, r, label, o = t.labels,
                        c = 1e8;
                    for (p in o)(r = o[p] - e) < 0 == !!n && r && c > (r = Math.abs(r)) && (label = p, c = r);
                    return label
                },
                fe = function (t, e, n) {
                    var r, o, c = t.vars,
                        l = c[e];
                    if (l) return r = c[e + "Params"], o = c.callbackScope || t, n && vt.length && Rt(), r ? l.apply(o, r) : l.call(o)
                },
                me = function (t) {
                    return Gt(t), t.progress() < 1 && fe(t, "onInterrupt"), t
                },
                ge = function (t) {
                    var e = (t = !t.name && t.default || t).name,
                        n = Y(t),
                        r = e && !n && t.init ? function () {
                            this._props = []
                        } : t,
                        o = {
                            init: mt,
                            render: nn,
                            add: He,
                            kill: an,
                            modifier: rn,
                            rawVars: 0
                        },
                        c = {
                            targetTest: 0,
                            get: 0,
                            getSetter: Qe,
                            aliases: {},
                            register: 0
                        };
                    if (Te(), t !== r) {
                        if (_t[e]) return;
                        Nt(r, Nt(zt(t, o), c)), Bt(r.prototype, Bt(o, zt(t, c))), _t[r.prop = e] = r, t.targetTest && (wt.push(r), gt[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
                    }
                    ft(e, r), t.register && t.register(dn, r, un)
                },
                ve = {
                    aqua: [0, 255, 255],
                    lime: [0, 255, 0],
                    silver: [192, 192, 192],
                    black: [0, 0, 0],
                    maroon: [128, 0, 0],
                    teal: [0, 128, 128],
                    blue: [0, 0, 255],
                    navy: [0, 0, 128],
                    white: [255, 255, 255],
                    olive: [128, 128, 0],
                    yellow: [255, 255, 0],
                    orange: [255, 165, 0],
                    gray: [128, 128, 128],
                    purple: [128, 0, 128],
                    green: [0, 128, 0],
                    red: [255, 0, 0],
                    pink: [255, 192, 203],
                    cyan: [0, 255, 255],
                    transparent: [255, 255, 255, 0]
                },
                ye = function (t, e, n) {
                    return 255 * (6 * (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t) < 1 ? e + (n - e) * t * 6 : t < .5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) + .5 | 0
                },
                _e = function (t, e) {
                    var n, g, b, r, s, o, c, l, h, d, a = t ? X(t) ? [t >> 16, t >> 8 & 255, 255 & t] : 0 : ve.black;
                    if (!a) {
                        if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), ve[t]) a = ve[t];
                        else if ("#" === t.charAt(0)) 4 === t.length && (n = t.charAt(1), g = t.charAt(2), b = t.charAt(3), t = "#" + n + n + g + g + b + b), a = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & 255, 255 & t];
                        else if ("hsl" === t.substr(0, 3))
                            if (a = d = t.match(et), e) {
                                if (~t.indexOf("=")) return t.match(nt)
                            } else r = +a[0] % 360 / 360, s = +a[1] / 100, n = 2 * (o = +a[2] / 100) - (g = o <= .5 ? o * (s + 1) : o + s - o * s), a.length > 3 && (a[3] *= 1), a[0] = ye(r + 1 / 3, n, g), a[1] = ye(r, n, g), a[2] = ye(r - 1 / 3, n, g);
                        else a = t.match(et) || ve.transparent;
                        a = a.map(Number)
                    }
                    return e && !d && (n = a[0] / 255, g = a[1] / 255, b = a[2] / 255, o = ((c = Math.max(n, g, b)) + (l = Math.min(n, g, b))) / 2, c === l ? r = s = 0 : (h = c - l, s = o > .5 ? h / (2 - c - l) : h / (c + l), r = c === n ? (g - b) / h + (g < b ? 6 : 0) : c === g ? (b - n) / h + 2 : (n - g) / h + 4, r *= 60), a[0] = r + .5 | 0, a[1] = 100 * s + .5 | 0, a[2] = 100 * o + .5 | 0), a
                },
                xe = function (s, t) {
                    var i, e, n, r = (s + "").match(be),
                        o = 0,
                        c = "";
                    if (!r) return s;
                    for (i = 0; i < r.length; i++) e = r[i], o += (n = s.substr(o, s.indexOf(e, o) - o)).length + e.length, 3 === (e = _e(e, t)).length && e.push(1), c += n + (t ? "hsla(" + e[0] + "," + e[1] + "%," + e[2] + "%," + e[3] : "rgba(" + e.join(",")) + ")";
                    return c + s.substr(o)
                },
                be = function () {
                    var p, s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
                    for (p in ve) s += "|" + p + "\\b";
                    return new RegExp(s + ")", "gi")
                }(),
                we = /hsl[a]?\(/,
                Me = function (a) {
                    var t, e = a.join(" ");
                    be.lastIndex = 0, be.test(e) && (t = we.test(e), a[0] = xe(a[0], t), a[1] = xe(a[1], t))
                },
                Ee = (M = Date.now, E = 500, T = 33, D = M(), S = D, C = A = 1 / 60, R = function t(e) {
                    var n, r, o = M() - S,
                        c = !0 === e;
                    o > E && (D += o - T), S += o, w.time = (S - D) / 1e3, ((n = w.time - C) > 0 || c) && (w.frame++, C += n + (n >= A ? .004 : A - n), r = 1), c || (y = _(t)), r && L.forEach((function (t) {
                        return t(w.time, o, w.frame, e)
                    }))
                }, w = {
                    time: 0,
                    frame: 0,
                    tick: function () {
                        R(!0)
                    },
                    wake: function () {
                        f && (!h && Q() && (l = h = window, d = l.document || {}, ut.gsap = dn, (l.gsapVersions || (l.gsapVersions = [])).push(dn.version), lt(ct || l.GreenSockGlobals || !l.gsap && l || {}), x = l.requestAnimationFrame), y && w.sleep(), _ = x || function (t) {
                            return setTimeout(t, 1e3 * (C - w.time) + 1 | 0)
                        }, v = 1, R(2))
                    },
                    sleep: function () {
                        (x ? l.cancelAnimationFrame : clearTimeout)(y), v = 0, _ = mt
                    },
                    lagSmoothing: function (t, e) {
                        E = t || 1 / k, T = Math.min(e, E, 0)
                    },
                    fps: function (t) {
                        A = 1 / (t || 60), C = w.time + A
                    },
                    add: function (t) {
                        L.indexOf(t) < 0 && L.push(t), Te()
                    },
                    remove: function (t) {
                        var i;
                        ~(i = L.indexOf(t)) && L.splice(i, 1)
                    },
                    _listeners: L = []
                }),
                Te = function () {
                    return !v && Ee.wake()
                },
                De = {},
                Se = /^[\d.\-M][\d.\-,\s]/,
                Ae = /["']/g,
                Ce = function (t) {
                    for (var e, n, r, o = {}, c = t.substr(1, t.length - 3).split(":"), l = c[0], i = 1, h = c.length; i < h; i++) n = c[i], e = i !== h - 1 ? n.lastIndexOf(",") : n.length, r = n.substr(0, e), o[l] = isNaN(r) ? r.replace(Ae, "").trim() : +r, l = n.substr(e + 1).trim();
                    return o
                },
                Le = function (t) {
                    return function (p) {
                        return 1 - t(1 - p)
                    }
                },
                Re = function (t, e) {
                    return t && (Y(t) ? t : De[t] || function (t) {
                        var e = (t + "").split("("),
                            n = De[e[0]];
                        return n && e.length > 1 && n.config ? n.config.apply(null, ~t.indexOf("{") ? [Ce(e[1])] : at.exec(t)[1].split(",").map(Ot)) : De._CE && Se.test(t) ? De._CE("", t) : n
                    }(t)) || e
                },
                Pe = function (t, e, n, r) {
                    void 0 === n && (n = function (p) {
                        return 1 - e(1 - p)
                    }), void 0 === r && (r = function (p) {
                        return p < .5 ? e(2 * p) / 2 : 1 - e(2 * (1 - p)) / 2
                    });
                    var o, c = {
                        easeIn: e,
                        easeOut: n,
                        easeInOut: r
                    };
                    return St(t, (function (t) {
                        for (var p in De[t] = ut[t] = c, De[o = t.toLowerCase()] = n, c) De[o + ("easeIn" === p ? ".in" : "easeOut" === p ? ".out" : ".inOut")] = De[t + "." + p] = c[p]
                    })), c
                },
                Oe = function (t) {
                    return function (p) {
                        return p < .5 ? (1 - t(1 - 2 * p)) / 2 : .5 + t(2 * (p - .5)) / 2
                    }
                },
                Fe = function t(e, n, r) {
                    var o = n >= 1 ? n : 1,
                        c = (r || (e ? .3 : .45)) / (n < 1 ? n : 1),
                        l = c / z * (Math.asin(1 / o) || 0),
                        h = function (p) {
                            return 1 === p ? 1 : o * Math.pow(2, -10 * p) * j((p - l) * c) + 1
                        },
                        d = "out" === e ? h : "in" === e ? function (p) {
                            return 1 - h(1 - p)
                        } : Oe(h);
                    return c = z / c, d.config = function (n, r) {
                        return t(e, n, r)
                    }, d
                },
                Ne = function t(e, n) {
                    void 0 === n && (n = 1.70158);
                    var r = function (p) {
                            return --p * p * ((n + 1) * p + n) + 1
                        },
                        o = "out" === e ? r : "in" === e ? function (p) {
                            return 1 - r(1 - p)
                        } : Oe(r);
                    return o.config = function (n) {
                        return t(e, n)
                    }, o
                };
            St("Linear,Quad,Cubic,Quart,Quint,Strong", (function (t, i) {
                var e = i < 5 ? i + 1 : i;
                Pe(t + ",Power" + (e - 1), i ? function (p) {
                    return Math.pow(p, e)
                } : function (p) {
                    return p
                }, (function (p) {
                    return 1 - Math.pow(1 - p, e)
                }), (function (p) {
                    return p < .5 ? Math.pow(2 * p, e) / 2 : 1 - Math.pow(2 * (1 - p), e) / 2
                }))
            })), De.Linear.easeNone = De.none = De.Linear.easeIn, Pe("Elastic", Fe("in"), Fe("out"), Fe()), P = 7.5625, F = 1 / (O = 2.75), Pe("Bounce", (function (p) {
                return 1 - N(1 - p)
            }), N = function (p) {
                return p < F ? P * p * p : p < .7272727272727273 ? P * Math.pow(p - 1.5 / O, 2) + .75 : p < .9090909090909092 ? P * (p -= 2.25 / O) * p + .9375 : P * Math.pow(p - 2.625 / O, 2) + .984375
            }), Pe("Expo", (function (p) {
                return p ? Math.pow(2, 10 * (p - 1)) : 0
            })), Pe("Circ", (function (p) {
                return -(G(1 - p * p) - 1)
            })), Pe("Sine", (function (p) {
                return 1 - V(p * U)
            })), Pe("Back", Ne("in"), Ne("out"), Ne()), De.SteppedEase = De.steps = ut.SteppedEase = {
                config: function (t, e) {
                    void 0 === t && (t = 1);
                    var n = 1 / t,
                        r = t + (e ? 0 : 1),
                        o = e ? 1 : 0,
                        c = 1 - k;
                    return function (p) {
                        return ((r * te(0, c, p) | 0) + o) * n
                    }
                }
            }, B.ease = De["quad.out"];
            var Ie = function (t, e) {
                    this.id = H++, t._gsap = this, this.target = t, this.harness = e, this.get = e ? e.get : Dt, this.set = e ? e.getSetter : Qe
                },
                Be = function () {
                    function t(t, time) {
                        var e = t.parent || c;
                        this.vars = t, this._dur = this._tDur = +t.duration || 0, this._delay = +t.delay || 0, (this._repeat = t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase, Jt(this)), this._ts = 1, this.data = t.data, v || Ee.wake(), e && Xt(e, this, time || 0 === time ? time : e._time), t.reversed && this.reversed(!0), t.paused && this.paused(!0)
                    }
                    var e = t.prototype;
                    return e.delay = function (t) {
                        return t || 0 === t ? (this._delay = t, this) : this._delay
                    }, e.duration = function (t) {
                        var e = arguments.length,
                            n = this._repeat,
                            r = n > 0 ? n * ((e ? t : this._dur) + this._rDelay) : 0;
                        return e ? this.totalDuration(n < 0 ? t : t + r) : this.totalDuration() && this._dur
                    }, e.totalDuration = function (t) {
                        if (!arguments.length) return this._tDur;
                        var e = this._repeat,
                            n = (t || this._rDelay) && e < 0;
                        return this._tDur = n ? 1e20 : t, this._dur = n ? t : (t - e * this._rDelay) / (e + 1), this._dirty = 0, Vt(this.parent), this
                    }, e.totalTime = function (t, e) {
                        if (Te(), !arguments.length) return this._tTime;
                        var n, r = this.parent || this._dp;
                        if (r && r.smoothChildTiming && this._ts) {
                            for (n = this._start, this._start = r._time - (this._ts > 0 ? t / this._ts : ((this._dirty ? this.totalDuration() : this._tDur) - t) / -this._ts), this._end += this._start - n, r._dirty || Vt(r); r.parent;) r.parent._time !== r._start + (r._ts > 0 ? r._tTime / r._ts : (r.totalDuration() - r._tTime) / -r._ts) && r.totalTime(r._tTime, !0), r = r.parent;
                            this.parent || Xt(this._dp, this, this._start - this._delay)
                        }
                        return this._tTime === t && this._dur || (this._ts || (this._pTime = t), Pt(this, t, e)), this
                    }, e.time = function (t, e) {
                        return arguments.length ? this.totalTime((t + Yt(this)) % this.duration() || (t ? this._dur : 0), e) : this._time
                    }, e.totalProgress = function (t, e) {
                        return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._tTime / this.totalDuration()
                    }, e.progress = function (t, e) {
                        return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + Yt(this), e) : this.duration() ? this._time / this._dur : this.ratio
                    }, e.iteration = function (t, e) {
                        var n = this.duration() + this._rDelay;
                        return arguments.length ? this.totalTime(this._time + (t - 1) * n, e) : this._repeat ? 1 + ~~(this._tTime / n) : 1
                    }, e.timeScale = function (t) {
                        var e = this._ts;
                        return arguments.length ? e ? (this._end = this._start + this._tDur / (this._ts = t || k), jt(this).totalTime(this._tTime, !0)) : (this._pauseTS = t, this) : e || this._pauseTS
                    }, e.paused = function (t) {
                        var e = !this._ts;
                        return arguments.length ? (e !== t && (t ? (this._pauseTS = this._ts, this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (this._ts = this._pauseTS, t = this._tTime || this._pTime, 1 === this.progress() && (this._tTime -= k), this.totalTime(t, !0))), this) : e
                    }, e.startTime = function (t) {
                        return arguments.length ? (this.parent && this.parent._sort && Xt(this.parent, this, t - this._delay), this) : this._start
                    }, e.endTime = function (t) {
                        return this._start + ($(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts)
                    }, e.rawTime = function (t) {
                        var e = this.parent || this._dp;
                        return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? qt(e.rawTime(t), this) : this._tTime : this._tTime
                    }, e.repeat = function (t) {
                        return arguments.length ? (this._repeat = t, Jt(this)) : this._repeat
                    }, e.repeatDelay = function (t) {
                        return arguments.length ? (this._rDelay = t, Jt(this)) : this._rDelay
                    }, e.yoyo = function (t) {
                        return arguments.length ? (this._yoyo = t, this) : this._yoyo
                    }, e.seek = function (t, e) {
                        return this.totalTime(Qt(this, t), $(e))
                    }, e.restart = function (t, e) {
                        return this.play().totalTime(t ? -this._delay : 0, $(e))
                    }, e.play = function (t, e) {
                        return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
                    }, e.reverse = function (t, e) {
                        return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
                    }, e.pause = function (t, e) {
                        return null != t && this.seek(t, e), this.paused(!0)
                    }, e.resume = function () {
                        return this.paused(!1)
                    }, e.reversed = function (t) {
                        var e = this._ts || this._pauseTS;
                        return arguments.length ? (t !== this.reversed() && (this[this._ts ? "_ts" : "_pauseTS"] = Math.abs(e) * (t ? -1 : 1), this.totalTime(this._tTime, !0)), this) : e < 0
                    }, e.invalidate = function () {
                        return this._initted = 0, this
                    }, e.isActive = function (t) {
                        var e, n = this.parent || this._dp,
                            r = this._start;
                        return !n || this._ts && (this._initted || !t) && n.isActive(t) && (e = n.rawTime(!0)) >= r && e < this.endTime(!0) - k
                    }, e.eventCallback = function (t, e, n) {
                        var r = this.vars;
                        return arguments.length > 1 ? (e ? (r[t] = e, n && (r[t + "Params"] = n), "onUpdate" === t && (this._onUpdate = e)) : delete r[t], this) : r[t]
                    }, e.then = function (t) {
                        var e = this;
                        return new Promise((function (n) {
                            var r = t || Ft,
                                o = function () {
                                    var t = e.then;
                                    e.then = null, (r = r(e)) && (r.then || r === e) && (e._prom = r, e.then = t), n(r), e.then = t
                                };
                            e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? o() : e._prom = o
                        }))
                    }, e.kill = function () {
                        me(this)
                    }, t
                }();
            Nt(Be.prototype, {
                _time: 0,
                _start: 0,
                _end: 0,
                _tTime: 0,
                _tDur: 0,
                _dirty: 0,
                _repeat: 0,
                _yoyo: !1,
                parent: 0,
                _initted: !1,
                _rDelay: 0,
                _ts: 1,
                _dp: 0,
                ratio: 0,
                _zTime: -k,
                _prom: 0
            });
            var ke = function (t) {
                function e(e, time) {
                    var n;
                    return void 0 === e && (e = {}), (n = t.call(this, e, time) || this).labels = {}, n.smoothChildTiming = $(e.smoothChildTiming), n.autoRemoveChildren = !!e.autoRemoveChildren, n._sort = $(e.sortChildren), n
                }
                o(e, t);
                var n = e.prototype;
                return n.to = function (t, e, n) {
                    return new qe(t, Lt(arguments, 0, this), Qt(this, X(e) ? arguments[3] : n)), this
                }, n.from = function (t, e, n) {
                    return new qe(t, Lt(arguments, 1, this), Qt(this, X(e) ? arguments[3] : n)), this
                }, n.fromTo = function (t, e, n, r) {
                    return new qe(t, Lt(arguments, 2, this), Qt(this, X(e) ? arguments[4] : r)), this
                }, n.set = function (t, e, n) {
                    return e.duration = 0, e.parent = this, e.repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new qe(t, e, Qt(this, n)), this
                }, n.call = function (t, e, n) {
                    return Xt(this, qe.delayedCall(0, t, e), Qt(this, n))
                }, n.staggerTo = function (t, e, n, r, o, c, l) {
                    return n.duration = e, n.stagger = n.stagger || r, n.onComplete = c, n.onCompleteParams = l, n.parent = this, new qe(t, n, Qt(this, o)), this
                }, n.staggerFrom = function (t, e, n, r, o, c, l) {
                    return n.runBackwards = 1, n.immediateRender = $(n.immediateRender), this.staggerTo(t, e, n, r, o, c, l)
                }, n.staggerFromTo = function (t, e, n, r, o, c, l, h) {
                    return r.startAt = n, r.immediateRender = $(r.immediateRender), this.staggerTo(t, e, r, o, c, l, h)
                }, n.render = function (t, e, n) {
                    var time, r, o, l, h, d, f, m, v, y, _, x = this._time,
                        w = this._dirty ? this.totalDuration() : this._tDur,
                        M = this._dur,
                        E = t > w - k && t >= 0 && this !== c ? w : t < k ? 0 : t,
                        T = this._zTime < 0 != t < 0 && (this._initted || !M);
                    if (E !== this._tTime || n || T) {
                        if (T && (M || (x = this._zTime), !t && e || (this._zTime = t)), time = E, v = this._start, d = 0 === (m = this._ts), x !== this._time && M && (time += this._time - x), this._repeat && (_ = this._yoyo, h = M + this._rDelay, ((time = At(E % h)) > M || w === E) && (time = M), (l = ~~(E / h)) && l === E / h && (time = M, l--), (y = ~~(this._tTime / h)) && y === this._tTime / h && y--, _ && 1 & l && (time = M - time, 1), l !== y && !this._lock)) {
                            var D = _ && 1 & y,
                                S = D === (_ && 1 & l);
                            if (l < y && (D = !D), x = D ? 0 : M, this._lock = 1, this.render(x, e, !M)._lock = 0, !e && this.parent && fe(this, "onRepeat"), x !== this._time || d !== !this._ts) return this;
                            if (S && (this._lock = 2, x = D ? M + 1e-4 : -1e-4, this.render(x, !0)), this._lock = 0, !this._ts && !d) return this
                        }
                        if (this._hasPause && !this._forcing && this._lock < 2 && (f = function (t, e, time) {
                                var n;
                                if (time > e)
                                    for (n = t._first; n && n._start <= time;) {
                                        if (!n._dur && "isPause" === n.data && n._start > e) return n;
                                        n = n._next
                                    } else
                                        for (n = t._last; n && n._start >= time;) {
                                            if (!n._dur && "isPause" === n.data && n._start < e) return n;
                                            n = n._prev
                                        }
                            }(this, At(x), At(time))) && (E -= time - (time = f._start)), this._tTime = E, this._time = time, this._act = !m, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1), x || !time || e || fe(this, "onStart"), time >= x && t >= 0)
                            for (r = this._first; r;) {
                                if (o = r._next, (r._act || time >= r._start) && r._ts && f !== r) {
                                    if (r.parent !== this) return this.render(t, e, n);
                                    if (r.render(r._ts > 0 ? (time - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (time - r._start) * r._ts, e, n), time !== this._time || !this._ts && !d) {
                                        f = 0;
                                        break
                                    }
                                }
                                r = o
                            } else {
                                r = this._last;
                                for (var A = t < 0 ? t : time; r;) {
                                    if (o = r._prev, (r._act || A <= r._end) && r._ts && f !== r) {
                                        if (r.parent !== this) return this.render(t, e, n);
                                        if (r.render(r._ts > 0 ? (A - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (A - r._start) * r._ts, e, n), time !== this._time || !this._ts && !d) {
                                            f = 0;
                                            break
                                        }
                                    }
                                    r = o
                                }
                            }
                        if (f && !e && (this.pause(), f.render(time >= x ? 0 : -k)._zTime = time >= x ? 1 : -1, this._ts)) return this._start = v, this.render(t, e, n);
                        this._onUpdate && !e && fe(this, "onUpdate", !0), (E === w || !E && this._ts < 0) && (v !== this._start && Math.abs(m) === Math.abs(this._ts) || (!time || w >= this.totalDuration()) && ((t || !M) && Gt(this, 1), e || t < 0 && !x || (fe(this, E === w ? "onComplete" : "onReverseComplete", !0), this._prom && this._prom())))
                    }
                    return this
                }, n.add = function (t, e) {
                    var n = this;
                    if (X(e) || (e = Qt(this, e)), !(t instanceof Be)) {
                        if (tt(t)) return t.forEach((function (t) {
                            return n.add(t, e)
                        })), Vt(this);
                        if (W(t)) return this.addLabel(t, e);
                        if (!Y(t)) return this;
                        t = qe.delayedCall(0, t)
                    }
                    return this !== t ? Xt(this, t, e) : this
                }, n.getChildren = function (t, e, n, r) {
                    void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === n && (n = !0), void 0 === r && (r = -1e8);
                    for (var a = [], o = this._first; o;) o._start >= r && (o instanceof qe ? e && a.push(o) : (n && a.push(o), t && a.push.apply(a, o.getChildren(!0, e, n)))), o = o._next;
                    return a
                }, n.getById = function (t) {
                    for (var e = this.getChildren(1, 1, 1), i = e.length; i--;)
                        if (e[i].vars.id === t) return e[i]
                }, n.remove = function (t) {
                    return W(t) ? this.removeLabel(t) : Y(t) ? this.killTweensOf(t) : (Ht(this, t), t === this._recent && (this._recent = this._last), Vt(this))
                }, n.totalTime = function (e, n) {
                    return arguments.length ? (this._forcing = 1, this.parent || this._dp || !this._ts || (this._start = Ee.time - (this._ts > 0 ? e / this._ts : (this.totalDuration() - e) / -this._ts)), t.prototype.totalTime.call(this, e, n), this._forcing = 0, this) : this._tTime
                }, n.addLabel = function (label, t) {
                    return this.labels[label] = Qt(this, t), this
                }, n.removeLabel = function (label) {
                    return delete this.labels[label], this
                }, n.addPause = function (t, e, n) {
                    var r = qe.delayedCall(0, e || mt, n);
                    return r.data = "isPause", this._hasPause = 1, Xt(this, r, Qt(this, t))
                }, n.removePause = function (t) {
                    var e = this._first;
                    for (t = Qt(this, t); e;) e._start === t && "isPause" === e.data && Gt(e), e = e._next
                }, n.killTweensOf = function (t, e, n) {
                    for (var r = this.getTweensOf(t, n), i = r.length; i--;) ze !== r[i] && r[i].kill(t, e);
                    return this
                }, n.getTweensOf = function (t, e) {
                    for (var n, a = [], r = ae(t), o = this._first; o;) o instanceof qe ? !Ct(o._targets, r) || e && !o.isActive("started" === e) || a.push(o) : (n = o.getTweensOf(r, e)).length && a.push.apply(a, n), o = o._next;
                    return a
                }, n.tweenTo = function (t, e) {
                    var n = this,
                        r = Qt(n, t),
                        o = e && e.startAt,
                        c = qe.to(n, Nt({
                            ease: "none",
                            lazy: !1,
                            time: r,
                            duration: Math.abs(r - (o && "time" in o ? o.time : n._time)) / n.timeScale() || k,
                            onStart: function () {
                                n.pause();
                                var t = Math.abs(r - n._time) / n.timeScale();
                                c._dur !== t && (c._dur = t, c.render(c._time, !0, !0)), e && e.onStart && e.onStart.apply(c, e.onStartParams || [])
                            }
                        }, e));
                    return c
                }, n.tweenFromTo = function (t, e, n) {
                    return this.tweenTo(e, Nt({
                        startAt: {
                            time: Qt(this, t)
                        }
                    }, n))
                }, n.recent = function () {
                    return this._recent
                }, n.nextLabel = function (t) {
                    return void 0 === t && (t = this._time), pe(this, Qt(this, t))
                }, n.previousLabel = function (t) {
                    return void 0 === t && (t = this._time), pe(this, Qt(this, t), 1)
                }, n.currentLabel = function (t) {
                    return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + k)
                }, n.shiftChildren = function (t, e, n) {
                    void 0 === n && (n = 0);
                    for (var p, r = this._first, o = this.labels; r;) r._start >= n && (r._start += t), r = r._next;
                    if (e)
                        for (p in o) o[p] >= n && (o[p] += t);
                    return Vt(this)
                }, n.invalidate = function () {
                    var e = this._first;
                    for (this._lock = 0; e;) e.invalidate(), e = e._next;
                    return t.prototype.invalidate.call(this)
                }, n.clear = function (t) {
                    void 0 === t && (t = !0);
                    for (var e, n = this._first; n;) e = n._next, this.remove(n), n = e;
                    return this._time = this._tTime = 0, t && (this.labels = {}), Vt(this)
                }, n.totalDuration = function (t) {
                    var e, n, r = 0,
                        o = this,
                        l = o._last,
                        h = 1e8,
                        d = o._repeat,
                        f = d * o._rDelay || 0,
                        m = d < 0;
                    if (!arguments.length) {
                        if (o._dirty) {
                            for (; l;) e = l._prev, l._dirty && l.totalDuration(), l._start > h && o._sort && l._ts && !o._lock ? (o._lock = 1, Xt(o, l, l._start - l._delay), o._lock = 0) : h = l._start, l._start < 0 && l._ts && (r -= l._start, (!o.parent && !o._dp || o.parent && o.parent.smoothChildTiming) && (o._start += l._start / o._ts, o._time -= l._start, o._tTime -= l._start), o.shiftChildren(-l._start, !1, -1e8), h = 0), (n = l._end = l._start + l._tDur / Math.abs(l._ts || l._pauseTS)) > r && l._ts && (r = At(n)), l = e;
                            o._dur = o === c && o._time > r ? o._time : Math.min(1e8, r), o._tDur = m && (o._dur || f) ? 1e20 : Math.min(1e8, r * (d + 1) + f), o._end = o._start + (o._tDur / Math.abs(o._ts || o._pauseTS) || 0), o._dirty = 0
                        }
                        return o._tDur
                    }
                    return m ? o : o.timeScale(o.totalDuration() / t)
                }, e.updateRoot = function (time) {
                    if (c._ts && Pt(c, qt(time, c)), Ee.frame >= bt) {
                        bt += I.autoSleep || 120;
                        var t = c._first;
                        if ((!t || !t._ts) && I.autoSleep && Ee._listeners.length < 2) {
                            for (; t && !t._ts;) t = t._next;
                            t || Ee.sleep()
                        }
                    }
                }, e
            }(Be);
            Nt(ke.prototype, {
                _lock: 0,
                _hasPause: 0,
                _forcing: 0
            });
            var ze, Ue = function (t, e, n, r, o, c, l) {
                    var h, d, f, m, v, y, _, a, x = new un(this._pt, t, e, 0, 1, en, null, o),
                        w = 0,
                        M = 0;
                    for (x.b = n, x.e = r, n += "", (_ = ~(r += "").indexOf("random(")) && (r = he(r)), c && (c(a = [n, r], t, e), n = a[0], r = a[1]), d = n.match(it) || []; h = it.exec(r);) m = h[0], v = r.substring(w, h.index), f ? f = (f + 1) % 5 : "rgba(" === v.substr(-5) && (f = 1), m !== d[M++] && (y = parseFloat(d[M - 1]), x._pt = {
                        _next: x._pt,
                        p: v || 1 === M ? v : ",",
                        s: y,
                        c: "=" === m.charAt(1) ? parseFloat(m.substr(2)) * ("-" === m.charAt(0) ? -1 : 1) : parseFloat(m) - y,
                        m: f && f < 4 ? Math.round : 0
                    }, w = it.lastIndex);
                    return x.c = w < r.length ? r.substring(w, r.length) : "", x.fp = l, (ot.test(r) || _) && (x.e = 0), this._pt = x, x
                },
                He = function (t, e, n, r, o, c, l, h, d) {
                    Y(r) && (r = r(o || 0, t, c));
                    var f, m = t[e],
                        v = "get" !== n ? n : Y(m) ? d ? t[e.indexOf("set") || !Y(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](d) : t[e]() : m,
                        y = Y(m) ? d ? Je : Ze : Xe;
                    if (W(r) && (~r.indexOf("random(") && (r = he(r)), "=" === r.charAt(1) && (r = parseFloat(v) + parseFloat(r.substr(2)) * ("-" === r.charAt(0) ? -1 : 1) + (ee(v) || 0))), v !== r) return isNaN(v + r) ? (!m && !(e in t) && ht(e, r), Ue.call(this, t, e, v, r, y, h || I.stringFilter, d)) : (f = new un(this._pt, t, e, +v || 0, r - (v || 0), "boolean" == typeof m ? tn : Ke, 0, y), d && (f.fp = d), l && f.modifier(l, this, t), this._pt = f)
                },
                Ge = function (t, e, n, r, o, c) {
                    var l, h, d, i;
                    if (_t[t] && !1 !== (l = new _t[t]).init(o, l.rawVars ? e[t] : function (t, e, n, r, o) {
                            if (Y(t) && (t = je(t, o, e, n, r)), !J(t) || t.style && t.nodeType || tt(t)) return W(t) ? je(t, o, e, n, r) : t;
                            var p, c = {};
                            for (p in t) c[p] = je(t[p], o, e, n, r);
                            return c
                        }(e[t], r, o, c, n), n, r, c) && (n._pt = h = new un(n._pt, o, t, 0, 1, l.render, l, 0, l.priority), n !== m))
                        for (d = n._ptLookup[n._targets.indexOf(o)], i = l._props.length; i--;) d[l._props[i]] = h;
                    return l
                },
                Ve = function t(e, time) {
                    var n, i, p, r, o, l, h, d, f, m, v, y, _ = e.vars,
                        x = _.ease,
                        w = _.startAt,
                        M = _.immediateRender,
                        E = _.lazy,
                        T = _.onUpdate,
                        D = _.onUpdateParams,
                        S = _.callbackScope,
                        A = _.runBackwards,
                        C = _.yoyoEase,
                        L = _.keyframes,
                        R = _.autoRevert,
                        P = e._dur,
                        O = e._startAt,
                        F = e._targets,
                        N = e.parent,
                        I = N && "nested" === N.data ? N.parent._targets : F,
                        z = "auto" === e._overwrite,
                        U = e.timeline;
                    if (!U || L && x || (x = "none"), e._ease = Re(x, B.ease), e._yEase = C ? Le(Re(!0 === C ? x : C, B.ease)) : 0, C && e._yoyo && !e._repeat && (C = e._yEase, e._yEase = e._ease, e._ease = C), !U) {
                        if (O && O.render(-1, !0).kill(), w) {
                            if (Gt(e._startAt = qe.set(F, Nt({
                                    data: "isStart",
                                    overwrite: !1,
                                    parent: N,
                                    immediateRender: !0,
                                    lazy: $(E),
                                    startAt: null,
                                    delay: 0,
                                    onUpdate: T,
                                    onUpdateParams: D,
                                    callbackScope: S,
                                    stagger: 0
                                }, w))), M)
                                if (time > 0) !R && (e._startAt = 0);
                                else if (P) return
                        } else if (A && P)
                            if (O) !R && (e._startAt = 0);
                            else if (time && (M = !1), Gt(e._startAt = qe.set(F, Bt(zt(_, gt), {
                                overwrite: !1,
                                data: "isFromStart",
                                lazy: M && $(E),
                                immediateRender: M,
                                stagger: 0,
                                parent: N
                            }))), M) {
                            if (!time) return
                        } else t(e._startAt, k);
                        for (n = zt(_, gt), e._pt = 0, y = (d = F[0] ? Tt(F[0]).harness : 0) && _[d.prop], E = P && $(E) || E && !P, i = 0; i < F.length; i++) {
                            if (h = (o = F[i])._gsap || Et(F)[i]._gsap, e._ptLookup[i] = m = {}, yt[h.id] && Rt(), v = I === F ? i : I.indexOf(o), d && !1 !== (f = new d).init(o, y || n, e, v, I) && (e._pt = r = new un(e._pt, o, f.name, 0, 1, f.render, f, 0, f.priority), f._props.forEach((function (t) {
                                    m[t] = r
                                })), f.priority && (l = 1)), !d || y)
                                for (p in n) _t[p] && (f = Ge(p, n, e, v, o, I)) ? f.priority && (l = 1) : m[p] = r = He.call(e, o, p, "get", n[p], v, I, 0, _.stringFilter);
                            e._op && e._op[i] && e.kill(o, e._op[i]), z && (ze = e, c.killTweensOf(o, m, "started"), ze = 0), e._pt && E && (yt[h.id] = 1)
                        }
                        l && sn(e), e._onInit && e._onInit(e)
                    }
                    e._from = !U && !!_.runBackwards, e._onUpdate = T, e._initted = 1
                },
                je = function (t, e, i, n, r) {
                    return Y(t) ? t.call(e, i, n, r) : W(t) && ~t.indexOf("random(") ? he(t) : t
                },
                We = Mt + ",repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
                Ye = (We + ",id,stagger,delay,duration,paused").split(","),
                qe = function (t) {
                    function e(e, n, time) {
                        var o;
                        "number" == typeof n && (time.duration = n, n = time, time = null);
                        var l, i, h, d, p, f, m, v, y = (o = t.call(this, Ut(n), time) || this).vars,
                            _ = y.duration,
                            x = y.delay,
                            w = y.immediateRender,
                            M = y.stagger,
                            E = y.overwrite,
                            T = y.keyframes,
                            D = y.defaults,
                            S = tt(e) && X(e[0]) ? [e] : ae(e);
                        if (o._targets = S.length ? Et(S) : pt("GSAP target " + e + " not found. https://greensock.com", !I.nullTargetWarn) || [], o._ptLookup = [], o._overwrite = E, T || M || K(_) || K(x)) {
                            if (n = o.vars, (l = o.timeline = new ke({
                                    data: "nested",
                                    defaults: D || {}
                                })).kill(), l.parent = r(o), T) Nt(l.vars.defaults, {
                                ease: "none"
                            }), T.forEach((function (t) {
                                return l.to(S, t, ">")
                            }));
                            else {
                                if (d = S.length, m = M ? oe(M) : mt, J(M))
                                    for (p in M) ~We.indexOf(p) && (v || (v = {}), v[p] = M[p]);
                                for (i = 0; i < d; i++) {
                                    for (p in h = {}, n) Ye.indexOf(p) < 0 && (h[p] = n[p]);
                                    h.stagger = 0, v && Bt(h, v), n.yoyoEase && !n.repeat && (h.yoyoEase = n.yoyoEase), f = S[i], h.duration = +je(_, r(o), i, f, S), h.delay = (+je(x, r(o), i, f, S) || 0) - o._delay, !M && 1 === d && h.delay && (o._delay = x = h.delay, o._start += x, h.delay = 0), l.to(f, h, m(i, f, S))
                                }
                                _ = x = 0
                            }
                            _ || o.duration(_ = l.duration())
                        } else o.timeline = 0;
                        return !0 === E && (ze = r(o), c.killTweensOf(S), ze = 0), (w || !_ && !T && o._start === o.parent._time && $(w) && Wt(r(o)) && "nested" !== o.parent.data) && (o._tTime = -k, o.render(Math.max(0, -x))), o
                    }
                    o(e, t);
                    var n = e.prototype;
                    return n.render = function (t, e, n) {
                        var time, r, o, c, l, h, d, f, m, v = this._time,
                            y = this._tDur,
                            _ = this._dur,
                            x = t > y - k && t >= 0 ? y : t < k ? 0 : t;
                        if (_) {
                            if (x !== this._tTime || !t || n || this._startAt && this._zTime < 0 != t < 0) {
                                if (time = x, f = this.timeline, this._repeat) {
                                    if (c = _ + this._rDelay, (time = At(x % c)) > _ && (time = _), (o = ~~(x / c)) && o === x / c && (time = _, o--), (h = this._yoyo && 1 & o) && (m = this._yEase, time = _ - time), (l = ~~(this._tTime / c)) && l === this._tTime / c && l--, time === v && !n && this._initted) return this;
                                    o !== l && this.vars.repeatRefresh && !this._lock && (this._lock = n = 1, this.render(c * o, !0).invalidate()._lock = 0)
                                }
                                if (!this._initted && Zt(this, time, n, e)) return this;
                                for (this._tTime = x, this._time = time, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = d = (m || this._ease)(time / _), this._from && (this.ratio = d = 1 - d), v || !time || e || fe(this, "onStart"), r = this._pt; r;) r.r(d, r.d), r = r._next;
                                f && f.render(t < 0 ? t : !time && h ? -k : f._dur * d, e, n) || this._startAt && (this._zTime = t), this._onUpdate && !e && (t < 0 && this._startAt && this._startAt.render(t, !0, n), fe(this, "onUpdate")), this._repeat && o !== l && this.vars.onRepeat && !e && this.parent && fe(this, "onRepeat"), x !== y && x || this._tTime !== x || (t < 0 && this._startAt && !this._onUpdate && this._startAt.render(t, !0, n), (t || !_) && (x || this._ts < 0) && Gt(this, 1), e || t < 0 && !v || (fe(this, x === y ? "onComplete" : "onReverseComplete", !0), this._prom && this._prom()))
                            }
                        } else ! function (t, e, n, r) {
                            var o, c, l, h = t._zTime < 0 ? 0 : 1,
                                d = e < 0 ? 0 : 1,
                                f = t._rDelay,
                                m = 0;
                            if (f && t._repeat && ((c = ~~((m = te(0, t._tDur, e)) / f)) && c === m / f && c--, (l = ~~(t._tTime / f)) && l === t._tTime / f && l--, c !== l && (h = 1 - d, t.vars.repeatRefresh && t._initted && t.invalidate())), (t._initted || !Zt(t, e, r, n)) && (d !== h || r || t._zTime === k || !e && t._zTime)) {
                                for (t._zTime = e || (n ? k : 0), t.ratio = d, t._from && (d = 1 - d), t._time = 0, t._tTime = m, n || fe(t, "onStart"), o = t._pt; o;) o.r(d, o.d), o = o._next;
                                !d && t._startAt && !t._onUpdate && t._start && t._startAt.render(e, !0, r), t._onUpdate && !n && fe(t, "onUpdate"), m && t._repeat && !n && t.parent && fe(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === d && (t.ratio && Gt(t, 1), n || (fe(t, t.ratio ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()))
                            }
                        }(this, t, e, n);
                        return this
                    }, n.targets = function () {
                        return this._targets
                    }, n.invalidate = function () {
                        return this._pt = this._op = this._startAt = this._onUpdate = this._act = this._lazy = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), t.prototype.invalidate.call(this)
                    }, n.kill = function (t, e) {
                        if (void 0 === e && (e = "all"), !(t || e && "all" !== e) && (this._lazy = 0, this.parent)) return me(this);
                        if (this.timeline) return this.timeline.killTweensOf(t, e, !!ze), this;
                        var n, r, o, c, p, l, i, h = this._targets,
                            d = t ? ae(t) : h,
                            f = this._ptLookup,
                            m = this._pt;
                        if ((!e || "all" === e) && function (t, e) {
                                for (var i = t.length, n = i === e.length; n && i-- && t[i] === e[i];);
                                return i < 0
                            }(h, d)) return me(this);
                        for (n = this._op = this._op || [], "all" !== e && (W(e) && (p = {}, St(e, (function (t) {
                                return p[t] = 1
                            })), e = p), e = function (t, e) {
                                var n, p, i, r, o = t[0] ? Tt(t[0]).harness : 0,
                                    c = o && o.aliases;
                                if (!c) return e;
                                for (p in n = Bt({}, e), c)
                                    if (p in n)
                                        for (i = (r = c[p].split(",")).length; i--;) n[r[i]] = n[p];
                                return n
                            }(h, e)), i = h.length; i--;)
                            if (~d.indexOf(h[i]))
                                for (p in r = f[i], "all" === e ? (n[i] = e, c = r, o = {}) : (o = n[i] = n[i] || {}, c = e), c)(l = r && r[p]) && ("kill" in l.d && !0 !== l.d.kill(p) || (Ht(this, l, "_pt"), delete r[p])), "all" !== o && (o[p] = 1);
                        return this._initted && !this._pt && m && me(this), this
                    }, e.to = function (t, n) {
                        return new e(t, n, arguments[2])
                    }, e.from = function (t, n) {
                        return new e(t, Lt(arguments, 1))
                    }, e.delayedCall = function (t, n, r, o) {
                        return new e(n, 0, {
                            immediateRender: !1,
                            lazy: !1,
                            overwrite: !1,
                            delay: t,
                            onComplete: n,
                            onReverseComplete: n,
                            onCompleteParams: r,
                            onReverseCompleteParams: r,
                            callbackScope: o
                        })
                    }, e.fromTo = function (t, n, r) {
                        return new e(t, Lt(arguments, 2))
                    }, e.set = function (t, n) {
                        return n.duration = 0, n.repeatDelay || (n.repeat = 0), new e(t, n)
                    }, e.killTweensOf = function (t, e, n) {
                        return c.killTweensOf(t, e, n)
                    }, e
                }(Be);
            Nt(qe.prototype, {
                _targets: [],
                _lazy: 0,
                _startAt: 0,
                _op: 0,
                _onInit: 0
            }), St("staggerTo,staggerFrom,staggerFromTo", (function (t) {
                qe[t] = function () {
                    var e = new ke,
                        n = ae(arguments);
                    return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n)
                }
            }));
            var Xe = function (t, e, n) {
                    return t[e] = n
                },
                Ze = function (t, e, n) {
                    return t[e](n)
                },
                Je = function (t, e, n, data) {
                    return t[e](data.fp, n)
                },
                $e = function (t, e, n) {
                    return t.setAttribute(e, n)
                },
                Qe = function (t, e) {
                    return Y(t[e]) ? Ze : Z(t[e]) && t.setAttribute ? $e : Xe
                },
                Ke = function (t, data) {
                    return data.set(data.t, data.p, Math.round(1e4 * (data.s + data.c * t)) / 1e4, data)
                },
                tn = function (t, data) {
                    return data.set(data.t, data.p, !!(data.s + data.c * t), data)
                },
                en = function (t, data) {
                    var e = data._pt,
                        s = "";
                    if (!t && data.b) s = data.b;
                    else if (1 === t && data.e) s = data.e;
                    else {
                        for (; e;) s = e.p + (e.m ? e.m(e.s + e.c * t) : Math.round(1e4 * (e.s + e.c * t)) / 1e4) + s, e = e._next;
                        s += data.c
                    }
                    data.set(data.t, data.p, s, data)
                },
                nn = function (t, data) {
                    for (var e = data._pt; e;) e.r(t, e.d), e = e._next
                },
                rn = function (t, e, n, r) {
                    for (var o, c = this._pt; c;) o = c._next, c.p === r && c.modifier(t, e, n), c = o
                },
                an = function (t) {
                    for (var e, n, r = this._pt; r;) n = r._next, r.p === t && !r.op || r.op === t ? Ht(this, r, "_pt") : r.dep || (e = 1), r = n;
                    return !e
                },
                on = function (t, e, n, data) {
                    data.mSet(t, e, data.m.call(data.tween, n, data.mt), data)
                },
                sn = function (t) {
                    for (var e, n, r, o, c = t._pt; c;) {
                        for (e = c._next, n = r; n && n.pr > c.pr;) n = n._next;
                        (c._prev = n ? n._prev : o) ? c._prev._next = c: r = c, (c._next = n) ? n._prev = c : o = c, c = e
                    }
                    t._pt = r
                },
                un = function () {
                    function t(t, e, n, r, o, c, data, l, h) {
                        this.t = e, this.s = r, this.c = o, this.p = n, this.r = c || Ke, this.d = data || this, this.set = l || Xe, this.pr = h || 0, this._next = t, t && (t._prev = this)
                    }
                    return t.prototype.modifier = function (t, e, n) {
                        this.mSet = this.mSet || this.set, this.set = on, this.m = t, this.mt = n, this.tween = e
                    }, t
                }();
            St(Mt + ",parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert", (function (t) {
                gt[t] = 1, "on" === t.substr(0, 2) && (gt[t + "Params"] = 1)
            })), ut.TweenMax = ut.TweenLite = qe, ut.TimelineLite = ut.TimelineMax = ke, c = new ke({
                sortChildren: !1,
                defaults: B,
                autoRemoveChildren: !0,
                id: "root"
            }), I.stringFilter = Me;
            var cn = {
                registerPlugin: function () {
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                    e.forEach((function (t) {
                        return ge(t)
                    }))
                },
                timeline: function (t) {
                    return new ke(t)
                },
                getTweensOf: function (t, e) {
                    return c.getTweensOf(t, e)
                },
                getProperty: function (t, e, n, r) {
                    W(t) && (t = ae(t)[0]);
                    var o = Tt(t || {}).get,
                        c = n ? Ft : Ot;
                    return "native" === n && (n = ""), t ? e ? c((_t[e] && _t[e].get || o)(t, e, n, r)) : function (e, n, r) {
                        return c((_t[e] && _t[e].get || o)(t, e, n, r))
                    } : t
                },
                quickSetter: function (t, e, n) {
                    if ((t = ae(t)).length > 1) {
                        var r = t.map((function (t) {
                                return dn.quickSetter(t, e, n)
                            })),
                            o = r.length;
                        return function (t) {
                            for (var i = o; i--;) r[i](t)
                        }
                    }
                    t = t[0] || {};
                    var c = _t[e],
                        l = Tt(t),
                        h = c ? function (e) {
                            var p = new c;
                            m._pt = 0, p.init(t, n ? e + n : e, m, 0, [t]), p.render(1, p), m._pt && nn(1, m)
                        } : l.set(t, e);
                    return c ? h : function (r) {
                        return h(t, e, n ? r + n : r, l, 1)
                    }
                },
                isTweening: function (t) {
                    return c.getTweensOf(t, !0).length > 0
                },
                defaults: function (t) {
                    return t && t.ease && (t.ease = Re(t.ease, B.ease)), kt(B, t || {})
                },
                config: function (t) {
                    return kt(I, t || {})
                },
                registerEffect: function (t) {
                    var e = t.name,
                        n = t.effect,
                        r = t.plugins,
                        o = t.defaults,
                        c = t.extendTimeline;
                    (r || "").split(",").forEach((function (t) {
                        return t && !_t[t] && !ut[t] && pt(e + " effect requires " + t + " plugin.")
                    })), xt[e] = function (t, e) {
                        return n(ae(t), Nt(e || {}, o))
                    }, c && (ke.prototype[e] = function (t, n, r) {
                        return this.add(xt[e](t, J(n) ? n : (r = n) && {}), r)
                    })
                },
                registerEase: function (t, e) {
                    De[t] = Re(e)
                },
                parseEase: function (t, e) {
                    return arguments.length ? Re(t, e) : De
                },
                getById: function (t) {
                    return c.getById(t)
                },
                exportRoot: function (t, e) {
                    void 0 === t && (t = {});
                    var n, r, o = new ke(t);
                    for (o.smoothChildTiming = $(t.smoothChildTiming), c.remove(o), o._dp = 0, o._time = o._tTime = c._time, n = c._first; n;) r = n._next, !e && !n._dur && n instanceof qe && n.vars.onComplete === n._targets[0] || Xt(o, n, n._start - n._delay), n = r;
                    return Xt(c, o, 0), o
                },
                utils: {
                    wrap: function t(e, n, r) {
                        var o = n - e;
                        return tt(e) ? le(e, t(0, e.length), n) : Kt(r, (function (t) {
                            return (o + (t - e) % o) % o + e
                        }))
                    },
                    wrapYoyo: function t(e, n, r) {
                        var o = n - e,
                            c = 2 * o;
                        return tt(e) ? le(e, t(0, e.length - 1), n) : Kt(r, (function (t) {
                            return e + ((t = (c + (t - e) % c) % c) > o ? c - t : t)
                        }))
                    },
                    distribute: oe,
                    random: ce,
                    snap: ue,
                    normalize: function (t, e, n) {
                        return de(t, e, 0, 1, n)
                    },
                    getUnit: ee,
                    clamp: function (t, e, n) {
                        return Kt(n, (function (n) {
                            return te(t, e, n)
                        }))
                    },
                    splitColor: _e,
                    toArray: ae,
                    mapRange: de,
                    pipe: function () {
                        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                        return function (t) {
                            return e.reduce((function (t, e) {
                                return e(t)
                            }), t)
                        }
                    },
                    unitize: function (t, e) {
                        return function (n) {
                            return t(parseFloat(n)) + (e || ee(n))
                        }
                    },
                    interpolate: function t(e, n, progress, r) {
                        var o = isNaN(e + n) ? 0 : function (p) {
                            return (1 - p) * e + p * n
                        };
                        if (!o) {
                            var p, i, c, l, h, d = W(e),
                                f = {};
                            if (!0 === progress && (r = 1) && (progress = null), d) e = {
                                p: e
                            }, n = {
                                p: n
                            };
                            else if (tt(e) && !tt(n)) {
                                for (c = [], l = e.length, h = l - 2, i = 1; i < l; i++) c.push(t(e[i - 1], e[i]));
                                l--, o = function (p) {
                                    p *= l;
                                    var i = Math.min(h, ~~p);
                                    return c[i](p - i)
                                }, progress = n
                            } else r || (e = Bt(tt(e) ? [] : {}, e));
                            if (!c) {
                                for (p in n) He.call(f, e, p, "get", n[p]);
                                o = function (p) {
                                    return nn(p, f) || (d ? e.p : e)
                                }
                            }
                        }
                        return Kt(progress, o)
                    }
                },
                install: lt,
                effects: xt,
                ticker: Ee,
                updateRoot: ke.updateRoot,
                plugins: _t,
                globalTimeline: c,
                core: {
                    PropTween: un,
                    globals: ft,
                    Tween: qe,
                    Timeline: ke,
                    Animation: Be,
                    getCache: Tt
                }
            };
            St("to,from,fromTo,delayedCall,set,killTweensOf", (function (t) {
                return cn[t] = qe[t]
            })), Ee.add(ke.updateRoot), m = cn.to({}, {
                duration: 0
            });
            var ln = function (t, e) {
                    for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e;) n = n._next;
                    return n
                },
                hn = function (t, e) {
                    return {
                        name: t,
                        rawVars: 1,
                        init: function (t, n, r) {
                            r._onInit = function (t) {
                                var r, p;
                                if (W(n) && (r = {}, St(n, (function (t) {
                                        return r[t] = 1
                                    })), n = r), e) {
                                    for (p in r = {}, n) r[p] = e(n[p]);
                                    n = r
                                }! function (t, e) {
                                    var p, i, n, r = t._targets;
                                    for (p in e)
                                        for (i = r.length; i--;)(n = t._ptLookup[i][p]) && (n = n.d) && (n._pt && (n = ln(n, p)), n && n.modifier && n.modifier(e[p], t, r[i], p))
                                }(t, n)
                            }
                        }
                    }
                },
                dn = cn.registerPlugin({
                    name: "attr",
                    init: function (t, e, n, r, o) {
                        for (var p in e) this.add(t, "setAttribute", (t.getAttribute(p) || 0) + "", e[p], r, o, 0, 0, p), this._props.push(p)
                    }
                }, {
                    name: "endArray",
                    init: function (t, e) {
                        for (var i = e.length; i--;) this.add(t, i, t[i] || 0, e[i])
                    }
                }, hn("roundProps", se), hn("modifiers"), hn("snap", ue)) || cn;
            qe.version = ke.version = dn.version = "3.0.2", f = 1, Q() && Te();
            var pn, fn, mn, gn, vn, yn, _n, xn, bn, wn, Mn = De.Power0,
                En = De.Power1,
                Tn = De.Power2,
                Dn = De.Power3,
                Sn = De.Power4,
                An = De.Linear,
                Cn = De.Quad,
                Ln = De.Cubic,
                Rn = De.Quart,
                Pn = De.Quint,
                On = De.Strong,
                Fn = De.Elastic,
                Nn = De.Back,
                In = De.SteppedEase,
                Bn = De.Bounce,
                kn = De.Sine,
                zn = De.Expo,
                Un = De.Circ,
                Hn = {},
                Gn = 180 / Math.PI,
                Vn = Math.PI / 180,
                jn = Math.atan2,
                Wn = /([A-Z])/g,
                Yn = /[-+=\.]*\d+[\.e-]*\d*[a-z%]*/g,
                qn = /(?:left|right|width|margin|padding|x)/i,
                Xn = /[\s,\(]\S/,
                Zn = {
                    autoAlpha: "opacity,visibility",
                    scale: "scaleX,scaleY",
                    alpha: "opacity"
                },
                Jn = function (t, data) {
                    return data.set(data.t, data.p, ~~(1e3 * (data.s + data.c * t)) / 1e3 + data.u, data)
                },
                $n = function (t, data) {
                    return data.set(data.t, data.p, 1 === t ? data.e : ~~(1e3 * (data.s + data.c * t)) / 1e3 + data.u, data)
                },
                Qn = function (t, data) {
                    return data.set(data.t, data.p, t ? ~~(1e3 * (data.s + data.c * t)) / 1e3 + data.u : data.b, data)
                },
                Kn = function (t, data) {
                    var e = data.s + data.c * t;
                    data.set(data.t, data.p, ~~(e + (e < 0 ? -.5 : .5)) + data.u, data)
                },
                ti = function (t, data) {
                    return data.set(data.t, data.p, t ? data.e : data.b, data)
                },
                ei = function (t, data) {
                    return data.set(data.t, data.p, 1 !== t ? data.b : data.e, data)
                },
                ni = function (t, e, n) {
                    return t.style[e] = n
                },
                ii = function (t, e, n) {
                    return t.style.setProperty(e, n)
                },
                ri = function (t, e, n) {
                    return t._gsap[e] = n
                },
                ai = function (t, e, n) {
                    return t._gsap.scaleX = t._gsap.scaleY = n
                },
                oi = function (t, e, n, data, r) {
                    var o = t._gsap;
                    o.scaleX = o.scaleY = n, o.renderTransform(r, o)
                },
                si = function (t, e, n, data, r) {
                    var o = t._gsap;
                    o[e] = n, o.renderTransform(r, o)
                },
                ui = "transform",
                ci = ui + "Origin",
                hi = function (t, e) {
                    var n = fn.createElementNS ? fn.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : fn.createElement(t);
                    return n.style ? n : fn.createElement(t)
                },
                di = function t(e, n, r) {
                    var o = getComputedStyle(e);
                    return o[n] || o.getPropertyValue(n.replace(Wn, "-$1").toLowerCase()) || o.getPropertyValue(n) || !r && t(e, fi(n) || n, 1) || ""
                },
                pi = "O,Moz,ms,Ms,Webkit".split(","),
                fi = function (t, element) {
                    var s = (element || vn).style,
                        i = 5;
                    if (t in s) return t;
                    for (t = t.charAt(0).toUpperCase() + t.substr(1); i-- && !(pi[i] + t in s););
                    return i < 0 ? null : (3 === i ? "ms" : i >= 0 ? pi[i] : "") + t
                },
                mi = function () {
                    "undefined" != typeof window && (pn = window, fn = pn.document, mn = fn.documentElement, vn = hi("div") || {
                        style: {}
                    }, yn = hi("div"), ui = fi(ui), ci = fi(ci), vn.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", xn = !!fi("perspective"), gn = 1)
                },
                gi = function t(e) {
                    var n, svg = hi("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                        r = this.parentNode,
                        o = this.nextSibling,
                        c = this.style.cssText;
                    if (mn.appendChild(svg), svg.appendChild(this), this.style.display = "block", e) try {
                        n = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = t
                    } catch (t) {} else this._gsapBBox && (n = this._gsapBBox());
                    return o ? r.insertBefore(this, o) : r.appendChild(this), mn.removeChild(svg), this.style.cssText = c, n
                },
                vi = function (t, e) {
                    for (var i = e.length; i--;)
                        if (t.hasAttribute(e[i])) return t.getAttribute(e[i])
                },
                yi = function (t) {
                    var e;
                    try {
                        e = t.getBBox()
                    } catch (n) {
                        e = gi.call(t, !0)
                    }
                    return !e || e.width || e.x || e.y ? e : {
                        x: +vi(t, ["x", "cx", "x1"]) || 0,
                        y: +vi(t, ["y", "cy", "y1"]) || 0,
                        width: 0,
                        height: 0
                    }
                },
                _i = function (t) {
                    return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !yi(t))
                },
                xi = function (t, e) {
                    if (e) {
                        var style = t.style;
                        e in Hn && (e = ui), style.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), style.removeProperty(e.replace(Wn, "-$1").toLowerCase())) : style.removeAttribute(e)
                    }
                },
                bi = function (t, e, n, r, o, c) {
                    var l = new un(t._pt, e, n, 0, 1, c ? ei : ti);
                    return t._pt = l, l.b = r, l.e = o, t._props.push(n), l
                },
                wi = {
                    deg: 1,
                    rad: 1,
                    turn: 1
                },
                Mi = function (t, e, n, r) {
                    var o, c, l, h, d = parseFloat(n),
                        f = (n + "").substr((d + "").length) || "px",
                        style = vn.style,
                        m = qn.test(e),
                        v = "svg" === t.tagName.toLowerCase(),
                        y = (v ? "client" : "offset") + (m ? "Width" : "Height"),
                        _ = "px" === r;
                    return r === f || wi[r] || wi[f] ? d : (h = t.getCTM && _i(t), "%" === r && Hn[e] ? At(d / (h ? t.getBBox()[m ? "width" : "height"] : t[y]) * 100) : (style[m ? "width" : "height"] = 100 + (_ ? f : r), c = "em" === r && t.appendChild && !v ? t : t.parentNode, h && (c = (t.ownerSVGElement || {}).parentNode), c && c !== fn && c.appendChild || (c = fn.body), (l = c._gsap) && "%" === r && l.width && m && l.time === Ee.time ? o = l.width * d / 100 : (c.appendChild(vn), o = vn[y], c.removeChild(vn), m && "%" === r && ((l = Tt(c)).time = Ee.time, l.width = o / d * 100)), At(_ ? o * d / 100 : 100 / o * d)))
                },
                Ei = function (t, e, n, r) {
                    var o;
                    return gn || mi(), e in Zn && ~(e = Zn[e]).indexOf(",") && (e = e.split(",")[0]), Hn[e] ? (o = Ni(t, r), o = "transformOrigin" !== e ? o[e] : Ii(di(t, ci)) + o.zOrigin + "px") : (!(o = t.style[e]) || "auto" === o || r || ~o.indexOf("calc(")) && (o = di(t, e) || Dt(t, e)), n ? Mi(t, e, o, n) + n : o
                },
                Ti = function (t, e, n, r) {
                    var a, o, c, l, h, d, f, m, v, y, _, x, w = new un(this._pt, t.style, e, 0, 1, en),
                        M = 0,
                        E = 0;
                    if (w.b = n, w.e = r, n += "", "auto" === (r += "") && (t.style[e] = r, r = di(t, e) || r, t.style[e] = n), Me(a = [n, r]), r = a[1], c = (n = a[0]).match(Yn) || [], (r.match(Yn) || []).length) {
                        for (; o = Yn.exec(r);) f = o[0], v = r.substring(M, o.index), h ? h = (h + 1) % 5 : "rgba(" === v.substr(-5) && (h = 1), f !== (d = c[E++] || "") && (l = parseFloat(d) || 0, _ = d.substr((l + "").length), (x = "=" === f.charAt(1) ? +(f.charAt(0) + "1") : 0) && (f = f.substr(2)), m = parseFloat(f), y = f.substr((m + "").length), M = Yn.lastIndex - y.length, y || (y = y || I.units[e] || _, M === r.length && (r += y, w.e += y)), _ !== y && (l = Mi(t, e, d, y) || 0), w._pt = {
                            _next: w._pt,
                            p: v || 1 === E ? v : ",",
                            s: l,
                            c: x ? x * m : m - l,
                            m: h && h < 4 ? Math.round : 0
                        });
                        w.c = M < r.length ? r.substring(M, r.length) : ""
                    } else w.r = "display" === e && "none" === r ? ei : ti;
                    return ot.test(r) && (w.e = 0), this._pt = w, w
                },
                Di = {
                    top: "0%",
                    bottom: "100%",
                    left: "0%",
                    right: "100%",
                    center: "50%"
                },
                Si = function (t, data) {
                    if (data.tween && data.tween._time === data.tween._dur) {
                        var e, n, i, r = data.t,
                            style = r.style,
                            o = data.u;
                        if ("all" === o || !0 === o) style.cssText = "", n = 1;
                        else
                            for (i = (o = o.split(",")).length; --i > -1;) e = o[i], Hn[e] && (n = 1, e = "transformOrigin" === e ? ci : ui), xi(r, e);
                        n && (xi(r, ui), (n = r._gsap) && (n.svg && r.removeAttribute("transform"), n.uncache = 1))
                    }
                },
                Ai = {
                    clearProps: function (t, e, n, r, o) {
                        if ("isFromStart" !== o.data) {
                            var c = t._pt = new un(t._pt, e, n, 0, 0, Si);
                            return c.u = r, c.pr = -10, c.tween = o, t._props.push(n), 1
                        }
                    }
                },
                Ci = [1, 0, 0, 1, 0, 0],
                Li = {},
                Ri = function (t) {
                    return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
                },
                Pi = function (t) {
                    var e = di(t, ui);
                    return Ri(e) ? Ci : e.substr(7).match(nt).map(At)
                },
                Oi = function (t, e) {
                    var n, r, o, c, l = t._gsap,
                        style = t.style,
                        h = Pi(t);
                    return l.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (h = [(o = t.transform.baseVal.consolidate().matrix).a, o.b, o.c, o.d, o.e, o.f]).join(",") ? Ci : h : (h !== Ci || t.offsetParent || t === mn || l.svg || (o = style.display, style.display = "block", (n = t.parentNode) && t.offsetParent || (c = 1, r = t.nextSibling, mn.appendChild(t)), h = Pi(t), o ? style.display = o : xi(t, "display"), c && (r ? n.insertBefore(t, r) : n ? n.appendChild(t) : mn.removeChild(t))), e && h.length > 6 ? [h[0], h[1], h[4], h[5], h[12], h[13]] : h)
                },
                Fi = function (t, e, n, r, o, c) {
                    var l, h, d, f = t._gsap,
                        m = o || Oi(t, !0),
                        v = f.xOrigin || 0,
                        y = f.yOrigin || 0,
                        _ = f.xOffset || 0,
                        x = f.yOffset || 0,
                        a = m[0],
                        b = m[1],
                        w = m[2],
                        M = m[3],
                        E = m[4],
                        T = m[5],
                        D = e.split(" "),
                        S = parseFloat(D[0]) || 0,
                        A = parseFloat(D[1]) || 0;
                    n ? m !== Ci && (h = a * M - b * w) && (d = S * (-b / h) + A * (a / h) - (a * T - b * E) / h, S = S * (M / h) + A * (-w / h) + (w * T - M * E) / h, A = d) : (S = (l = yi(t)).x + (~D[0].indexOf("%") ? S / 100 * l.width : S), A = l.y + (~(D[1] || D[0]).indexOf("%") ? A / 100 * l.height : A)), r || !1 !== r && f.smooth ? (E = S - v, T = A - y, f.xOffset = _ + (E * a + T * w) - E, f.yOffset = x + (E * b + T * M) - T) : f.xOffset = f.yOffset = 0, f.xOrigin = S, f.yOrigin = A, f.smooth = !!r, f.origin = e, f.originIsAbsolute = !!n, t.style[ci] = "0px 0px", c && (bi(c, f, "xOrigin", v, S), bi(c, f, "yOrigin", y, A), bi(c, f, "xOffset", _, f.xOffset), bi(c, f, "yOffset", x, f.yOffset))
                },
                Ni = function (t, e) {
                    var n = t._gsap || new Ie(t);
                    if ("x" in n && !e && !n.uncache) return n;
                    var r, o, c, l, h, d, f, m, v, y, _, x, w, M, E, a, b, T, D, S, A, C, L, R, P, O, F, N, B, k, style = t.style,
                        z = n.scaleX < 0,
                        U = n.xOrigin || 0,
                        H = n.yOrigin || 0,
                        G = di(t, ci) || "0";
                    return r = o = c = d = f = m = v = y = _ = 0, l = h = 1, n.svg = !(!t.getCTM || !_i(t)), x = Oi(t, n.svg), n.svg && Fi(t, G, n.originIsAbsolute, !1 !== n.smooth, x), x !== Ci && (a = x[0], b = x[1], T = x[2], D = x[3], r = S = x[4], o = A = x[5], 6 === x.length ? (l = Math.sqrt(a * a + b * b), h = Math.sqrt(D * D + T * T), d = a || b ? jn(b, a) * Gn : n.rotation || 0, v = T || D ? jn(T, D) * Gn + d : n.skewX || 0, n.svg && (r -= U - (U * a + H * T), o -= H - (U * b + H * D))) : (k = x[6], N = x[7], P = x[8], O = x[9], F = x[10], B = x[11], r = x[12], o = x[13], c = x[14], f = (w = jn(k, F)) * Gn, w && (C = S * (M = Math.cos(-w)) + P * (E = Math.sin(-w)), L = A * M + O * E, R = k * M + F * E, P = S * -E + P * M, O = A * -E + O * M, F = k * -E + F * M, B = N * -E + B * M, S = C, A = L, k = R), m = (w = jn(-T, F)) * Gn, w && (M = Math.cos(-w), B = D * (E = Math.sin(-w)) + B * M, a = C = a * M - P * E, b = L = b * M - O * E, T = R = T * M - F * E), d = (w = jn(b, a)) * Gn, w && (C = a * (M = Math.cos(w)) + b * (E = Math.sin(w)), L = S * M + A * E, b = b * M - a * E, A = A * M - S * E, a = C, S = L), f && Math.abs(f) + Math.abs(d) > 359.9 && (f = d = 0, m = 180 - m), l = At(Math.sqrt(a * a + b * b + T * T)), h = At(Math.sqrt(A * A + k * k)), w = jn(S, A), v = Math.abs(w) > 2e-4 ? w * Gn : 0, _ = B ? 1 / (B < 0 ? -B : B) : 0), n.svg && (x = t.getAttribute("transform"), n.forceCSS = t.setAttribute("transform", "") || !Ri(di(t, ui)), x && t.setAttribute("transform", x))), Math.abs(v) > 90 && Math.abs(v) < 270 && (z ? (l *= -1, v += d <= 0 ? 180 : -180, d += d <= 0 ? 180 : -180) : (h *= -1, v += v <= 0 ? 180 : -180)), n.x = ((n.xPercent = r && Math.round(t.offsetWidth / 2) === Math.round(-r) ? -50 : 0) ? 0 : r) + "px", n.y = ((n.yPercent = o && Math.round(t.offsetHeight / 2) === Math.round(-o) ? -50 : 0) ? 0 : o) + "px", n.z = c + "px", n.scaleX = At(l), n.scaleY = At(h), n.rotation = At(d) + "deg", n.rotationX = At(f) + "deg", n.rotationY = At(m) + "deg", n.skewX = v + "deg", n.skewY = y + "deg", n.transformPerspective = _ + "px", (n.zOrigin = parseFloat(G.split(" ")[2]) || 0) && (style[ci] = Ii(G)), n.xOffset = n.yOffset = 0, n.force3D = I.force3D, n.renderTransform = n.svg ? Ui : xn ? zi : ki, n.uncache = 0, n
                },
                Ii = function (t) {
                    return (t = t.split(" "))[0] + " " + t[1]
                },
                Bi = function (t, e, n) {
                    var r = ee(e);
                    return At(parseFloat(e) + parseFloat(Mi(t, "x", n + "px", r))) + r
                },
                ki = function (t, e) {
                    e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, zi(t, e)
                },
                zi = function (t, e) {
                    var n = e || this,
                        r = n.xPercent,
                        o = n.yPercent,
                        c = n.x,
                        l = n.y,
                        h = n.z,
                        d = n.rotation,
                        f = n.rotationY,
                        m = n.rotationX,
                        v = n.skewX,
                        y = n.skewY,
                        _ = n.scaleX,
                        x = n.scaleY,
                        w = n.transformPerspective,
                        M = n.force3D,
                        E = n.target,
                        T = n.zOrigin,
                        D = "",
                        S = "auto" === M && t && 1 !== t || !0 === M;
                    if (T && ("0deg" !== m || "0deg" !== f)) {
                        var A, C = parseFloat(f) * Vn,
                            L = Math.sin(C),
                            R = Math.cos(C);
                        C = parseFloat(m) * Vn, A = Math.cos(C), c = Bi(E, c, L * A * -T), l = Bi(E, l, -Math.sin(C) * -T), h = Bi(E, h, R * A * -T + T)
                    }(r || o) && (D = "translate(" + r + "%, " + o + "%) "), (S || "0px" !== c || "0px" !== l || "0px" !== h) && (D += "0px" !== h || S ? "translate3d(" + c + ", " + l + ", " + h + ") " : "translate(" + c + ", " + l + ") "), "0px" !== w && (D += "perspective(" + w + ") "), "0deg" !== d && (D += "rotate(" + d + ") "), "0deg" !== f && (D += "rotateY(" + f + ") "), "0deg" !== m && (D += "rotateX(" + m + ") "), "0deg" === v && "0deg" === y || (D += "skew(" + v + ", " + y + ") "), 1 === _ && 1 === x || (D += "scale(" + _ + ", " + x + ") "), E.style[ui] = D || "translate(0, 0)"
                },
                Ui = function (t, e) {
                    var n, r, o, c, l, h = e || this,
                        d = h.xPercent,
                        f = h.yPercent,
                        m = h.x,
                        v = h.y,
                        y = h.rotation,
                        _ = h.skewX,
                        x = h.skewY,
                        w = h.scaleX,
                        M = h.scaleY,
                        E = h.target,
                        T = h.xOrigin,
                        D = h.yOrigin,
                        S = h.xOffset,
                        A = h.yOffset,
                        C = h.forceCSS,
                        L = parseFloat(m),
                        R = parseFloat(v);
                    y = parseFloat(y), _ = parseFloat(_), (x = parseFloat(x)) && (_ += x = parseFloat(x), y += x), y || _ ? (y *= Vn, _ *= Vn, n = Math.cos(y) * w, r = Math.sin(y) * w, o = Math.sin(y - _) * -M, c = Math.cos(y - _) * M, _ && (x *= Vn, l = Math.tan(_ - x), o *= l = Math.sqrt(1 + l * l), c *= l, x && (l = Math.tan(x), n *= l = Math.sqrt(1 + l * l), r *= l)), n = At(n), r = At(r), o = At(o), c = At(c)) : (n = w, c = M, r = o = 0), (L && !~(m + "").indexOf("px") || R && !~(v + "").indexOf("px")) && (L = Mi(E, "x", m, "px"), R = Mi(E, "y", v, "px")), (T || D || S || A) && (L = At(L + T - (T * n + D * o) + S), R = At(R + D - (T * r + D * c) + A)), (d || f) && (l = E.getBBox(), L = At(L + d / 100 * l.width), R = At(R + f / 100 * l.height)), l = "matrix(" + n + "," + r + "," + o + "," + c + "," + L + "," + R + ")", E.setAttribute("transform", l), C && (E.style[ui] = l)
                },
                Hi = function (t, e, n, r, o, c) {
                    var l, h, d = W(o),
                        f = parseFloat(o) * (d && ~o.indexOf("rad") ? Gn : 1),
                        m = c ? f * c : f - r,
                        v = r + m + "deg";
                    return d && ("short" === (l = o.split("_")[1]) && (m %= 360) !== m % 180 && (m += m < 0 ? 360 : -360), "cw" === l && m < 0 ? m = (m + 36e9) % 360 - 360 * ~~(m / 360) : "ccw" === l && m > 0 && (m = (m - 36e9) % 360 - 360 * ~~(m / 360))), t._pt = h = new un(t._pt, e, n, r, m, $n), h.e = v, h.u = "deg", t._props.push(n), h
                },
                Gi = function (t, e, n) {
                    var r, p, o, c, l, h, d, style = yn.style,
                        f = n._gsap;
                    for (p in style.cssText = getComputedStyle(n).cssText + ";position:absolute;display:block;", style[ui] = e, fn.body.appendChild(yn), r = Ni(yn, 1), Hn)(o = f[p]) !== (c = r[p]) && "perspective" !== p && (l = ee(o) !== (d = ee(c)) ? Mi(n, p, o, d) : parseFloat(o), h = parseFloat(c), t._pt = new un(t._pt, f, p, l, h - l, Jn), t._pt.u = d, t._props.push(p));
                    fn.body.removeChild(yn)
                },
                Vi = {
                    name: "css",
                    register: mi,
                    targetTest: function (t) {
                        return t.style && t.nodeType
                    },
                    init: function (t, e, n, r, o) {
                        var c, l, h, d, f, m, p, v, y, _, x, w, M, E, T, D, S, A, C, L = this._props,
                            style = t.style;
                        for (p in gn || mi(), e)
                            if ("autoRound" !== p && (l = e[p], !_t[p] || !Ge(p, e, n, r, t, o)))
                                if (m = Ai[p], "function" === (f = typeof l) && (f = typeof (l = l.call(n, r, t, o))), "string" === f && ~l.indexOf("random(") && (l = he(l)), m) m(this, t, p, l, n) && (T = 1);
                                else if ("--" === p.substr(0, 2)) this.add(style, "setProperty", getComputedStyle(t).getPropertyValue(p) + "", l + "", r, o, 0, 0, p);
                        else {
                            if (c = Ei(t, p), d = parseFloat(c), (_ = "string" === f && "=" === l.charAt(1) ? +(l.charAt(0) + "1") : 0) && (l = l.substr(2)), h = parseFloat(l), p in Zn && ("autoAlpha" === p && (1 === d && "hidden" === Ei(t, "visibility") && h && (d = 0), bi(this, style, "visibility", d ? "inherit" : "hidden", h ? "inherit" : "hidden", !h)), "scale" !== p && ~(p = Zn[p]).indexOf(",") && (p = p.split(",")[0])), x = p in Hn)
                                if (w || (M = t._gsap, E = !1 !== e.smoothOrigin && M.smooth, (w = this._pt = new un(this._pt, style, ui, 0, 1, M.renderTransform, M, 0, -1)).dep = 1), "scale" === p) this._pt = new un(this._pt, M, "scaleY", M.scaleY, _ ? _ * h : h - M.scaleY), L.push("scaleY", p), p += "X";
                                else {
                                    if ("transformOrigin" === p) {
                                        S = void 0, A = void 0, C = void 0, S = (D = l).split(" "), A = S[0], C = S[1] || "50%", "top" !== A && "bottom" !== A && "left" !== C && "right" !== C || (D = A, A = C, C = D), S[0] = Di[A] || A, S[1] = Di[C] || C, l = S.join(" "), M.svg ? Fi(t, l, 0, E, 0, this) : ((y = parseFloat(l.split(" ")[2])) !== M.zOrigin && bi(this, M, "zOrigin", M.zOrigin, y), bi(this, style, p, Ii(c), Ii(l)));
                                        continue
                                    }
                                    if ("svgOrigin" === p) {
                                        Fi(t, l, 1, E, 0, this);
                                        continue
                                    }
                                    if (p in Li) {
                                        Hi(this, M, p, d, l, _);
                                        continue
                                    }
                                    if ("smoothOrigin" === p) {
                                        bi(this, M, "smooth", M.smooth, l);
                                        continue
                                    }
                                    if ("force3D" === p) {
                                        M[p] = l;
                                        continue
                                    }
                                    if ("transform" === p) {
                                        Gi(this, l, t);
                                        continue
                                    }
                                }
                            else p in style || (p = fi(p) || p);
                            if (x || (h || 0 === h) && (d || 0 === d) && !Xn.test(l) && p in style)(v = (c + "").substr((d + "").length)) !== (y = (l + "").substr((h + "").length) || (p in I.units ? I.units[p] : v)) && (d = Mi(t, p, c, y)), this._pt = new un(this._pt, x ? M : style, p, d, _ ? _ * h : h - d, "px" !== y || !1 === e.autoRound || x ? Jn : Kn), this._pt.u = y || 0, v !== y && (this._pt.b = c, this._pt.r = Qn);
                            else if (p in style) Ti.call(this, t, p, c, l);
                            else {
                                if (!(p in t)) {
                                    ht(p, l);
                                    continue
                                }
                                this.add(t, p, t[p], l, r, o)
                            }
                            L.push(p)
                        }
                        T && sn(this)
                    },
                    get: Ei,
                    aliases: Zn,
                    getSetter: function (t, e, n) {
                        return e in Hn && e !== ci && (t._gsap.x || Ei(t, "x")) ? n && _n === n ? "scale" === e ? ai : ri : (_n = n || {}) && ("scale" === e ? oi : si) : t.style && !Z(t.style[e]) ? ni : ~e.indexOf("-") ? ii : Qe(t, e)
                    }
                };
            dn.utils.checkPrefix = fi, wn = St("x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + (bn = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function (t) {
                Hn[t] = 1
            })), St(bn, (function (t) {
                I.units[t] = "deg", Li[t] = 1
            })), Zn[wn[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + bn, St("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,9:rotateX,10:rotateY", (function (t) {
                var e = t.split(":");
                Zn[e[1]] = wn[e[0]]
            })), St("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function (t) {
                I.units[t] = "px"
            })), dn.registerPlugin(Vi), n.d(e, "gsap", (function () {
                return ji
            })), n.d(e, "default", (function () {
                return ji
            })), n.d(e, "CSSPlugin", (function () {
                return Vi
            })), n.d(e, "TweenMax", (function () {
                return qe
            })), n.d(e, "TweenLite", (function () {
                return qe
            })), n.d(e, "TimelineMax", (function () {
                return ke
            })), n.d(e, "TimelineLite", (function () {
                return ke
            })), n.d(e, "Power0", (function () {
                return Mn
            })), n.d(e, "Power1", (function () {
                return En
            })), n.d(e, "Power2", (function () {
                return Tn
            })), n.d(e, "Power3", (function () {
                return Dn
            })), n.d(e, "Power4", (function () {
                return Sn
            })), n.d(e, "Linear", (function () {
                return An
            })), n.d(e, "Quad", (function () {
                return Cn
            })), n.d(e, "Cubic", (function () {
                return Ln
            })), n.d(e, "Quart", (function () {
                return Rn
            })), n.d(e, "Quint", (function () {
                return Pn
            })), n.d(e, "Strong", (function () {
                return On
            })), n.d(e, "Elastic", (function () {
                return Fn
            })), n.d(e, "Back", (function () {
                return Nn
            })), n.d(e, "SteppedEase", (function () {
                return In
            })), n.d(e, "Bounce", (function () {
                return Bn
            })), n.d(e, "Sine", (function () {
                return kn
            })), n.d(e, "Expo", (function () {
                return zn
            })), n.d(e, "Circ", (function () {
                return Un
            }));
            var ji = dn.registerPlugin(Vi) || dn
        },
        310: function (t, e, n) {
            "use strict";
            n.r(e);
            var r = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
                o = /(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
                c = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/gi,
                l = /(^[#\.][a-z]|[a-y][a-z])/i,
                h = Math.PI / 180,
                d = (Math.PI, Math.sin),
                f = Math.cos,
                m = Math.abs,
                v = Math.sqrt,
                y = (Math.atan2, function (t) {
                    return "string" == typeof t
                }),
                _ = function (t) {
                    return "number" == typeof t
                },
                x = function (t) {
                    return ~~(1e5 * t + (t < 0 ? -.5 : .5)) / 1e5
                };

            function w(t) {
                var e, i = 0;
                for (t.reverse(); i < t.length; i += 2) e = t[i], t[i] = t[i + 1], t[i + 1] = e;
                t.reversed = !t.reversed
            }
            var M = function (t, e) {
                    var n, path = document.createElementNS("http://www.w3.org/2000/svg", "path"),
                        r = [].slice.call(t.attributes),
                        i = r.length;
                    for (e = "," + e + ","; --i > -1;) n = r[i].nodeName.toLowerCase(), e.indexOf("," + n + ",") < 0 && path.setAttributeNS(null, n, r[i].nodeValue);
                    return path
                },
                E = {
                    rect: "rx,ry,x,y,width,height",
                    circle: "r,cx,cy",
                    ellipse: "rx,ry,cx,cy",
                    line: "x1,x2,y1,y2"
                },
                T = function (t, e) {
                    for (var n = e ? e.split(",") : [], r = {}, i = n.length; --i > -1;) r[n[i]] = +t.getAttribute(n[i]) || 0;
                    return r
                };

            function D(element, t) {
                var data, e, n, r, c, path, l, h, d, f, m, v, y, _, x, w, D, S, L, R, P, O, F = element.tagName.toLowerCase(),
                    N = .552284749831;
                return "path" !== F && element.getBBox ? (path = M(element, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points"), O = T(element, E[F]), "rect" === F ? (r = O.rx, c = O.ry, e = O.x, n = O.y, f = O.width - 2 * r, m = O.height - 2 * c, data = r || c ? "M" + (w = (_ = (y = e + r) + f) + r) + "," + (S = n + c) + " V" + (L = S + m) + " C" + [w, R = L + c * N, x = _ + r * N, P = L + c, _, P, _ - (_ - y) / 3, P, y + (_ - y) / 3, P, y, P, v = e + r * (1 - N), P, e, R, e, L, e, L - (L - S) / 3, e, S + (L - S) / 3, e, S, e, D = n + c * (1 - N), v, n, y, n, y + (_ - y) / 3, n, _ - (_ - y) / 3, n, _, n, x, n, w, D, w, S].join(",") + "z" : "M" + (e + f) + "," + n + " v" + m + " h" + -f + " v" + -m + " h" + f + "z") : "circle" === F || "ellipse" === F ? ("circle" === F ? h = (r = c = O.r) * N : (r = O.rx, h = (c = O.ry) * N), data = "M" + ((e = O.cx) + r) + "," + (n = O.cy) + " C" + [e + r, n + h, e + (l = r * N), n + c, e, n + c, e - l, n + c, e - r, n + h, e - r, n, e - r, n - h, e - l, n - c, e, n - c, e + l, n - c, e + r, n - h, e + r, n].join(",") + "z") : "line" === F ? data = "M" + O.x1 + "," + O.y1 + " L" + O.x2 + "," + O.y2 : "polyline" !== F && "polygon" !== F || (data = "M" + (e = (d = (element.getAttribute("points") + "").match(o) || []).shift()) + "," + (n = d.shift()) + " L" + d.join(","), "polygon" === F && (data += "," + e + "," + n + "z")), path.setAttribute("d", C(path._gsRawPath = A(data))), t && element.parentNode && (element.parentNode.insertBefore(path, element), element.parentNode.removeChild(element)), path) : element
            }

            function S(t, e, n, r, o, c, l, y, _) {
                if (t !== y || e !== _) {
                    n = m(n), r = m(r);
                    var x = o % 360 * h,
                        w = f(x),
                        M = d(x),
                        E = Math.PI,
                        T = 2 * E,
                        D = (t - y) / 2,
                        S = (e - _) / 2,
                        A = w * D + M * S,
                        C = -M * D + w * S,
                        L = A * A,
                        R = C * C,
                        P = L / (n * n) + R / (r * r);
                    P > 1 && (n = v(P) * n, r = v(P) * r);
                    var O = n * n,
                        F = r * r,
                        N = (O * F - O * R - F * L) / (O * R + F * L);
                    N < 0 && (N = 0);
                    var I = (c === l ? -1 : 1) * v(N),
                        B = I * (n * C / r),
                        k = I * (-r * A / n),
                        z = (t + y) / 2 + (w * B - M * k),
                        U = (e + _) / 2 + (M * B + w * k),
                        H = (A - B) / n,
                        G = (C - k) / r,
                        V = (-A - B) / n,
                        j = (-C - k) / r,
                        W = H * H + G * G,
                        Y = (G < 0 ? -1 : 1) * Math.acos(H / v(W)),
                        X = (H * j - G * V < 0 ? -1 : 1) * Math.acos((H * V + G * j) / v(W * (V * V + j * j)));
                    isNaN(X) && (X = E), !l && X > 0 ? X -= T : l && X < 0 && (X += T), Y %= T, X %= T;
                    var i, Z = Math.ceil(m(X) / (T / 4)),
                        J = [],
                        $ = X / Z,
                        Q = 4 / 3 * d($ / 2) / (1 + f($ / 2)),
                        K = w * n,
                        tt = M * n,
                        et = M * -r,
                        nt = w * r;
                    for (i = 0; i < Z; i++) A = f(o = Y + i * $), C = d(o), H = f(o += $), G = d(o), J.push(A - Q * C, C + Q * A, H + Q * G, G - Q * H, H, G);
                    for (i = 0; i < J.length; i += 2) A = J[i], C = J[i + 1], J[i] = A * K + C * et + z, J[i + 1] = A * tt + C * nt + U;
                    return J[i - 2] = y, J[i - 1] = _, J
                }
            }

            function A(t) {
                var i, e, n, o, l, h, d, f, v, y, _, x, w, a = (t + "").replace(c, (function (t) {
                        var e = +t;
                        return e < 1e-4 && e > -1e-4 ? 0 : e
                    })).match(r) || [],
                    path = [],
                    M = 0,
                    E = 0,
                    T = a.length,
                    D = 0,
                    A = "ERROR: malformed path: " + t,
                    line = function (t, e, n, r) {
                        y = (n - t) / 3, _ = (r - e) / 3, d.push(t + y, e + _, n - y, r - _, n, r)
                    };
                if (!t || !isNaN(a[0]) || isNaN(a[1])) return console.log(A), path;
                for (i = 0; i < T; i++)
                    if (w = l, isNaN(a[i]) ? h = (l = a[i].toUpperCase()) !== a[i] : i--, n = +a[i + 1], o = +a[i + 2], h && (n += M, o += E), i || (f = n, v = o), "M" === l) d && (d.length < 8 ? path.length -= 1 : D += d.length), M = f = n, E = v = o, d = [n, o], path.push(d), i += 2, l = "L";
                    else if ("C" === l) d || (d = [0, 0]), h || (M = E = 0), d.push(n, o, M + 1 * a[i + 3], E + 1 * a[i + 4], M += 1 * a[i + 5], E += 1 * a[i + 6]), i += 6;
                else if ("S" === l) y = M, _ = E, "C" !== w && "S" !== w || (y += M - d[d.length - 4], _ += E - d[d.length - 3]), h || (M = E = 0), d.push(y, _, n, o, M += 1 * a[i + 3], E += 1 * a[i + 4]), i += 4;
                else if ("Q" === l) y = M + 2 / 3 * (n - M), _ = E + 2 / 3 * (o - E), h || (M = E = 0), M += 1 * a[i + 3], E += 1 * a[i + 4], d.push(y, _, M + 2 / 3 * (n - M), E + 2 / 3 * (o - E), M, E), i += 4;
                else if ("T" === l) y = M - d[d.length - 4], _ = E - d[d.length - 3], d.push(M + y, E + _, n + 2 / 3 * (M + 1.5 * y - n), o + 2 / 3 * (E + 1.5 * _ - o), M = n, E = o), i += 2;
                else if ("H" === l) line(M, E, M = n, E), i += 1;
                else if ("V" === l) line(M, E, M, E = n + (h ? E - M : 0)), i += 1;
                else if ("L" === l || "Z" === l) "Z" === l && (n = f, o = v, d.closed = !0), ("L" === l || m(M - n) > .5 || m(E - o) > .5) && (line(M, E, n, o), "L" === l && (i += 2)), M = n, E = o;
                else if ("A" === l) {
                    if (x = S(M, E, +a[i + 1], +a[i + 2], +a[i + 3], +a[i + 4], +a[i + 5], (h ? M : 0) + 1 * a[i + 6], (h ? E : 0) + 1 * a[i + 7]))
                        for (e = 0; e < x.length; e++) d.push(x[e]);
                    M = d[d.length - 2], E = d[d.length - 1], i += 7
                } else console.log(A);
                return (i = d.length) < 6 ? (path.pop(), i = 0) : d[0] === d[i - 2] && d[1] === d[i - 1] && (d.closed = !0), path.totalPoints = D + i, path
            }

            function C(t) {
                _(t[0]) && (t = [t]);
                var e, s, i, n, r = "",
                    o = t.length;
                for (s = 0; s < o; s++) {
                    for (n = t[s], r += "M" + x(n[0]) + "," + x(n[1]) + " C", e = n.length, i = 2; i < e; i++) r += x(n[i++]) + "," + x(n[i++]) + " " + x(n[i++]) + "," + x(n[i++]) + " " + x(n[i++]) + "," + x(n[i]) + " ";
                    n.closed && (r += "z")
                }
                return r
            }
            n.d(e, "MorphSVGPlugin", (function () {
                return vt
            })), n.d(e, "default", (function () {
                return vt
            }));
            var L, R, P, O, F, N = function () {
                    return L || "undefined" != typeof window && (L = window.gsap) && L.registerPlugin && L
                },
                I = Math.atan2,
                B = Math.cos,
                k = Math.sin,
                z = Math.sqrt,
                U = Math.PI,
                H = 2 * U,
                G = .3 * U,
                V = .7 * U,
                j = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi,
                W = /(^[#\.][a-z]|[a-y][a-z])/gi,
                Y = /[achlmqstvz]/gi,
                X = function (t) {
                    return console && console.warn(t)
                },
                Z = function (t) {
                    var i, e = t.length,
                        n = 0,
                        r = 0;
                    for (i = 0; i < e; i++) n += t[i++], r += t[i];
                    return [n / (e / 2), r / (e / 2)]
                },
                J = function (t) {
                    var e, n, i, r = t.length,
                        o = t[0],
                        c = o,
                        l = t[1],
                        h = l;
                    for (i = 6; i < r; i += 6)(e = t[i]) > o ? o = e : e < c && (c = e), (n = t[i + 1]) > l ? l = n : n < h && (h = n);
                    return t.centerX = (o + c) / 2, t.centerY = (l + h) / 2, t.size = (o - c) * (l - h)
                },
                $ = function (t, e) {
                    void 0 === e && (e = 3);
                    for (var n, r, o, i, c, l, h, d, f, m, v, y, _, x, w, M, E = t.length, T = t[0][0], D = T, S = t[0][1], A = S, C = 1 / e; --E > -1;)
                        for (n = (c = t[E]).length, i = 6; i < n; i += 6)
                            for (f = c[i], m = c[i + 1], v = c[i + 2] - f, x = c[i + 3] - m, y = c[i + 4] - f, w = c[i + 5] - m, _ = c[i + 6] - f, M = c[i + 7] - m, l = e; --l > -1;)(r = ((h = C * l) * h * _ + 3 * (d = 1 - h) * (h * y + d * v)) * h + f) > T ? T = r : r < D && (D = r), (o = (h * h * M + 3 * d * (h * w + d * x)) * h + m) > S ? S = o : o < A && (A = o);
                    return t.centerX = (T + D) / 2, t.centerY = (S + A) / 2, t.left = D, t.width = T - D, t.top = A, t.height = S - A, t.size = (T - D) * (S - A)
                },
                Q = function (a, b) {
                    return b.length - a.length
                },
                K = function (a, b) {
                    var t = a.size || J(a),
                        e = b.size || J(b);
                    return Math.abs(e - t) < (t + e) / 20 ? b.centerX - a.centerX || b.centerY - a.centerY : e - t
                },
                tt = function (t, e) {
                    var i, n, a = t.slice(0),
                        r = t.length,
                        o = r - 2;
                    for (e |= 0, i = 0; i < r; i++) n = (i + e) % o, t[i++] = a[n], t[i] = a[n + 1]
                },
                et = function (t, e, n, r, o) {
                    var c, i, l, h, d = t.length,
                        f = 0,
                        m = d - 2;
                    for (n *= 6, i = 0; i < d; i += 6) h = t[c = (i + n) % m] - (e[i] - r), l = t[c + 1] - (e[i + 1] - o), f += z(l * l + h * h);
                    return f
                },
                nt = function (t, e, n) {
                    var r, o, i, c = t.length,
                        l = Z(t),
                        h = Z(e),
                        d = h[0] - l[0],
                        f = h[1] - l[1],
                        m = et(t, e, 0, d, f),
                        v = 0;
                    for (i = 6; i < c; i += 6)(o = et(t, e, i / 6, d, f)) < m && (m = o, v = i);
                    if (n)
                        for (w(r = t.slice(0)), i = 6; i < c; i += 6)(o = et(r, e, i / 6, d, f)) < m && (m = o, v = -i);
                    return v / 6
                },
                it = function (t, e, n) {
                    for (var r, o, c, l, i, h, d = t.length, f = 1e20, m = 0, v = 0; --d > -1;)
                        for (h = (r = t[d]).length, i = 0; i < h; i += 6) o = r[i] - e, c = r[i + 1] - n, (l = z(o * o + c * c)) < f && (f = l, m = r[i], v = r[i + 1]);
                    return [m, v]
                },
                at = function (t, e, n, r, o, c) {
                    var i, l, h, d, f = e.length,
                        m = 0,
                        v = Math.min(t.size || J(t), e[n].size || J(e[n])) * r,
                        y = 1e20,
                        _ = t.centerX + o,
                        x = t.centerY + c;
                    for (i = n; i < f && !((e[i].size || J(e[i])) < v); i++) l = e[i].centerX - _, h = e[i].centerY - x, (d = z(l * l + h * h)) < y && (m = i, y = d);
                    return d = e[m], e.splice(m, 1), d
                },
                ot = function (t, e) {
                    var n, r, o, c, l, h, d, f, m, v, y, _, i, x, w = 0,
                        M = t.length,
                        E = e / ((M - 2) / 6);
                    for (i = 2; i < M; i += 6)
                        for (w += E; w > .999999;) n = t[i - 2], r = t[i - 1], o = t[i], c = t[i + 1], l = t[i + 2], h = t[i + 3], d = t[i + 4], f = t[i + 5], m = n + (o - n) * (x = 1 / ((Math.floor(w) || 1) + 1)), m += ((y = o + (l - o) * x) - m) * x, y += (l + (d - l) * x - y) * x, v = r + (c - r) * x, v += ((_ = c + (h - c) * x) - v) * x, _ += (h + (f - h) * x - _) * x, t.splice(i, 4, n + (o - n) * x, r + (c - r) * x, m, v, m + (y - m) * x, v + (_ - v) * x, y, _, l + (d - l) * x, h + (f - h) * x), i += 6, M += 6, w--;
                    return t
                },
                st = function (t, e, n, map, r) {
                    var o, c, b, l, h, d, f, m = e.length - t.length,
                        v = m > 0 ? e : t,
                        y = m > 0 ? t : e,
                        _ = 0,
                        x = "complexity" === map ? Q : K,
                        M = "position" === map ? 0 : "number" == typeof map ? map : .8,
                        i = y.length,
                        E = "object" == typeof n && n.push ? n.slice(0) : [n],
                        T = "reverse" === E[0] || E[0] < 0,
                        D = "log" === n;
                    if (y[0]) {
                        if (v.length > 1 && (t.sort(x), e.sort(x), v.size || $(v), y.size || $(y), d = v.centerX - y.centerX, f = v.centerY - y.centerY, x === K))
                            for (i = 0; i < y.length; i++) v.splice(i, 0, at(y[i], v, i, M, d, f));
                        if (m)
                            for (m < 0 && (m = -m), v[0].length > y[0].length && ot(y[0], (v[0].length - y[0].length) / 6 | 0), i = y.length; _ < m;) v[i].size || J(v[i]), l = (b = it(y, v[i].centerX, v[i].centerY))[0], h = b[1], y[i++] = [l, h, l, h, l, h, l, h], y.totalPoints += 8, _++;
                        for (i = 0; i < t.length; i++) o = e[i], c = t[i], (m = o.length - c.length) < 0 ? ot(o, -m / 6 | 0) : m > 0 && ot(c, m / 6 | 0), T && !1 !== r && !c.reversed && w(c), (n = E[i] || 0 === E[i] ? E[i] : "auto") && (c.closed || Math.abs(c[0] - c[c.length - 2]) < .5 && Math.abs(c[1] - c[c.length - 1]) < .5 ? "auto" === n || "log" === n ? (E[i] = n = nt(c, o, !i || !1 === r), n < 0 && (T = !0, w(c), n = -n), tt(c, 6 * n)) : "reverse" !== n && (i && n < 0 && w(c), tt(c, 6 * (n < 0 ? -n : n))) : !T && ("auto" === n && Math.abs(o[0] - c[0]) + Math.abs(o[1] - c[1]) + Math.abs(o[o.length - 2] - c[c.length - 2]) + Math.abs(o[o.length - 1] - c[c.length - 1]) > Math.abs(o[0] - c[c.length - 2]) + Math.abs(o[1] - c[c.length - 1]) + Math.abs(o[o.length - 2] - c[0]) + Math.abs(o[o.length - 1] - c[1]) || n % 2) ? (w(c), E[i] = -1, T = !0) : "auto" === n ? E[i] = 0 : "reverse" === n && (E[i] = -1), c.closed !== o.closed && (c.closed = o.closed = !1));
                        return D && X("shapeIndex:[" + E.join(",") + "]"), t.shapeIndex = E, E
                    }
                },
                ut = function (a, t) {
                    var e, i, n, r, o, c, l, h = 0,
                        d = parseFloat(a[0]),
                        f = parseFloat(a[1]),
                        s = d + "," + f + " ";
                    for (e = .5 * t / (.5 * (n = a.length) - 1), i = 0; i < n - 2; i += 2) {
                        if (h += e, c = parseFloat(a[i + 2]), l = parseFloat(a[i + 3]), h > .999999)
                            for (o = 1 / (Math.floor(h) + 1), r = 1; h > .999999;) s += (d + (c - d) * o * r).toFixed(2) + "," + (f + (l - f) * o * r).toFixed(2) + " ", h--, r++;
                        s += c + "," + l + " ", d = c, f = l
                    }
                    return s
                },
                ct = function (a) {
                    var t = a[0].match(j) || [],
                        e = a[1].match(j) || [],
                        n = e.length - t.length;
                    n > 0 ? a[0] = ut(t, n) : a[1] = ut(e, -n)
                },
                lt = function (t) {
                    return isNaN(t) ? ct : function (a) {
                        ct(a), a[1] = function (text, t) {
                            if (!t) return text;
                            var e, i, n, a = text.match(j) || [],
                                r = a.length,
                                s = "";
                            for ("reverse" === t ? (i = r - 1, e = -2) : (i = (2 * (parseInt(t, 10) || 0) + 1 + 100 * r) % r, e = 2), n = 0; n < r; n += 2) s += a[i - 1] + "," + a[i] + " ", i = (i + e) % r;
                            return s
                        }(a[1], parseInt(t, 10))
                    }
                },
                ht = function (t, e) {
                    for (var n, r, o, c, l, h, i, d, a, f, m, v, y = t.length, _ = .2 * (e || 1); --y > -1;) {
                        for (m = (r = t[y]).isSmooth = r.isSmooth || [0, 0, 0, 0], v = r.smoothData = r.smoothData || [0, 0, 0, 0], m.length = 4, d = r.length - 2, i = 6; i < d; i += 6) o = r[i] - r[i - 2], c = r[i + 1] - r[i - 1], l = r[i + 2] - r[i], h = r[i + 3] - r[i + 1], a = I(c, o), f = I(h, l), (n = Math.abs(a - f) < _) && (v[i - 2] = a, v[i + 2] = f, v[i - 1] = z(o * o + c * c), v[i + 3] = z(l * l + h * h)), m.push(n, n, 0, 0, n, n);
                        r[d] === r[0] && r[d + 1] === r[1] && (o = r[0] - r[d - 2], c = r[1] - r[d - 1], l = r[2] - r[0], h = r[3] - r[1], a = I(c, o), f = I(h, l), Math.abs(a - f) < _ && (v[d - 2] = a, v[2] = f, v[d - 1] = z(o * o + c * c), v[3] = z(l * l + h * h), m[d - 2] = m[d - 1] = !0))
                    }
                    return t
                },
                pt = function (t) {
                    var a = t.trim().split(" ");
                    return {
                        x: (~t.indexOf("left") ? 0 : ~t.indexOf("right") ? 100 : isNaN(parseFloat(a[0])) ? 50 : parseFloat(a[0])) / 100,
                        y: (~t.indexOf("top") ? 0 : ~t.indexOf("bottom") ? 100 : isNaN(parseFloat(a[1])) ? 50 : parseFloat(a[1])) / 100
                    }
                },
                ft = "Use MorphSVGPlugin.convertToPath() to convert to a path before morphing.",
                mt = function (t, e, i, n) {
                    var r, o, c, l = this._origin,
                        h = this._eOrigin,
                        d = t[i] - l.x,
                        f = t[i + 1] - l.y,
                        m = z(d * d + f * f),
                        v = I(f, d);
                    return d = e[i] - h.x, f = e[i + 1] - h.y, r = I(f, d) - v, o = (c = r) !== c % U ? c + (c < 0 ? H : -H) : c, !n && P && Math.abs(o + P.ca) < G && (n = P), this._anchorPT = P = {
                        _next: this._anchorPT,
                        t: t,
                        sa: v,
                        ca: n && o * n.ca < 0 && Math.abs(o) > V ? r : o,
                        sl: m,
                        cl: z(d * d + f * f) - m,
                        i: i
                    }
                },
                gt = function (t) {
                    L = N(), F = F || L && L.plugins.morphSVG, L && F ? (R = L.utils.toArray, document, F.prototype._tweenRotation = mt, O = 1) : t && X("Please gsap.registerPlugin(MorphSVGPlugin)")
                },
                vt = {
                    version: "3.0.2",
                    name: "morphSVG",
                    register: function (t, e) {
                        L = t, F = e, gt()
                    },
                    init: function (t, e, n, r, o) {
                        var c, p, l, h, d, f, map, m, v, y, _, i, x, w, M, E, T, S, L, F, N, I, B = t.nodeType ? window.getComputedStyle(t) : {},
                            k = B.fill + "",
                            z = !("none" === k || "0" === (k.match(j) || [])[3] || "evenodd" === B.fillRule),
                            U = (e.origin || "50 50").split(",");
                        if (O || gt(1), d = "POLYLINE" === (c = (t.nodeName + "").toUpperCase()) || "POLYGON" === c, "PATH" !== c && !d && !e.prop) return X("Cannot morph a <" + c + "> element. " + ft), !1;
                        if (p = "PATH" === c ? "d" : "points", ("string" == typeof e || e.getBBox || e[0]) && (e = {
                                shape: e
                            }), !e.prop && "function" != typeof t.setAttribute) return !1;
                        if (h = function (t, e, n) {
                                var r, o;
                                return (!("string" == typeof t) || W.test(t) || (t.match(j) || []).length < 3) && ((r = R(t)[0]) ? (o = (r.nodeName + "").toUpperCase(), e && "PATH" !== o && (r = D(r, !1), o = "PATH"), t = r.getAttribute("PATH" === o ? "d" : "points") || "", r === n && (t = r.getAttributeNS(null, "data-original") || t)) : (X("WARNING: invalid morph to: " + t), t = !1)), t
                            }(e.shape || e.d || e.points || "", "d" === p, t), d && Y.test(h)) return X("A <" + c + "> cannot accept path data. " + ft), !1;
                        if (f = e.shapeIndex || 0 === e.shapeIndex ? e.shapeIndex : "auto", map = e.map || vt.defaultMap, this._prop = e.prop, this._render = e.render || vt.defaultRender, this._apply = "updateTarget" in e ? e.updateTarget : vt.defaultUpdateTarget, this._rnd = Math.pow(10, isNaN(e.precision) ? 2 : +e.precision), this._tween = n, h) {
                            if (this._target = t, T = "object" == typeof e.precompile, y = this._prop ? t[this._prop] : t.getAttribute(p), this._prop || t.getAttributeNS(null, "data-original") || t.setAttributeNS(null, "data-original", y), "d" === p || this._prop) {
                                if (y = A(T ? e.precompile[0] : y), _ = A(T ? e.precompile[1] : h), !T && !st(y, _, f, map, z)) return !1;
                                for ("log" !== e.precompile && !0 !== e.precompile || X('precompile:["' + C(y) + '","' + C(_) + '"]'), (N = "linear" !== (e.type || vt.defaultType)) && (y = ht(y, e.smoothTolerance), _ = ht(_, e.smoothTolerance), y.size || $(y), _.size || $(_), F = pt(U[0]), this._origin = y.origin = {
                                        x: y.left + F.x * y.width,
                                        y: y.top + F.y * y.height
                                    }, U[1] && (F = pt(U[1])), this._eOrigin = {
                                        x: _.left + F.x * _.width,
                                        y: _.top + F.y * _.height
                                    }), this._rawPath = t._gsRawPath = y, x = y.length; --x > -1;)
                                    for (M = y[x], E = _[x], m = M.isSmooth || [], v = E.isSmooth || [], w = M.length, P = 0, i = 0; i < w; i += 2) E[i] === M[i] && E[i + 1] === M[i + 1] || (N ? m[i] && v[i] ? (S = M.smoothData, L = E.smoothData, I = i + (i === w - 4 ? 7 - w : 5), this._controlPT = {
                                        _next: this._controlPT,
                                        i: i,
                                        j: x,
                                        l1s: S[i + 1],
                                        l1c: L[i + 1] - S[i + 1],
                                        l2s: S[I],
                                        l2c: L[I] - S[I]
                                    }, l = this._tweenRotation(M, E, i + 2), this._tweenRotation(M, E, i, l), this._tweenRotation(M, E, I - 1, l), i += 4) : this._tweenRotation(M, E, i) : (l = this.add(M, i, M[i], E[i]), l = this.add(M, i + 1, M[i + 1], E[i + 1]) || l))
                            } else l = this.add(t, "setAttribute", t.getAttribute(p) + "", h + "", r, o, 0, lt(f), p);
                            N && (this.add(this._origin, "x", this._origin.x, this._eOrigin.x), l = this.add(this._origin, "y", this._origin.y, this._eOrigin.y)), l && (this._props.push("morphSVG"), l.end = h, l.endProp = p)
                        }
                        return 1
                    },
                    render: function (t, data) {
                        for (var s, e, n, r, o, i, c, l, h, d, f, m, v = data._rawPath, y = data._controlPT, _ = data._anchorPT, x = data._rnd, w = data._target, M = data._pt; M;) M.r(t, M.d), M = M._next;
                        if (1 === t && data._apply)
                            for (M = data._pt; M;) M.end && (data._prop ? w[data._prop] = M.end : w.setAttribute(M.endProp, M.end)), M = M._next;
                        else if (v) {
                            for (; _;) o = _.sa + t * _.ca, r = _.sl + t * _.cl, _.t[_.i] = data._origin.x + B(o) * r, _.t[_.i + 1] = data._origin.y + k(o) * r, _ = _._next;
                            for (e = t < .5 ? 2 * t * t : (4 - 2 * t) * t - 1; y;) m = (i = y.i) + (i === (n = v[y.j]).length - 4 ? 7 - n.length : 5), o = I(n[m] - n[i + 1], n[m - 1] - n[i]), d = k(o), f = B(o), l = n[i + 2], h = n[i + 3], r = y.l1s + e * y.l1c, n[i] = l - f * r, n[i + 1] = h - d * r, r = y.l2s + e * y.l2c, n[m - 1] = l + f * r, n[m] = h + d * r, y = y._next;
                            if (w._gsRawPath = v, data._apply) {
                                for (s = "", " ", c = 0; c < v.length; c++)
                                    for (r = (n = v[c]).length, s += "M" + (n[0] * x | 0) / x + " " + (n[1] * x | 0) / x + " C", i = 2; i < r; i++) s += (n[i] * x | 0) / x + " ";
                                data._prop ? w[data._prop] = s : w.setAttribute("d", s)
                            }
                        }
                        data._render && v && data._render.call(data._tween, v, w)
                    },
                    kill: function (t) {
                        this._pt = this._rawPath = 0
                    },
                    getRawPath: function (t) {
                        var e, n = (t = y(t) && l.test(t) && document.querySelector(t) || t).getAttribute ? t : 0;
                        return n && (t = t.getAttribute("d")) ? (n._gsPath || (n._gsPath = {}), (e = n._gsPath[t]) && !e._dirty ? e : n._gsPath[t] = A(t)) : t ? y(t) ? A(t) : _(t[0]) ? [t] : t : console.warn("Expecting a <path> element or an SVG path data string")
                    },
                    stringToRawPath: A,
                    rawPathToString: C,
                    pathFilter: function (a, t, map, e, n) {
                        var r = A(a[0]),
                            o = A(a[1]);
                        st(r, o, t || 0 === t ? t : "auto", map, n) && (a[0] = C(r), a[1] = C(o), "log" !== e && !0 !== e || X('precompile:["' + a[0] + '","' + a[1] + '"]'))
                    },
                    pointsFilter: ct,
                    getTotalSize: $,
                    equalizeSegmentQuantity: st,
                    convertToPath: function (t, e) {
                        return R(t).map((function (t) {
                            return D(t, !1 !== e)
                        }))
                    },
                    defaultType: "linear",
                    defaultUpdateTarget: !0,
                    defaultMap: "size"
                };
            N() && L.registerPlugin(vt)
        },
        311: function (t, e, n) {
            "use strict";
            n.r(e);
            var r = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;
            n.d(e, "SplitText", (function () {
                return O
            })), n.d(e, "default", (function () {
                return O
            }));
            var o, c, l, h = /(?:\r|\n|\t\t)/g,
                d = /(?:\s\s+)/g,
                f = function () {
                    o = document, c = window, l = 1
                },
                m = 1,
                v = function (element) {
                    return c.getComputedStyle(element)
                },
                y = Array.isArray,
                _ = [].slice,
                x = function (t, e) {
                    var n;
                    return y(t) ? t : "string" == (n = typeof t) && !e && t ? _.call(o.querySelectorAll(t), 0) : t && "object" === n && "length" in t ? _.call(t, 0) : t ? [t] : []
                },
                w = function (t) {
                    return "absolute" === t.position || !0 === t.absolute
                },
                M = function (text, t) {
                    for (var s, i = t.length; --i > -1;)
                        if (s = t[i], text.substr(0, s.length) === s) return s.length
                },
                E = function (t, e) {
                    void 0 === t && (t = "");
                    var n = ~t.indexOf("++"),
                        r = 1;
                    return n && (t = t.split("++").join("")),
                        function () {
                            return "<" + e + " style='position:relative;display:inline-block;'" + (t ? " class='" + t + (n ? r++ : "") + "'>" : ">")
                        }
                },
                T = function t(element, e, n) {
                    var r = element.nodeType;
                    if (1 === r || 9 === r || 11 === r)
                        for (element = element.firstChild; element; element = element.nextSibling) t(element, e, n);
                    else 3 !== r && 4 !== r || (element.nodeValue = element.nodeValue.split(e).join(n))
                },
                D = function (a, t) {
                    for (var i = t.length; --i > -1;) a.push(t[i])
                },
                S = function (t, e, n) {
                    for (var r; t && t !== e;) {
                        if (r = t._next || t.nextSibling) return r.textContent.charAt(0) === n;
                        t = t.parentNode || t._parent
                    }
                },
                A = function t(e) {
                    var i, n, r = x(e.childNodes),
                        o = r.length;
                    for (i = 0; i < o; i++)(n = r[i])._isSplit ? t(n) : (i && 3 === n.previousSibling.nodeType ? n.previousSibling.nodeValue += 3 === n.nodeType ? n.nodeValue : n.firstChild.nodeValue : 3 !== n.nodeType && e.insertBefore(n.firstChild, n), e.removeChild(n))
                },
                C = function (t, e) {
                    return parseFloat(e[t]) || 0
                },
                L = function (element, t, e, n, r, c, l) {
                    var i, h, d, f, m, y, _, x, style, M, E, L, R = v(element),
                        P = C("paddingLeft", R),
                        O = -999,
                        F = C("borderBottomWidth", R) + C("borderTopWidth", R),
                        N = C("borderLeftWidth", R) + C("borderRightWidth", R),
                        I = C("paddingTop", R) + C("paddingBottom", R),
                        B = C("paddingLeft", R) + C("paddingRight", R),
                        k = .2 * C("fontSize", R),
                        z = R.textAlign,
                        U = [],
                        H = [],
                        G = [],
                        V = t.wordDelimiter || " ",
                        j = t.tag ? t.tag : t.span ? "span" : "div",
                        W = t.type || t.split || "chars,words,lines",
                        Y = r && ~W.indexOf("lines") ? [] : null,
                        X = ~W.indexOf("words"),
                        Z = ~W.indexOf("chars"),
                        J = w(t),
                        $ = t.linesClass,
                        Q = ~($ || "").indexOf("++"),
                        K = [];
                    for (Q && ($ = $.split("++").join("")), d = (h = element.getElementsByTagName("*")).length, m = [], i = 0; i < d; i++) m[i] = h[i];
                    if (Y || J)
                        for (i = 0; i < d; i++)((y = (f = m[i]).parentNode === element) || J || Z && !X) && (L = f.offsetTop, Y && y && Math.abs(L - O) > k && ("BR" !== f.nodeName || 0 === i) && (_ = [], Y.push(_), O = L), J && (f._x = f.offsetLeft, f._y = L, f._w = f.offsetWidth, f._h = f.offsetHeight), Y && ((f._isSplit && y || !Z && y || X && y || !X && f.parentNode.parentNode === element && !f.parentNode._isSplit) && (_.push(f), f._x -= P, S(f, element, V) && (f._wordEnd = !0)), "BR" === f.nodeName && (f.nextSibling && "BR" === f.nextSibling.nodeName || 0 === i) && Y.push([])));
                    for (i = 0; i < d; i++) y = (f = m[i]).parentNode === element, "BR" !== f.nodeName ? (J && (style = f.style, X || y || (f._x += f.parentNode._x, f._y += f.parentNode._y), style.left = f._x + "px", style.top = f._y + "px", style.position = "absolute", style.display = "block", style.width = f._w + 1 + "px", style.height = f._h + "px"), !X && Z ? f._isSplit ? (f._next = f.nextSibling, f.parentNode.appendChild(f)) : f.parentNode._isSplit ? (f._parent = f.parentNode, !f.previousSibling && f.firstChild && (f.firstChild._isFirst = !0), f.nextSibling && " " === f.nextSibling.textContent && !f.nextSibling.nextSibling && K.push(f.nextSibling), f._next = f.nextSibling && f.nextSibling._isFirst ? null : f.nextSibling, f.parentNode.removeChild(f), m.splice(i--, 1), d--) : y || (L = !f.nextSibling && S(f.parentNode, element, V), f.parentNode._parent && f.parentNode._parent.appendChild(f), L && f.parentNode.appendChild(o.createTextNode(" ")), "span" === j && (f.style.display = "inline"), U.push(f)) : f.parentNode._isSplit && !f._isSplit && "" !== f.innerHTML ? H.push(f) : Z && !f._isSplit && ("span" === j && (f.style.display = "inline"), U.push(f))) : Y || J ? (f.parentNode && f.parentNode.removeChild(f), m.splice(i--, 1), d--) : X || element.appendChild(f);
                    for (i = K.length; --i > -1;) K[i].parentNode.removeChild(K[i]);
                    if (Y) {
                        for (J && (M = o.createElement(j), element.appendChild(M), E = M.offsetWidth + "px", L = M.offsetParent === element ? 0 : element.offsetLeft, element.removeChild(M)), style = element.style.cssText, element.style.cssText = "display:none;"; element.firstChild;) element.removeChild(element.firstChild);
                        for (x = " " === V && (!J || !X && !Z), i = 0; i < Y.length; i++) {
                            for (_ = Y[i], (M = o.createElement(j)).style.cssText = "display:block;text-align:" + z + ";position:" + (J ? "absolute;" : "relative;"), $ && (M.className = $ + (Q ? i + 1 : "")), G.push(M), d = _.length, h = 0; h < d; h++) "BR" !== _[h].nodeName && (f = _[h], M.appendChild(f), x && f._wordEnd && M.appendChild(o.createTextNode(" ")), J && (0 === h && (M.style.top = f._y + "px", M.style.left = P + L + "px"), f.style.top = "0px", L && (f.style.left = f._x - L + "px")));
                            0 === d ? M.innerHTML = "&nbsp;" : X || Z || (A(M), T(M, String.fromCharCode(160), " ")), J && (M.style.width = E, M.style.height = f._h + "px"), element.appendChild(M)
                        }
                        element.style.cssText = style
                    }
                    J && (l > element.clientHeight && (element.style.height = l - I + "px", element.clientHeight < l && (element.style.height = l + F + "px")), c > element.clientWidth && (element.style.width = c - B + "px", element.clientWidth < c && (element.style.width = c + N + "px"))), D(e, U), X && D(n, H), D(r, G)
                },
                R = function (element, t, e, n) {
                    var text, c, i, l, f, m, v, y, _ = t.tag ? t.tag : t.span ? "span" : "div",
                        x = ~(t.type || t.split || "chars,words,lines").indexOf("chars"),
                        E = w(t),
                        D = t.wordDelimiter || " ",
                        S = " " !== D ? "" : E ? "&#173; " : " ",
                        A = "</" + _ + ">",
                        C = 1,
                        L = t.specialChars ? "function" == typeof t.specialChars ? t.specialChars : M : null,
                        R = o.createElement("div"),
                        P = element.parentNode;
                    for (P.insertBefore(R, element), R.textContent = element.nodeValue, P.removeChild(element), v = -1 !== (text = function t(e) {
                            var n = e.nodeType,
                                r = "";
                            if (1 === n || 9 === n || 11 === n) {
                                if ("string" == typeof e.textContent) return e.textContent;
                                for (e = e.firstChild; e; e = e.nextSibling) r += t(e)
                            } else if (3 === n || 4 === n) return e.nodeValue;
                            return r
                        }(element = R)).indexOf("<"), !1 !== t.reduceWhiteSpace && (text = text.replace(d, " ").replace(h, "")), v && (text = text.split("<").join("{{LT}}")), f = text.length, c = (" " === text.charAt(0) ? S : "") + e(), i = 0; i < f; i++)
                        if (m = text.charAt(i), L && (y = L(text.substr(i), t.specialChars))) m = text.substr(i, y || 1), c += x && " " !== m ? n() + m + "</" + _ + ">" : m, i += y - 1;
                        else if (m === D && text.charAt(i - 1) !== D && i) {
                        for (c += C ? A : "", C = 0; text.charAt(i + 1) === D;) c += S, i++;
                        i === f - 1 ? c += S : ")" !== text.charAt(i + 1) && (c += S + e(), C = 1)
                    } else "{" === m && "{{LT}}" === text.substr(i, 6) ? (c += x ? n() + "{{LT}}</" + _ + ">" : "{{LT}}", i += 5) : m.charCodeAt(0) >= 55296 && m.charCodeAt(0) <= 56319 || text.charCodeAt(i + 1) >= 65024 && text.charCodeAt(i + 1) <= 65039 ? (l = ((text.substr(i, 12).split(r) || [])[1] || "").length || 2, c += x && " " !== m ? n() + text.substr(i, l) + "</" + _ + ">" : text.substr(i, l), i += l - 1) : c += x && " " !== m ? n() + m + "</" + _ + ">" : m;
                    element.outerHTML = c + (C ? A : ""), v && T(P, "{{LT}}", "<")
                },
                P = function t(element, e, n, r) {
                    var i, o, c = x(element.childNodes),
                        l = c.length,
                        h = w(e);
                    if (3 !== element.nodeType || l > 1) {
                        for (e.absolute = !1, i = 0; i < l; i++)(3 !== (o = c[i]).nodeType || /\S+/.test(o.nodeValue)) && (h && 3 !== o.nodeType && "inline" === v(o).display && (o.style.display = "inline-block", o.style.position = "relative"), o._isSplit = !0, t(o, e, n, r));
                        return e.absolute = h, void(element._isSplit = !0)
                    }
                    R(element, e, n, r)
                },
                O = function () {
                    function t(element, t) {
                        l || f(), this.elements = x(element), this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = t || {}, m && this.split(t)
                    }
                    var e = t.prototype;
                    return e.split = function (t) {
                        this.isSplit && this.revert(), this.vars = t = t || this.vars, this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
                        for (var e, n, r, i = this.elements.length, o = t.tag ? t.tag : t.span ? "span" : "div", c = E(t.wordsClass, o), l = E(t.charsClass, o); --i > -1;) r = this.elements[i], this._originals[i] = r.innerHTML, e = r.clientHeight, n = r.clientWidth, P(r, t, c, l), L(r, t, this.chars, this.words, this.lines, n, e);
                        return this.chars.reverse(), this.words.reverse(), this.lines.reverse(), this.isSplit = !0, this
                    }, e.revert = function () {
                        var t = this._originals;
                        if (!t) throw "revert() call wasn't scoped properly.";
                        return this.elements.forEach((function (e, i) {
                            return e.innerHTML = t[i]
                        })), this.chars = [], this.words = [], this.lines = [], this.isSplit = !1, this
                    }, t.create = function (element, e) {
                        return new t(element, e)
                    }, t
                }();
            O.version = "3.0.2"
        },
        58: function (t, e, n) {
            "use strict";
            var r = {
                name: "NoSsr",
                functional: !0,
                props: {
                    placeholder: String,
                    placeholderTag: {
                        type: String,
                        default: "div"
                    }
                },
                render: function (t, e) {
                    var n = e.parent,
                        r = e.slots,
                        o = e.props,
                        c = r(),
                        l = c.default;
                    void 0 === l && (l = []);
                    var h = c.placeholder;
                    return n._isMounted ? l : (n.$once("hook:mounted", (function () {
                        n.$forceUpdate()
                    })), o.placeholderTag && (o.placeholder || h) ? t(o.placeholderTag, {
                        class: ["no-ssr-placeholder"]
                    }, o.placeholder || h) : l.length > 0 ? l.map((function () {
                        return t(!1)
                    })) : t(!1))
                }
            };
            t.exports = r
        },
        65: function (t, e, n) {
            (function (t) {
                t.exports = function () {
                    "use strict";
                    var e, n;

                    function r() {
                        return e.apply(null, arguments)
                    }

                    function o(input) {
                        return input instanceof Array || "[object Array]" === Object.prototype.toString.call(input)
                    }

                    function c(input) {
                        return null != input && "[object Object]" === Object.prototype.toString.call(input)
                    }

                    function l(input) {
                        return void 0 === input
                    }

                    function h(input) {
                        return "number" == typeof input || "[object Number]" === Object.prototype.toString.call(input)
                    }

                    function d(input) {
                        return input instanceof Date || "[object Date]" === Object.prototype.toString.call(input)
                    }

                    function map(t, e) {
                        var i, n = [];
                        for (i = 0; i < t.length; ++i) n.push(e(t[i], i));
                        return n
                    }

                    function f(a, b) {
                        return Object.prototype.hasOwnProperty.call(a, b)
                    }

                    function m(a, b) {
                        for (var i in b) f(b, i) && (a[i] = b[i]);
                        return f(b, "toString") && (a.toString = b.toString), f(b, "valueOf") && (a.valueOf = b.valueOf), a
                    }

                    function v(input, t, e, n) {
                        return He(input, t, e, n, !0).utc()
                    }

                    function y(t) {
                        return null == t._pf && (t._pf = {
                            empty: !1,
                            unusedTokens: [],
                            unusedInput: [],
                            overflow: -2,
                            charsLeftOver: 0,
                            nullInput: !1,
                            invalidMonth: null,
                            invalidFormat: !1,
                            userInvalidated: !1,
                            iso: !1,
                            parsedDateParts: [],
                            meridiem: null,
                            rfc2822: !1,
                            weekdayMismatch: !1
                        }), t._pf
                    }

                    function _(t) {
                        if (null == t._isValid) {
                            var e = y(t),
                                r = n.call(e.parsedDateParts, (function (i) {
                                    return null != i
                                })),
                                o = !isNaN(t._d.getTime()) && e.overflow < 0 && !e.empty && !e.invalidMonth && !e.invalidWeekday && !e.weekdayMismatch && !e.nullInput && !e.invalidFormat && !e.userInvalidated && (!e.meridiem || e.meridiem && r);
                            if (t._strict && (o = o && 0 === e.charsLeftOver && 0 === e.unusedTokens.length && void 0 === e.bigHour), null != Object.isFrozen && Object.isFrozen(t)) return o;
                            t._isValid = o
                        }
                        return t._isValid
                    }

                    function x(t) {
                        var e = v(NaN);
                        return null != t ? m(y(e), t) : y(e).userInvalidated = !0, e
                    }
                    n = Array.prototype.some ? Array.prototype.some : function (t) {
                        for (var e = Object(this), n = e.length >>> 0, i = 0; i < n; i++)
                            if (i in e && t.call(this, e[i], i, e)) return !0;
                        return !1
                    };
                    var w = r.momentProperties = [];

                    function M(t, e) {
                        var i, n, r;
                        if (l(e._isAMomentObject) || (t._isAMomentObject = e._isAMomentObject), l(e._i) || (t._i = e._i), l(e._f) || (t._f = e._f), l(e._l) || (t._l = e._l), l(e._strict) || (t._strict = e._strict), l(e._tzm) || (t._tzm = e._tzm), l(e._isUTC) || (t._isUTC = e._isUTC), l(e._offset) || (t._offset = e._offset), l(e._pf) || (t._pf = y(e)), l(e._locale) || (t._locale = e._locale), w.length > 0)
                            for (i = 0; i < w.length; i++) l(r = e[n = w[i]]) || (t[n] = r);
                        return t
                    }
                    var E = !1;

                    function T(t) {
                        M(this, t), this._d = new Date(null != t._d ? t._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), !1 === E && (E = !0, r.updateOffset(this), E = !1)
                    }

                    function D(t) {
                        return t instanceof T || null != t && null != t._isAMomentObject
                    }

                    function S(t) {
                        return t < 0 ? Math.ceil(t) || 0 : Math.floor(t)
                    }

                    function A(t) {
                        var e = +t,
                            n = 0;
                        return 0 !== e && isFinite(e) && (n = S(e)), n
                    }

                    function C(t, e, n) {
                        var i, r = Math.min(t.length, e.length),
                            o = Math.abs(t.length - e.length),
                            c = 0;
                        for (i = 0; i < r; i++)(n && t[i] !== e[i] || !n && A(t[i]) !== A(e[i])) && c++;
                        return c + o
                    }

                    function L(t) {
                        !1 === r.suppressDeprecationWarnings && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + t)
                    }

                    function R(t, e) {
                        var n = !0;
                        return m((function () {
                            if (null != r.deprecationHandler && r.deprecationHandler(null, t), n) {
                                for (var o, c = [], i = 0; i < arguments.length; i++) {
                                    if (o = "", "object" == typeof arguments[i]) {
                                        for (var l in o += "\n[" + i + "] ", arguments[0]) o += l + ": " + arguments[0][l] + ", ";
                                        o = o.slice(0, -2)
                                    } else o = arguments[i];
                                    c.push(o)
                                }
                                L(t + "\nArguments: " + Array.prototype.slice.call(c).join("") + "\n" + (new Error).stack), n = !1
                            }
                            return e.apply(this, arguments)
                        }), e)
                    }
                    var P, O = {};

                    function F(t, e) {
                        null != r.deprecationHandler && r.deprecationHandler(t, e), O[t] || (L(e), O[t] = !0)
                    }

                    function N(input) {
                        return input instanceof Function || "[object Function]" === Object.prototype.toString.call(input)
                    }

                    function I(t, e) {
                        var n, r = m({}, t);
                        for (n in e) f(e, n) && (c(t[n]) && c(e[n]) ? (r[n] = {}, m(r[n], t[n]), m(r[n], e[n])) : null != e[n] ? r[n] = e[n] : delete r[n]);
                        for (n in t) f(t, n) && !f(e, n) && c(t[n]) && (r[n] = m({}, r[n]));
                        return r
                    }

                    function B(t) {
                        null != t && this.set(t)
                    }
                    r.suppressDeprecationWarnings = !1, r.deprecationHandler = null, P = Object.keys ? Object.keys : function (t) {
                        var i, e = [];
                        for (i in t) f(t, i) && e.push(i);
                        return e
                    };
                    var k = {};

                    function z(t, e) {
                        var n = t.toLowerCase();
                        k[n] = k[n + "s"] = k[e] = t
                    }

                    function U(t) {
                        return "string" == typeof t ? k[t] || k[t.toLowerCase()] : void 0
                    }

                    function H(t) {
                        var e, n, r = {};
                        for (n in t) f(t, n) && (e = U(n)) && (r[e] = t[n]);
                        return r
                    }
                    var G = {};

                    function V(t, e) {
                        G[t] = e
                    }

                    function j(t, e, n) {
                        var r = "" + Math.abs(t),
                            o = e - r.length;
                        return (t >= 0 ? n ? "+" : "" : "-") + Math.pow(10, Math.max(0, o)).toString().substr(1) + r
                    }
                    var W = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
                        Y = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
                        X = {},
                        Z = {};

                    function J(t, e, n, r) {
                        var o = r;
                        "string" == typeof r && (o = function () {
                            return this[r]()
                        }), t && (Z[t] = o), e && (Z[e[0]] = function () {
                            return j(o.apply(this, arguments), e[1], e[2])
                        }), n && (Z[n] = function () {
                            return this.localeData().ordinal(o.apply(this, arguments), t)
                        })
                    }

                    function $(t, e) {
                        return t.isValid() ? (e = Q(e, t.localeData()), X[e] = X[e] || function (t) {
                            var i, e, input, n = t.match(W);
                            for (i = 0, e = n.length; i < e; i++) Z[n[i]] ? n[i] = Z[n[i]] : n[i] = (input = n[i]).match(/\[[\s\S]/) ? input.replace(/^\[|\]$/g, "") : input.replace(/\\/g, "");
                            return function (r) {
                                var i, output = "";
                                for (i = 0; i < e; i++) output += N(n[i]) ? n[i].call(r, t) : n[i];
                                return output
                            }
                        }(e), X[e](t)) : t.localeData().invalidDate()
                    }

                    function Q(t, e) {
                        var i = 5;

                        function n(input) {
                            return e.longDateFormat(input) || input
                        }
                        for (Y.lastIndex = 0; i >= 0 && Y.test(t);) t = t.replace(Y, n), Y.lastIndex = 0, i -= 1;
                        return t
                    }
                    var K = /\d/,
                        tt = /\d\d/,
                        et = /\d{3}/,
                        nt = /\d{4}/,
                        it = /[+-]?\d{6}/,
                        at = /\d\d?/,
                        ot = /\d\d\d\d?/,
                        st = /\d\d\d\d\d\d?/,
                        ut = /\d{1,3}/,
                        ct = /\d{1,4}/,
                        lt = /[+-]?\d{1,6}/,
                        ht = /\d+/,
                        pt = /[+-]?\d+/,
                        ft = /Z|[+-]\d\d:?\d\d/gi,
                        mt = /Z|[+-]\d\d(?::?\d\d)?/gi,
                        gt = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
                        vt = {};

                    function yt(t, e, n) {
                        vt[t] = N(e) ? e : function (t, r) {
                            return t && n ? n : e
                        }
                    }

                    function _t(t, e) {
                        return f(vt, t) ? vt[t](e._strict, e._locale) : new RegExp(xt(t.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, (function (t, e, n, r, o) {
                            return e || n || r || o
                        }))))
                    }

                    function xt(s) {
                        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
                    }
                    var bt = {};

                    function wt(t, e) {
                        var i, n = e;
                        for ("string" == typeof t && (t = [t]), h(e) && (n = function (input, t) {
                                t[e] = A(input)
                            }), i = 0; i < t.length; i++) bt[t[i]] = n
                    }

                    function Mt(t, e) {
                        wt(t, (function (input, t, n, r) {
                            n._w = n._w || {}, e(input, n._w, n, r)
                        }))
                    }

                    function Et(t, input, e) {
                        null != input && f(bt, t) && bt[t](input, e._a, e, t)
                    }
                    var Tt = 0,
                        Dt = 1,
                        St = 2,
                        At = 3,
                        Ct = 4,
                        Lt = 5,
                        Rt = 6,
                        Pt = 7,
                        Ot = 8;

                    function Ft(t) {
                        return Nt(t) ? 366 : 365
                    }

                    function Nt(t) {
                        return t % 4 == 0 && t % 100 != 0 || t % 400 == 0
                    }
                    J("Y", 0, 0, (function () {
                        var t = this.year();
                        return t <= 9999 ? "" + t : "+" + t
                    })), J(0, ["YY", 2], 0, (function () {
                        return this.year() % 100
                    })), J(0, ["YYYY", 4], 0, "year"), J(0, ["YYYYY", 5], 0, "year"), J(0, ["YYYYYY", 6, !0], 0, "year"), z("year", "y"), V("year", 1), yt("Y", pt), yt("YY", at, tt), yt("YYYY", ct, nt), yt("YYYYY", lt, it), yt("YYYYYY", lt, it), wt(["YYYYY", "YYYYYY"], Tt), wt("YYYY", (function (input, t) {
                        t[Tt] = 2 === input.length ? r.parseTwoDigitYear(input) : A(input)
                    })), wt("YY", (function (input, t) {
                        t[Tt] = r.parseTwoDigitYear(input)
                    })), wt("Y", (function (input, t) {
                        t[Tt] = parseInt(input, 10)
                    })), r.parseTwoDigitYear = function (input) {
                        return A(input) + (A(input) > 68 ? 1900 : 2e3)
                    };
                    var It, Bt = kt("FullYear", !0);

                    function kt(t, e) {
                        return function (n) {
                            return null != n ? (Ut(this, t, n), r.updateOffset(this, e), this) : zt(this, t)
                        }
                    }

                    function zt(t, e) {
                        return t.isValid() ? t._d["get" + (t._isUTC ? "UTC" : "") + e]() : NaN
                    }

                    function Ut(t, e, n) {
                        t.isValid() && !isNaN(n) && ("FullYear" === e && Nt(t.year()) && 1 === t.month() && 29 === t.date() ? t._d["set" + (t._isUTC ? "UTC" : "") + e](n, t.month(), Ht(n, t.month())) : t._d["set" + (t._isUTC ? "UTC" : "") + e](n))
                    }

                    function Ht(t, e) {
                        if (isNaN(t) || isNaN(e)) return NaN;
                        var n, r = (e % (n = 12) + n) % n;
                        return t += (e - r) / 12, 1 === r ? Nt(t) ? 29 : 28 : 31 - r % 7 % 2
                    }
                    It = Array.prototype.indexOf ? Array.prototype.indexOf : function (t) {
                        var i;
                        for (i = 0; i < this.length; ++i)
                            if (this[i] === t) return i;
                        return -1
                    }, J("M", ["MM", 2], "Mo", (function () {
                        return this.month() + 1
                    })), J("MMM", 0, 0, (function (t) {
                        return this.localeData().monthsShort(this, t)
                    })), J("MMMM", 0, 0, (function (t) {
                        return this.localeData().months(this, t)
                    })), z("month", "M"), V("month", 8), yt("M", at), yt("MM", at, tt), yt("MMM", (function (t, e) {
                        return e.monthsShortRegex(t)
                    })), yt("MMMM", (function (t, e) {
                        return e.monthsRegex(t)
                    })), wt(["M", "MM"], (function (input, t) {
                        t[Dt] = A(input) - 1
                    })), wt(["MMM", "MMMM"], (function (input, t, e, n) {
                        var r = e._locale.monthsParse(input, n, e._strict);
                        null != r ? t[Dt] = r : y(e).invalidMonth = input
                    }));
                    var Gt = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
                        Vt = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                        jt = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");

                    function Wt(t, e, n) {
                        var i, r, o, c = t.toLocaleLowerCase();
                        if (!this._monthsParse)
                            for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], i = 0; i < 12; ++i) o = v([2e3, i]), this._shortMonthsParse[i] = this.monthsShort(o, "").toLocaleLowerCase(), this._longMonthsParse[i] = this.months(o, "").toLocaleLowerCase();
                        return n ? "MMM" === e ? -1 !== (r = It.call(this._shortMonthsParse, c)) ? r : null : -1 !== (r = It.call(this._longMonthsParse, c)) ? r : null : "MMM" === e ? -1 !== (r = It.call(this._shortMonthsParse, c)) ? r : -1 !== (r = It.call(this._longMonthsParse, c)) ? r : null : -1 !== (r = It.call(this._longMonthsParse, c)) ? r : -1 !== (r = It.call(this._shortMonthsParse, c)) ? r : null
                    }

                    function Yt(t, e) {
                        var n;
                        if (!t.isValid()) return t;
                        if ("string" == typeof e)
                            if (/^\d+$/.test(e)) e = A(e);
                            else if (!h(e = t.localeData().monthsParse(e))) return t;
                        return n = Math.min(t.date(), Ht(t.year(), e)), t._d["set" + (t._isUTC ? "UTC" : "") + "Month"](e, n), t
                    }

                    function qt(t) {
                        return null != t ? (Yt(this, t), r.updateOffset(this, !0), this) : zt(this, "Month")
                    }
                    var Xt = gt,
                        Zt = gt;

                    function Jt() {
                        function t(a, b) {
                            return b.length - a.length
                        }
                        var i, e, n = [],
                            r = [],
                            o = [];
                        for (i = 0; i < 12; i++) e = v([2e3, i]), n.push(this.monthsShort(e, "")), r.push(this.months(e, "")), o.push(this.months(e, "")), o.push(this.monthsShort(e, ""));
                        for (n.sort(t), r.sort(t), o.sort(t), i = 0; i < 12; i++) n[i] = xt(n[i]), r[i] = xt(r[i]);
                        for (i = 0; i < 24; i++) o[i] = xt(o[i]);
                        this._monthsRegex = new RegExp("^(" + o.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + n.join("|") + ")", "i")
                    }

                    function $t(t, e, n, r, o, s, c) {
                        var l;
                        return t < 100 && t >= 0 ? (l = new Date(t + 400, e, n, r, o, s, c), isFinite(l.getFullYear()) && l.setFullYear(t)) : l = new Date(t, e, n, r, o, s, c), l
                    }

                    function Qt(t) {
                        var e;
                        if (t < 100 && t >= 0) {
                            var n = Array.prototype.slice.call(arguments);
                            n[0] = t + 400, e = new Date(Date.UTC.apply(null, n)), isFinite(e.getUTCFullYear()) && e.setUTCFullYear(t)
                        } else e = new Date(Date.UTC.apply(null, arguments));
                        return e
                    }

                    function Kt(t, e, n) {
                        var r = 7 + e - n;
                        return -(7 + Qt(t, 0, r).getUTCDay() - e) % 7 + r - 1
                    }

                    function te(t, e, n, r, o) {
                        var c, l, h = 1 + 7 * (e - 1) + (7 + n - r) % 7 + Kt(t, r, o);
                        return h <= 0 ? l = Ft(c = t - 1) + h : h > Ft(t) ? (c = t + 1, l = h - Ft(t)) : (c = t, l = h), {
                            year: c,
                            dayOfYear: l
                        }
                    }

                    function ee(t, e, n) {
                        var r, o, c = Kt(t.year(), e, n),
                            l = Math.floor((t.dayOfYear() - c - 1) / 7) + 1;
                        return l < 1 ? r = l + ne(o = t.year() - 1, e, n) : l > ne(t.year(), e, n) ? (r = l - ne(t.year(), e, n), o = t.year() + 1) : (o = t.year(), r = l), {
                            week: r,
                            year: o
                        }
                    }

                    function ne(t, e, n) {
                        var r = Kt(t, e, n),
                            o = Kt(t + 1, e, n);
                        return (Ft(t) - r + o) / 7
                    }

                    function ie(t, e) {
                        return t.slice(e, 7).concat(t.slice(0, e))
                    }
                    J("w", ["ww", 2], "wo", "week"), J("W", ["WW", 2], "Wo", "isoWeek"), z("week", "w"), z("isoWeek", "W"), V("week", 5), V("isoWeek", 5), yt("w", at), yt("ww", at, tt), yt("W", at), yt("WW", at, tt), Mt(["w", "ww", "W", "WW"], (function (input, t, e, n) {
                        t[n.substr(0, 1)] = A(input)
                    })), J("d", 0, "do", "day"), J("dd", 0, 0, (function (t) {
                        return this.localeData().weekdaysMin(this, t)
                    })), J("ddd", 0, 0, (function (t) {
                        return this.localeData().weekdaysShort(this, t)
                    })), J("dddd", 0, 0, (function (t) {
                        return this.localeData().weekdays(this, t)
                    })), J("e", 0, 0, "weekday"), J("E", 0, 0, "isoWeekday"), z("day", "d"), z("weekday", "e"), z("isoWeekday", "E"), V("day", 11), V("weekday", 11), V("isoWeekday", 11), yt("d", at), yt("e", at), yt("E", at), yt("dd", (function (t, e) {
                        return e.weekdaysMinRegex(t)
                    })), yt("ddd", (function (t, e) {
                        return e.weekdaysShortRegex(t)
                    })), yt("dddd", (function (t, e) {
                        return e.weekdaysRegex(t)
                    })), Mt(["dd", "ddd", "dddd"], (function (input, t, e, n) {
                        var r = e._locale.weekdaysParse(input, n, e._strict);
                        null != r ? t.d = r : y(e).invalidWeekday = input
                    })), Mt(["d", "e", "E"], (function (input, t, e, n) {
                        t[n] = A(input)
                    }));
                    var re = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                        ae = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
                        oe = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");

                    function se(t, e, n) {
                        var i, r, o, c = t.toLocaleLowerCase();
                        if (!this._weekdaysParse)
                            for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], i = 0; i < 7; ++i) o = v([2e3, 1]).day(i), this._minWeekdaysParse[i] = this.weekdaysMin(o, "").toLocaleLowerCase(), this._shortWeekdaysParse[i] = this.weekdaysShort(o, "").toLocaleLowerCase(), this._weekdaysParse[i] = this.weekdays(o, "").toLocaleLowerCase();
                        return n ? "dddd" === e ? -1 !== (r = It.call(this._weekdaysParse, c)) ? r : null : "ddd" === e ? -1 !== (r = It.call(this._shortWeekdaysParse, c)) ? r : null : -1 !== (r = It.call(this._minWeekdaysParse, c)) ? r : null : "dddd" === e ? -1 !== (r = It.call(this._weekdaysParse, c)) ? r : -1 !== (r = It.call(this._shortWeekdaysParse, c)) ? r : -1 !== (r = It.call(this._minWeekdaysParse, c)) ? r : null : "ddd" === e ? -1 !== (r = It.call(this._shortWeekdaysParse, c)) ? r : -1 !== (r = It.call(this._weekdaysParse, c)) ? r : -1 !== (r = It.call(this._minWeekdaysParse, c)) ? r : null : -1 !== (r = It.call(this._minWeekdaysParse, c)) ? r : -1 !== (r = It.call(this._weekdaysParse, c)) ? r : -1 !== (r = It.call(this._shortWeekdaysParse, c)) ? r : null
                    }
                    var ue = gt,
                        ce = gt,
                        le = gt;

                    function he() {
                        function t(a, b) {
                            return b.length - a.length
                        }
                        var i, e, n, r, o, c = [],
                            l = [],
                            h = [],
                            d = [];
                        for (i = 0; i < 7; i++) e = v([2e3, 1]).day(i), n = this.weekdaysMin(e, ""), r = this.weekdaysShort(e, ""), o = this.weekdays(e, ""), c.push(n), l.push(r), h.push(o), d.push(n), d.push(r), d.push(o);
                        for (c.sort(t), l.sort(t), h.sort(t), d.sort(t), i = 0; i < 7; i++) l[i] = xt(l[i]), h[i] = xt(h[i]), d[i] = xt(d[i]);
                        this._weekdaysRegex = new RegExp("^(" + d.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + h.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + l.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + c.join("|") + ")", "i")
                    }

                    function de() {
                        return this.hours() % 12 || 12
                    }

                    function pe(t, e) {
                        J(t, 0, 0, (function () {
                            return this.localeData().meridiem(this.hours(), this.minutes(), e)
                        }))
                    }

                    function fe(t, e) {
                        return e._meridiemParse
                    }
                    J("H", ["HH", 2], 0, "hour"), J("h", ["hh", 2], 0, de), J("k", ["kk", 2], 0, (function () {
                        return this.hours() || 24
                    })), J("hmm", 0, 0, (function () {
                        return "" + de.apply(this) + j(this.minutes(), 2)
                    })), J("hmmss", 0, 0, (function () {
                        return "" + de.apply(this) + j(this.minutes(), 2) + j(this.seconds(), 2)
                    })), J("Hmm", 0, 0, (function () {
                        return "" + this.hours() + j(this.minutes(), 2)
                    })), J("Hmmss", 0, 0, (function () {
                        return "" + this.hours() + j(this.minutes(), 2) + j(this.seconds(), 2)
                    })), pe("a", !0), pe("A", !1), z("hour", "h"), V("hour", 13), yt("a", fe), yt("A", fe), yt("H", at), yt("h", at), yt("k", at), yt("HH", at, tt), yt("hh", at, tt), yt("kk", at, tt), yt("hmm", ot), yt("hmmss", st), yt("Hmm", ot), yt("Hmmss", st), wt(["H", "HH"], At), wt(["k", "kk"], (function (input, t, e) {
                        var n = A(input);
                        t[At] = 24 === n ? 0 : n
                    })), wt(["a", "A"], (function (input, t, e) {
                        e._isPm = e._locale.isPM(input), e._meridiem = input
                    })), wt(["h", "hh"], (function (input, t, e) {
                        t[At] = A(input), y(e).bigHour = !0
                    })), wt("hmm", (function (input, t, e) {
                        var n = input.length - 2;
                        t[At] = A(input.substr(0, n)), t[Ct] = A(input.substr(n)), y(e).bigHour = !0
                    })), wt("hmmss", (function (input, t, e) {
                        var n = input.length - 4,
                            r = input.length - 2;
                        t[At] = A(input.substr(0, n)), t[Ct] = A(input.substr(n, 2)), t[Lt] = A(input.substr(r)), y(e).bigHour = !0
                    })), wt("Hmm", (function (input, t, e) {
                        var n = input.length - 2;
                        t[At] = A(input.substr(0, n)), t[Ct] = A(input.substr(n))
                    })), wt("Hmmss", (function (input, t, e) {
                        var n = input.length - 4,
                            r = input.length - 2;
                        t[At] = A(input.substr(0, n)), t[Ct] = A(input.substr(n, 2)), t[Lt] = A(input.substr(r))
                    }));
                    var me, ge = kt("Hours", !0),
                        ve = {
                            calendar: {
                                sameDay: "[Today at] LT",
                                nextDay: "[Tomorrow at] LT",
                                nextWeek: "dddd [at] LT",
                                lastDay: "[Yesterday at] LT",
                                lastWeek: "[Last] dddd [at] LT",
                                sameElse: "L"
                            },
                            longDateFormat: {
                                LTS: "h:mm:ss A",
                                LT: "h:mm A",
                                L: "MM/DD/YYYY",
                                LL: "MMMM D, YYYY",
                                LLL: "MMMM D, YYYY h:mm A",
                                LLLL: "dddd, MMMM D, YYYY h:mm A"
                            },
                            invalidDate: "Invalid date",
                            ordinal: "%d",
                            dayOfMonthOrdinalParse: /\d{1,2}/,
                            relativeTime: {
                                future: "in %s",
                                past: "%s ago",
                                s: "a few seconds",
                                ss: "%d seconds",
                                m: "a minute",
                                mm: "%d minutes",
                                h: "an hour",
                                hh: "%d hours",
                                d: "a day",
                                dd: "%d days",
                                M: "a month",
                                MM: "%d months",
                                y: "a year",
                                yy: "%d years"
                            },
                            months: Vt,
                            monthsShort: jt,
                            week: {
                                dow: 0,
                                doy: 6
                            },
                            weekdays: re,
                            weekdaysMin: oe,
                            weekdaysShort: ae,
                            meridiemParse: /[ap]\.?m?\.?/i
                        },
                        ye = {},
                        _e = {};

                    function xe(t) {
                        return t ? t.toLowerCase().replace("_", "-") : t
                    }

                    function be(e) {
                        var n = null;
                        if (!ye[e] && void 0 !== t && t && t.exports) try {
                            n = me._abbr, ! function () {
                                var t = new Error("Cannot find module 'undefined'");
                                throw t.code = "MODULE_NOT_FOUND", t
                            }(), we(n)
                        } catch (t) {}
                        return ye[e]
                    }

                    function we(t, e) {
                        var data;
                        return t && ((data = l(e) ? Ee(t) : Me(t, e)) ? me = data : "undefined" != typeof console && console.warn && console.warn("Locale " + t + " not found. Did you forget to load it?")), me._abbr
                    }

                    function Me(t, e) {
                        if (null !== e) {
                            var n, r = ve;
                            if (e.abbr = t, null != ye[t]) F("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), r = ye[t]._config;
                            else if (null != e.parentLocale)
                                if (null != ye[e.parentLocale]) r = ye[e.parentLocale]._config;
                                else {
                                    if (null == (n = be(e.parentLocale))) return _e[e.parentLocale] || (_e[e.parentLocale] = []), _e[e.parentLocale].push({
                                        name: t,
                                        config: e
                                    }), null;
                                    r = n._config
                                } return ye[t] = new B(I(r, e)), _e[t] && _e[t].forEach((function (t) {
                                Me(t.name, t.config)
                            })), we(t), ye[t]
                        }
                        return delete ye[t], null
                    }

                    function Ee(t) {
                        var e;
                        if (t && t._locale && t._locale._abbr && (t = t._locale._abbr), !t) return me;
                        if (!o(t)) {
                            if (e = be(t)) return e;
                            t = [t]
                        }
                        return function (t) {
                            for (var e, n, r, o, i = 0; i < t.length;) {
                                for (e = (o = xe(t[i]).split("-")).length, n = (n = xe(t[i + 1])) ? n.split("-") : null; e > 0;) {
                                    if (r = be(o.slice(0, e).join("-"))) return r;
                                    if (n && n.length >= e && C(o, n, !0) >= e - 1) break;
                                    e--
                                }
                                i++
                            }
                            return me
                        }(t)
                    }

                    function Te(t) {
                        var e, a = t._a;
                        return a && -2 === y(t).overflow && (e = a[Dt] < 0 || a[Dt] > 11 ? Dt : a[St] < 1 || a[St] > Ht(a[Tt], a[Dt]) ? St : a[At] < 0 || a[At] > 24 || 24 === a[At] && (0 !== a[Ct] || 0 !== a[Lt] || 0 !== a[Rt]) ? At : a[Ct] < 0 || a[Ct] > 59 ? Ct : a[Lt] < 0 || a[Lt] > 59 ? Lt : a[Rt] < 0 || a[Rt] > 999 ? Rt : -1, y(t)._overflowDayOfYear && (e < Tt || e > St) && (e = St), y(t)._overflowWeeks && -1 === e && (e = Pt), y(t)._overflowWeekday && -1 === e && (e = Ot), y(t).overflow = e), t
                    }

                    function De(a, b, t) {
                        return null != a ? a : null != b ? b : t
                    }

                    function Se(t) {
                        var i, e, n, o, c, input = [];
                        if (!t._d) {
                            for (n = function (t) {
                                    var e = new Date(r.now());
                                    return t._useUTC ? [e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate()] : [e.getFullYear(), e.getMonth(), e.getDate()]
                                }(t), t._w && null == t._a[St] && null == t._a[Dt] && function (t) {
                                    var e, n, r, o, c, l, h, d;
                                    if (null != (e = t._w).GG || null != e.W || null != e.E) c = 1, l = 4, n = De(e.GG, t._a[Tt], ee(Ge(), 1, 4).year), r = De(e.W, 1), ((o = De(e.E, 1)) < 1 || o > 7) && (d = !0);
                                    else {
                                        c = t._locale._week.dow, l = t._locale._week.doy;
                                        var f = ee(Ge(), c, l);
                                        n = De(e.gg, t._a[Tt], f.year), r = De(e.w, f.week), null != e.d ? ((o = e.d) < 0 || o > 6) && (d = !0) : null != e.e ? (o = e.e + c, (e.e < 0 || e.e > 6) && (d = !0)) : o = c
                                    }
                                    r < 1 || r > ne(n, c, l) ? y(t)._overflowWeeks = !0 : null != d ? y(t)._overflowWeekday = !0 : (h = te(n, r, o, c, l), t._a[Tt] = h.year, t._dayOfYear = h.dayOfYear)
                                }(t), null != t._dayOfYear && (c = De(t._a[Tt], n[Tt]), (t._dayOfYear > Ft(c) || 0 === t._dayOfYear) && (y(t)._overflowDayOfYear = !0), e = Qt(c, 0, t._dayOfYear), t._a[Dt] = e.getUTCMonth(), t._a[St] = e.getUTCDate()), i = 0; i < 3 && null == t._a[i]; ++i) t._a[i] = input[i] = n[i];
                            for (; i < 7; i++) t._a[i] = input[i] = null == t._a[i] ? 2 === i ? 1 : 0 : t._a[i];
                            24 === t._a[At] && 0 === t._a[Ct] && 0 === t._a[Lt] && 0 === t._a[Rt] && (t._nextDay = !0, t._a[At] = 0), t._d = (t._useUTC ? Qt : $t).apply(null, input), o = t._useUTC ? t._d.getUTCDay() : t._d.getDay(), null != t._tzm && t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm), t._nextDay && (t._a[At] = 24), t._w && void 0 !== t._w.d && t._w.d !== o && (y(t).weekdayMismatch = !0)
                        }
                    }
                    var Ae = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
                        Ce = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
                        Le = /Z|[+-]\d\d(?::?\d\d)?/,
                        Re = [
                            ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
                            ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
                            ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
                            ["GGGG-[W]WW", /\d{4}-W\d\d/, !1],
                            ["YYYY-DDD", /\d{4}-\d{3}/],
                            ["YYYY-MM", /\d{4}-\d\d/, !1],
                            ["YYYYYYMMDD", /[+-]\d{10}/],
                            ["YYYYMMDD", /\d{8}/],
                            ["GGGG[W]WWE", /\d{4}W\d{3}/],
                            ["GGGG[W]WW", /\d{4}W\d{2}/, !1],
                            ["YYYYDDD", /\d{7}/]
                        ],
                        Pe = [
                            ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
                            ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
                            ["HH:mm:ss", /\d\d:\d\d:\d\d/],
                            ["HH:mm", /\d\d:\d\d/],
                            ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
                            ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
                            ["HHmmss", /\d\d\d\d\d\d/],
                            ["HHmm", /\d\d\d\d/],
                            ["HH", /\d\d/]
                        ],
                        Oe = /^\/?Date\((\-?\d+)/i;

                    function Fe(t) {
                        var i, e, n, r, o, c, l = t._i,
                            h = Ae.exec(l) || Ce.exec(l);
                        if (h) {
                            for (y(t).iso = !0, i = 0, e = Re.length; i < e; i++)
                                if (Re[i][1].exec(h[1])) {
                                    r = Re[i][0], n = !1 !== Re[i][2];
                                    break
                                } if (null == r) return void(t._isValid = !1);
                            if (h[3]) {
                                for (i = 0, e = Pe.length; i < e; i++)
                                    if (Pe[i][1].exec(h[3])) {
                                        o = (h[2] || " ") + Pe[i][0];
                                        break
                                    } if (null == o) return void(t._isValid = !1)
                            }
                            if (!n && null != o) return void(t._isValid = !1);
                            if (h[4]) {
                                if (!Le.exec(h[4])) return void(t._isValid = !1);
                                c = "Z"
                            }
                            t._f = r + (o || "") + (c || ""), ze(t)
                        } else t._isValid = !1
                    }
                    var Ne = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

                    function Ie(t) {
                        var e = parseInt(t, 10);
                        return e <= 49 ? 2e3 + e : e <= 999 ? 1900 + e : e
                    }
                    var Be = {
                        UT: 0,
                        GMT: 0,
                        EDT: -240,
                        EST: -300,
                        CDT: -300,
                        CST: -360,
                        MDT: -360,
                        MST: -420,
                        PDT: -420,
                        PST: -480
                    };

                    function ke(t) {
                        var e, n, r, o, c, l, h, d = Ne.exec(t._i.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, ""));
                        if (d) {
                            var f = (e = d[4], n = d[3], r = d[2], o = d[5], c = d[6], l = d[7], h = [Ie(e), jt.indexOf(n), parseInt(r, 10), parseInt(o, 10), parseInt(c, 10)], l && h.push(parseInt(l, 10)), h);
                            if (! function (t, e, n) {
                                    return !t || ae.indexOf(t) === new Date(e[0], e[1], e[2]).getDay() || (y(n).weekdayMismatch = !0, n._isValid = !1, !1)
                                }(d[1], f, t)) return;
                            t._a = f, t._tzm = function (t, e, n) {
                                if (t) return Be[t];
                                if (e) return 0;
                                var r = parseInt(n, 10),
                                    o = r % 100;
                                return (r - o) / 100 * 60 + o
                            }(d[8], d[9], d[10]), t._d = Qt.apply(null, t._a), t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm), y(t).rfc2822 = !0
                        } else t._isValid = !1
                    }

                    function ze(t) {
                        if (t._f !== r.ISO_8601)
                            if (t._f !== r.RFC_2822) {
                                t._a = [], y(t).empty = !0;
                                var i, e, n, o, c, l = "" + t._i,
                                    h = l.length,
                                    d = 0;
                                for (n = Q(t._f, t._locale).match(W) || [], i = 0; i < n.length; i++) o = n[i], (e = (l.match(_t(o, t)) || [])[0]) && ((c = l.substr(0, l.indexOf(e))).length > 0 && y(t).unusedInput.push(c), l = l.slice(l.indexOf(e) + e.length), d += e.length), Z[o] ? (e ? y(t).empty = !1 : y(t).unusedTokens.push(o), Et(o, e, t)) : t._strict && !e && y(t).unusedTokens.push(o);
                                y(t).charsLeftOver = h - d, l.length > 0 && y(t).unusedInput.push(l), t._a[At] <= 12 && !0 === y(t).bigHour && t._a[At] > 0 && (y(t).bigHour = void 0), y(t).parsedDateParts = t._a.slice(0), y(t).meridiem = t._meridiem, t._a[At] = function (t, e, n) {
                                    var r;
                                    return null == n ? e : null != t.meridiemHour ? t.meridiemHour(e, n) : null != t.isPM ? ((r = t.isPM(n)) && e < 12 && (e += 12), r || 12 !== e || (e = 0), e) : e
                                }(t._locale, t._a[At], t._meridiem), Se(t), Te(t)
                            } else ke(t);
                        else Fe(t)
                    }

                    function Ue(t) {
                        var input = t._i,
                            e = t._f;
                        return t._locale = t._locale || Ee(t._l), null === input || void 0 === e && "" === input ? x({
                            nullInput: !0
                        }) : ("string" == typeof input && (t._i = input = t._locale.preparse(input)), D(input) ? new T(Te(input)) : (d(input) ? t._d = input : o(e) ? function (t) {
                            var e, n, r, i, o;
                            if (0 === t._f.length) return y(t).invalidFormat = !0, void(t._d = new Date(NaN));
                            for (i = 0; i < t._f.length; i++) o = 0, e = M({}, t), null != t._useUTC && (e._useUTC = t._useUTC), e._f = t._f[i], ze(e), _(e) && (o += y(e).charsLeftOver, o += 10 * y(e).unusedTokens.length, y(e).score = o, (null == r || o < r) && (r = o, n = e));
                            m(t, n || e)
                        }(t) : e ? ze(t) : function (t) {
                            var input = t._i;
                            l(input) ? t._d = new Date(r.now()) : d(input) ? t._d = new Date(input.valueOf()) : "string" == typeof input ? function (t) {
                                var e = Oe.exec(t._i);
                                null === e ? (Fe(t), !1 === t._isValid && (delete t._isValid, ke(t), !1 === t._isValid && (delete t._isValid, r.createFromInputFallback(t)))) : t._d = new Date(+e[1])
                            }(t) : o(input) ? (t._a = map(input.slice(0), (function (t) {
                                return parseInt(t, 10)
                            })), Se(t)) : c(input) ? function (t) {
                                if (!t._d) {
                                    var i = H(t._i);
                                    t._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], (function (t) {
                                        return t && parseInt(t, 10)
                                    })), Se(t)
                                }
                            }(t) : h(input) ? t._d = new Date(input) : r.createFromInputFallback(t)
                        }(t), _(t) || (t._d = null), t))
                    }

                    function He(input, t, e, n, r) {
                        var l, h = {};
                        return !0 !== e && !1 !== e || (n = e, e = void 0), (c(input) && function (t) {
                            if (Object.getOwnPropertyNames) return 0 === Object.getOwnPropertyNames(t).length;
                            var e;
                            for (e in t)
                                if (t.hasOwnProperty(e)) return !1;
                            return !0
                        }(input) || o(input) && 0 === input.length) && (input = void 0), h._isAMomentObject = !0, h._useUTC = h._isUTC = r, h._l = e, h._i = input, h._f = t, h._strict = n, (l = new T(Te(Ue(h))))._nextDay && (l.add(1, "d"), l._nextDay = void 0), l
                    }

                    function Ge(input, t, e, n) {
                        return He(input, t, e, n, !1)
                    }
                    r.createFromInputFallback = R("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", (function (t) {
                        t._d = new Date(t._i + (t._useUTC ? " UTC" : ""))
                    })), r.ISO_8601 = function () {}, r.RFC_2822 = function () {};
                    var Ve = R("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", (function () {
                            var t = Ge.apply(null, arguments);
                            return this.isValid() && t.isValid() ? t < this ? this : t : x()
                        })),
                        je = R("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", (function () {
                            var t = Ge.apply(null, arguments);
                            return this.isValid() && t.isValid() ? t > this ? this : t : x()
                        }));

                    function We(t, e) {
                        var n, i;
                        if (1 === e.length && o(e[0]) && (e = e[0]), !e.length) return Ge();
                        for (n = e[0], i = 1; i < e.length; ++i) e[i].isValid() && !e[i][t](n) || (n = e[i]);
                        return n
                    }
                    var Ye = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];

                    function qe(t) {
                        var e = H(t),
                            n = e.year || 0,
                            r = e.quarter || 0,
                            o = e.month || 0,
                            c = e.week || e.isoWeek || 0,
                            l = e.day || 0,
                            h = e.hour || 0,
                            d = e.minute || 0,
                            f = e.second || 0,
                            m = e.millisecond || 0;
                        this._isValid = function (t) {
                            for (var e in t)
                                if (-1 === It.call(Ye, e) || null != t[e] && isNaN(t[e])) return !1;
                            for (var n = !1, i = 0; i < Ye.length; ++i)
                                if (t[Ye[i]]) {
                                    if (n) return !1;
                                    parseFloat(t[Ye[i]]) !== A(t[Ye[i]]) && (n = !0)
                                } return !0
                        }(e), this._milliseconds = +m + 1e3 * f + 6e4 * d + 1e3 * h * 60 * 60, this._days = +l + 7 * c, this._months = +o + 3 * r + 12 * n, this._data = {}, this._locale = Ee(), this._bubble()
                    }

                    function Xe(t) {
                        return t instanceof qe
                    }

                    function Ze(t) {
                        return t < 0 ? -1 * Math.round(-1 * t) : Math.round(t)
                    }

                    function Je(t, e) {
                        J(t, 0, 0, (function () {
                            var t = this.utcOffset(),
                                n = "+";
                            return t < 0 && (t = -t, n = "-"), n + j(~~(t / 60), 2) + e + j(~~t % 60, 2)
                        }))
                    }
                    Je("Z", ":"), Je("ZZ", ""), yt("Z", mt), yt("ZZ", mt), wt(["Z", "ZZ"], (function (input, t, e) {
                        e._useUTC = !0, e._tzm = Qe(mt, input)
                    }));
                    var $e = /([\+\-]|\d\d)/gi;

                    function Qe(t, e) {
                        var n = (e || "").match(t);
                        if (null === n) return null;
                        var r = ((n[n.length - 1] || []) + "").match($e) || ["-", 0, 0],
                            o = 60 * r[1] + A(r[2]);
                        return 0 === o ? 0 : "+" === r[0] ? o : -o
                    }

                    function Ke(input, t) {
                        var e, n;
                        return t._isUTC ? (e = t.clone(), n = (D(input) || d(input) ? input.valueOf() : Ge(input).valueOf()) - e.valueOf(), e._d.setTime(e._d.valueOf() + n), r.updateOffset(e, !1), e) : Ge(input).local()
                    }

                    function tn(t) {
                        return 15 * -Math.round(t._d.getTimezoneOffset() / 15)
                    }

                    function en() {
                        return !!this.isValid() && this._isUTC && 0 === this._offset
                    }
                    r.updateOffset = function () {};
                    var nn = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,
                        rn = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

                    function an(input, t) {
                        var e, n, r, base, o, c, l = input,
                            d = null;
                        return Xe(input) ? l = {
                            ms: input._milliseconds,
                            d: input._days,
                            M: input._months
                        } : h(input) ? (l = {}, t ? l[t] = input : l.milliseconds = input) : (d = nn.exec(input)) ? (e = "-" === d[1] ? -1 : 1, l = {
                            y: 0,
                            d: A(d[St]) * e,
                            h: A(d[At]) * e,
                            m: A(d[Ct]) * e,
                            s: A(d[Lt]) * e,
                            ms: A(Ze(1e3 * d[Rt])) * e
                        }) : (d = rn.exec(input)) ? (e = "-" === d[1] ? -1 : 1, l = {
                            y: on(d[2], e),
                            M: on(d[3], e),
                            w: on(d[4], e),
                            d: on(d[5], e),
                            h: on(d[6], e),
                            m: on(d[7], e),
                            s: on(d[8], e)
                        }) : null == l ? l = {} : "object" == typeof l && ("from" in l || "to" in l) && (base = Ge(l.from), o = Ge(l.to), r = base.isValid() && o.isValid() ? (o = Ke(o, base), base.isBefore(o) ? c = sn(base, o) : ((c = sn(o, base)).milliseconds = -c.milliseconds, c.months = -c.months), c) : {
                            milliseconds: 0,
                            months: 0
                        }, (l = {}).ms = r.milliseconds, l.M = r.months), n = new qe(l), Xe(input) && f(input, "_locale") && (n._locale = input._locale), n
                    }

                    function on(t, e) {
                        var n = t && parseFloat(t.replace(",", "."));
                        return (isNaN(n) ? 0 : n) * e
                    }

                    function sn(base, t) {
                        var e = {};
                        return e.months = t.month() - base.month() + 12 * (t.year() - base.year()), base.clone().add(e.months, "M").isAfter(t) && --e.months, e.milliseconds = +t - +base.clone().add(e.months, "M"), e
                    }

                    function un(t, e) {
                        return function (n, r) {
                            var o;
                            return null === r || isNaN(+r) || (F(e, "moment()." + e + "(period, number) is deprecated. Please use moment()." + e + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), o = n, n = r, r = o), cn(this, an(n = "string" == typeof n ? +n : n, r), t), this
                        }
                    }

                    function cn(t, e, n, o) {
                        var c = e._milliseconds,
                            l = Ze(e._days),
                            h = Ze(e._months);
                        t.isValid() && (o = null == o || o, h && Yt(t, zt(t, "Month") + h * n), l && Ut(t, "Date", zt(t, "Date") + l * n), c && t._d.setTime(t._d.valueOf() + c * n), o && r.updateOffset(t, l || h))
                    }
                    an.fn = qe.prototype, an.invalid = function () {
                        return an(NaN)
                    };
                    var ln = un(1, "add"),
                        hn = un(-1, "subtract");

                    function dn(a, b) {
                        var t = 12 * (b.year() - a.year()) + (b.month() - a.month()),
                            e = a.clone().add(t, "months");
                        return -(t + (b - e < 0 ? (b - e) / (e - a.clone().add(t - 1, "months")) : (b - e) / (a.clone().add(t + 1, "months") - e))) || 0
                    }

                    function pn(t) {
                        var e;
                        return void 0 === t ? this._locale._abbr : (null != (e = Ee(t)) && (this._locale = e), this)
                    }
                    r.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", r.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
                    var fn = R("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", (function (t) {
                        return void 0 === t ? this.localeData() : this.locale(t)
                    }));

                    function mn() {
                        return this._locale
                    }
                    var gn = 1e3,
                        vn = 60 * gn,
                        yn = 60 * vn,
                        _n = 3506328 * yn;

                    function xn(t, e) {
                        return (t % e + e) % e
                    }

                    function bn(t, e, n) {
                        return t < 100 && t >= 0 ? new Date(t + 400, e, n) - _n : new Date(t, e, n).valueOf()
                    }

                    function wn(t, e, n) {
                        return t < 100 && t >= 0 ? Date.UTC(t + 400, e, n) - _n : Date.UTC(t, e, n)
                    }

                    function Mn(t, e) {
                        J(0, [t, t.length], 0, e)
                    }

                    function En(input, t, e, n, r) {
                        var o;
                        return null == input ? ee(this, n, r).year : (t > (o = ne(input, n, r)) && (t = o), Tn.call(this, input, t, e, n, r))
                    }

                    function Tn(t, e, n, r, o) {
                        var c = te(t, e, n, r, o),
                            l = Qt(c.year, 0, c.dayOfYear);
                        return this.year(l.getUTCFullYear()), this.month(l.getUTCMonth()), this.date(l.getUTCDate()), this
                    }
                    J(0, ["gg", 2], 0, (function () {
                        return this.weekYear() % 100
                    })), J(0, ["GG", 2], 0, (function () {
                        return this.isoWeekYear() % 100
                    })), Mn("gggg", "weekYear"), Mn("ggggg", "weekYear"), Mn("GGGG", "isoWeekYear"), Mn("GGGGG", "isoWeekYear"), z("weekYear", "gg"), z("isoWeekYear", "GG"), V("weekYear", 1), V("isoWeekYear", 1), yt("G", pt), yt("g", pt), yt("GG", at, tt), yt("gg", at, tt), yt("GGGG", ct, nt), yt("gggg", ct, nt), yt("GGGGG", lt, it), yt("ggggg", lt, it), Mt(["gggg", "ggggg", "GGGG", "GGGGG"], (function (input, t, e, n) {
                        t[n.substr(0, 2)] = A(input)
                    })), Mt(["gg", "GG"], (function (input, t, e, n) {
                        t[n] = r.parseTwoDigitYear(input)
                    })), J("Q", 0, "Qo", "quarter"), z("quarter", "Q"), V("quarter", 7), yt("Q", K), wt("Q", (function (input, t) {
                        t[Dt] = 3 * (A(input) - 1)
                    })), J("D", ["DD", 2], "Do", "date"), z("date", "D"), V("date", 9), yt("D", at), yt("DD", at, tt), yt("Do", (function (t, e) {
                        return t ? e._dayOfMonthOrdinalParse || e._ordinalParse : e._dayOfMonthOrdinalParseLenient
                    })), wt(["D", "DD"], St), wt("Do", (function (input, t) {
                        t[St] = A(input.match(at)[0])
                    }));
                    var Dn = kt("Date", !0);
                    J("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), z("dayOfYear", "DDD"), V("dayOfYear", 4), yt("DDD", ut), yt("DDDD", et), wt(["DDD", "DDDD"], (function (input, t, e) {
                        e._dayOfYear = A(input)
                    })), J("m", ["mm", 2], 0, "minute"), z("minute", "m"), V("minute", 14), yt("m", at), yt("mm", at, tt), wt(["m", "mm"], Ct);
                    var Sn = kt("Minutes", !1);
                    J("s", ["ss", 2], 0, "second"), z("second", "s"), V("second", 15), yt("s", at), yt("ss", at, tt), wt(["s", "ss"], Lt);
                    var An, Cn = kt("Seconds", !1);
                    for (J("S", 0, 0, (function () {
                            return ~~(this.millisecond() / 100)
                        })), J(0, ["SS", 2], 0, (function () {
                            return ~~(this.millisecond() / 10)
                        })), J(0, ["SSS", 3], 0, "millisecond"), J(0, ["SSSS", 4], 0, (function () {
                            return 10 * this.millisecond()
                        })), J(0, ["SSSSS", 5], 0, (function () {
                            return 100 * this.millisecond()
                        })), J(0, ["SSSSSS", 6], 0, (function () {
                            return 1e3 * this.millisecond()
                        })), J(0, ["SSSSSSS", 7], 0, (function () {
                            return 1e4 * this.millisecond()
                        })), J(0, ["SSSSSSSS", 8], 0, (function () {
                            return 1e5 * this.millisecond()
                        })), J(0, ["SSSSSSSSS", 9], 0, (function () {
                            return 1e6 * this.millisecond()
                        })), z("millisecond", "ms"), V("millisecond", 16), yt("S", ut, K), yt("SS", ut, tt), yt("SSS", ut, et), An = "SSSS"; An.length <= 9; An += "S") yt(An, ht);

                    function Ln(input, t) {
                        t[Rt] = A(1e3 * ("0." + input))
                    }
                    for (An = "S"; An.length <= 9; An += "S") wt(An, Ln);
                    var Rn = kt("Milliseconds", !1);
                    J("z", 0, 0, "zoneAbbr"), J("zz", 0, 0, "zoneName");
                    var Pn = T.prototype;

                    function On(t) {
                        return t
                    }
                    Pn.add = ln, Pn.calendar = function (time, t) {
                        var e = time || Ge(),
                            n = Ke(e, this).startOf("day"),
                            o = r.calendarFormat(this, n) || "sameElse",
                            output = t && (N(t[o]) ? t[o].call(this, e) : t[o]);
                        return this.format(output || this.localeData().calendar(o, this, Ge(e)))
                    }, Pn.clone = function () {
                        return new T(this)
                    }, Pn.diff = function (input, t, e) {
                        var n, r, output;
                        if (!this.isValid()) return NaN;
                        if (!(n = Ke(input, this)).isValid()) return NaN;
                        switch (r = 6e4 * (n.utcOffset() - this.utcOffset()), t = U(t)) {
                            case "year":
                                output = dn(this, n) / 12;
                                break;
                            case "month":
                                output = dn(this, n);
                                break;
                            case "quarter":
                                output = dn(this, n) / 3;
                                break;
                            case "second":
                                output = (this - n) / 1e3;
                                break;
                            case "minute":
                                output = (this - n) / 6e4;
                                break;
                            case "hour":
                                output = (this - n) / 36e5;
                                break;
                            case "day":
                                output = (this - n - r) / 864e5;
                                break;
                            case "week":
                                output = (this - n - r) / 6048e5;
                                break;
                            default:
                                output = this - n
                        }
                        return e ? output : S(output)
                    }, Pn.endOf = function (t) {
                        var time;
                        if (void 0 === (t = U(t)) || "millisecond" === t || !this.isValid()) return this;
                        var e = this._isUTC ? wn : bn;
                        switch (t) {
                            case "year":
                                time = e(this.year() + 1, 0, 1) - 1;
                                break;
                            case "quarter":
                                time = e(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
                                break;
                            case "month":
                                time = e(this.year(), this.month() + 1, 1) - 1;
                                break;
                            case "week":
                                time = e(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                                break;
                            case "isoWeek":
                                time = e(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                                break;
                            case "day":
                            case "date":
                                time = e(this.year(), this.month(), this.date() + 1) - 1;
                                break;
                            case "hour":
                                time = this._d.valueOf(), time += yn - xn(time + (this._isUTC ? 0 : this.utcOffset() * vn), yn) - 1;
                                break;
                            case "minute":
                                time = this._d.valueOf(), time += vn - xn(time, vn) - 1;
                                break;
                            case "second":
                                time = this._d.valueOf(), time += gn - xn(time, gn) - 1
                        }
                        return this._d.setTime(time), r.updateOffset(this, !0), this
                    }, Pn.format = function (t) {
                        t || (t = this.isUtc() ? r.defaultFormatUtc : r.defaultFormat);
                        var output = $(this, t);
                        return this.localeData().postformat(output)
                    }, Pn.from = function (time, t) {
                        return this.isValid() && (D(time) && time.isValid() || Ge(time).isValid()) ? an({
                            to: this,
                            from: time
                        }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate()
                    }, Pn.fromNow = function (t) {
                        return this.from(Ge(), t)
                    }, Pn.to = function (time, t) {
                        return this.isValid() && (D(time) && time.isValid() || Ge(time).isValid()) ? an({
                            from: this,
                            to: time
                        }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate()
                    }, Pn.toNow = function (t) {
                        return this.to(Ge(), t)
                    }, Pn.get = function (t) {
                        return N(this[t = U(t)]) ? this[t]() : this
                    }, Pn.invalidAt = function () {
                        return y(this).overflow
                    }, Pn.isAfter = function (input, t) {
                        var e = D(input) ? input : Ge(input);
                        return !(!this.isValid() || !e.isValid()) && ("millisecond" === (t = U(t) || "millisecond") ? this.valueOf() > e.valueOf() : e.valueOf() < this.clone().startOf(t).valueOf())
                    }, Pn.isBefore = function (input, t) {
                        var e = D(input) ? input : Ge(input);
                        return !(!this.isValid() || !e.isValid()) && ("millisecond" === (t = U(t) || "millisecond") ? this.valueOf() < e.valueOf() : this.clone().endOf(t).valueOf() < e.valueOf())
                    }, Pn.isBetween = function (t, e, n, r) {
                        var o = D(t) ? t : Ge(t),
                            c = D(e) ? e : Ge(e);
                        return !!(this.isValid() && o.isValid() && c.isValid()) && ("(" === (r = r || "()")[0] ? this.isAfter(o, n) : !this.isBefore(o, n)) && (")" === r[1] ? this.isBefore(c, n) : !this.isAfter(c, n))
                    }, Pn.isSame = function (input, t) {
                        var e, n = D(input) ? input : Ge(input);
                        return !(!this.isValid() || !n.isValid()) && ("millisecond" === (t = U(t) || "millisecond") ? this.valueOf() === n.valueOf() : (e = n.valueOf(), this.clone().startOf(t).valueOf() <= e && e <= this.clone().endOf(t).valueOf()))
                    }, Pn.isSameOrAfter = function (input, t) {
                        return this.isSame(input, t) || this.isAfter(input, t)
                    }, Pn.isSameOrBefore = function (input, t) {
                        return this.isSame(input, t) || this.isBefore(input, t)
                    }, Pn.isValid = function () {
                        return _(this)
                    }, Pn.lang = fn, Pn.locale = pn, Pn.localeData = mn, Pn.max = je, Pn.min = Ve, Pn.parsingFlags = function () {
                        return m({}, y(this))
                    }, Pn.set = function (t, e) {
                        if ("object" == typeof t)
                            for (var n = function (t) {
                                    var e = [];
                                    for (var u in t) e.push({
                                        unit: u,
                                        priority: G[u]
                                    });
                                    return e.sort((function (a, b) {
                                        return a.priority - b.priority
                                    })), e
                                }(t = H(t)), i = 0; i < n.length; i++) this[n[i].unit](t[n[i].unit]);
                        else if (N(this[t = U(t)])) return this[t](e);
                        return this
                    }, Pn.startOf = function (t) {
                        var time;
                        if (void 0 === (t = U(t)) || "millisecond" === t || !this.isValid()) return this;
                        var e = this._isUTC ? wn : bn;
                        switch (t) {
                            case "year":
                                time = e(this.year(), 0, 1);
                                break;
                            case "quarter":
                                time = e(this.year(), this.month() - this.month() % 3, 1);
                                break;
                            case "month":
                                time = e(this.year(), this.month(), 1);
                                break;
                            case "week":
                                time = e(this.year(), this.month(), this.date() - this.weekday());
                                break;
                            case "isoWeek":
                                time = e(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                                break;
                            case "day":
                            case "date":
                                time = e(this.year(), this.month(), this.date());
                                break;
                            case "hour":
                                time = this._d.valueOf(), time -= xn(time + (this._isUTC ? 0 : this.utcOffset() * vn), yn);
                                break;
                            case "minute":
                                time = this._d.valueOf(), time -= xn(time, vn);
                                break;
                            case "second":
                                time = this._d.valueOf(), time -= xn(time, gn)
                        }
                        return this._d.setTime(time), r.updateOffset(this, !0), this
                    }, Pn.subtract = hn, Pn.toArray = function () {
                        var t = this;
                        return [t.year(), t.month(), t.date(), t.hour(), t.minute(), t.second(), t.millisecond()]
                    }, Pn.toObject = function () {
                        var t = this;
                        return {
                            years: t.year(),
                            months: t.month(),
                            date: t.date(),
                            hours: t.hours(),
                            minutes: t.minutes(),
                            seconds: t.seconds(),
                            milliseconds: t.milliseconds()
                        }
                    }, Pn.toDate = function () {
                        return new Date(this.valueOf())
                    }, Pn.toISOString = function (t) {
                        if (!this.isValid()) return null;
                        var e = !0 !== t,
                            n = e ? this.clone().utc() : this;
                        return n.year() < 0 || n.year() > 9999 ? $(n, e ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : N(Date.prototype.toISOString) ? e ? this.toDate().toISOString() : new Date(this.valueOf() + 60 * this.utcOffset() * 1e3).toISOString().replace("Z", $(n, "Z")) : $(n, e ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ")
                    }, Pn.inspect = function () {
                        if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)";
                        var t = "moment",
                            e = "";
                        this.isLocal() || (t = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", e = "Z");
                        var n = "[" + t + '("]',
                            r = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY",
                            o = e + '[")]';
                        return this.format(n + r + "-MM-DD[T]HH:mm:ss.SSS" + o)
                    }, Pn.toJSON = function () {
                        return this.isValid() ? this.toISOString() : null
                    }, Pn.toString = function () {
                        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")
                    }, Pn.unix = function () {
                        return Math.floor(this.valueOf() / 1e3)
                    }, Pn.valueOf = function () {
                        return this._d.valueOf() - 6e4 * (this._offset || 0)
                    }, Pn.creationData = function () {
                        return {
                            input: this._i,
                            format: this._f,
                            locale: this._locale,
                            isUTC: this._isUTC,
                            strict: this._strict
                        }
                    }, Pn.year = Bt, Pn.isLeapYear = function () {
                        return Nt(this.year())
                    }, Pn.weekYear = function (input) {
                        return En.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy)
                    }, Pn.isoWeekYear = function (input) {
                        return En.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4)
                    }, Pn.quarter = Pn.quarters = function (input) {
                        return null == input ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (input - 1) + this.month() % 3)
                    }, Pn.month = qt, Pn.daysInMonth = function () {
                        return Ht(this.year(), this.month())
                    }, Pn.week = Pn.weeks = function (input) {
                        var t = this.localeData().week(this);
                        return null == input ? t : this.add(7 * (input - t), "d")
                    }, Pn.isoWeek = Pn.isoWeeks = function (input) {
                        var t = ee(this, 1, 4).week;
                        return null == input ? t : this.add(7 * (input - t), "d")
                    }, Pn.weeksInYear = function () {
                        var t = this.localeData()._week;
                        return ne(this.year(), t.dow, t.doy)
                    }, Pn.isoWeeksInYear = function () {
                        return ne(this.year(), 1, 4)
                    }, Pn.date = Dn, Pn.day = Pn.days = function (input) {
                        if (!this.isValid()) return null != input ? this : NaN;
                        var t = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
                        return null != input ? (input = function (input, t) {
                            return "string" != typeof input ? input : isNaN(input) ? "number" == typeof (input = t.weekdaysParse(input)) ? input : null : parseInt(input, 10)
                        }(input, this.localeData()), this.add(input - t, "d")) : t
                    }, Pn.weekday = function (input) {
                        if (!this.isValid()) return null != input ? this : NaN;
                        var t = (this.day() + 7 - this.localeData()._week.dow) % 7;
                        return null == input ? t : this.add(input - t, "d")
                    }, Pn.isoWeekday = function (input) {
                        if (!this.isValid()) return null != input ? this : NaN;
                        if (null != input) {
                            var t = function (input, t) {
                                return "string" == typeof input ? t.weekdaysParse(input) % 7 || 7 : isNaN(input) ? null : input
                            }(input, this.localeData());
                            return this.day(this.day() % 7 ? t : t - 7)
                        }
                        return this.day() || 7
                    }, Pn.dayOfYear = function (input) {
                        var t = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
                        return null == input ? t : this.add(input - t, "d")
                    }, Pn.hour = Pn.hours = ge, Pn.minute = Pn.minutes = Sn, Pn.second = Pn.seconds = Cn, Pn.millisecond = Pn.milliseconds = Rn, Pn.utcOffset = function (input, t, e) {
                        var n, o = this._offset || 0;
                        if (!this.isValid()) return null != input ? this : NaN;
                        if (null != input) {
                            if ("string" == typeof input) {
                                if (null === (input = Qe(mt, input))) return this
                            } else Math.abs(input) < 16 && !e && (input *= 60);
                            return !this._isUTC && t && (n = tn(this)), this._offset = input, this._isUTC = !0, null != n && this.add(n, "m"), o !== input && (!t || this._changeInProgress ? cn(this, an(input - o, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, r.updateOffset(this, !0), this._changeInProgress = null)), this
                        }
                        return this._isUTC ? o : tn(this)
                    }, Pn.utc = function (t) {
                        return this.utcOffset(0, t)
                    }, Pn.local = function (t) {
                        return this._isUTC && (this.utcOffset(0, t), this._isUTC = !1, t && this.subtract(tn(this), "m")), this
                    }, Pn.parseZone = function () {
                        if (null != this._tzm) this.utcOffset(this._tzm, !1, !0);
                        else if ("string" == typeof this._i) {
                            var t = Qe(ft, this._i);
                            null != t ? this.utcOffset(t) : this.utcOffset(0, !0)
                        }
                        return this
                    }, Pn.hasAlignedHourOffset = function (input) {
                        return !!this.isValid() && (input = input ? Ge(input).utcOffset() : 0, (this.utcOffset() - input) % 60 == 0)
                    }, Pn.isDST = function () {
                        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset()
                    }, Pn.isLocal = function () {
                        return !!this.isValid() && !this._isUTC
                    }, Pn.isUtcOffset = function () {
                        return !!this.isValid() && this._isUTC
                    }, Pn.isUtc = en, Pn.isUTC = en, Pn.zoneAbbr = function () {
                        return this._isUTC ? "UTC" : ""
                    }, Pn.zoneName = function () {
                        return this._isUTC ? "Coordinated Universal Time" : ""
                    }, Pn.dates = R("dates accessor is deprecated. Use date instead.", Dn), Pn.months = R("months accessor is deprecated. Use month instead", qt), Pn.years = R("years accessor is deprecated. Use year instead", Bt), Pn.zone = R("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", (function (input, t) {
                        return null != input ? ("string" != typeof input && (input = -input), this.utcOffset(input, t), this) : -this.utcOffset()
                    })), Pn.isDSTShifted = R("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", (function () {
                        if (!l(this._isDSTShifted)) return this._isDSTShifted;
                        var t = {};
                        if (M(t, this), (t = Ue(t))._a) {
                            var e = t._isUTC ? v(t._a) : Ge(t._a);
                            this._isDSTShifted = this.isValid() && C(t._a, e.toArray()) > 0
                        } else this._isDSTShifted = !1;
                        return this._isDSTShifted
                    }));
                    var Fn = B.prototype;

                    function Nn(t, e, n, r) {
                        var o = Ee(),
                            c = v().set(r, e);
                        return o[n](c, t)
                    }

                    function In(t, e, n) {
                        if (h(t) && (e = t, t = void 0), t = t || "", null != e) return Nn(t, e, n, "month");
                        var i, r = [];
                        for (i = 0; i < 12; i++) r[i] = Nn(t, i, n, "month");
                        return r
                    }

                    function Bn(t, e, n, r) {
                        "boolean" == typeof t ? (h(e) && (n = e, e = void 0), e = e || "") : (n = e = t, t = !1, h(e) && (n = e, e = void 0), e = e || "");
                        var i, o = Ee(),
                            c = t ? o._week.dow : 0;
                        if (null != n) return Nn(e, (n + c) % 7, r, "day");
                        var l = [];
                        for (i = 0; i < 7; i++) l[i] = Nn(e, (i + c) % 7, r, "day");
                        return l
                    }
                    Fn.calendar = function (t, e, n) {
                        var output = this._calendar[t] || this._calendar.sameElse;
                        return N(output) ? output.call(e, n) : output
                    }, Fn.longDateFormat = function (t) {
                        var e = this._longDateFormat[t],
                            n = this._longDateFormat[t.toUpperCase()];
                        return e || !n ? e : (this._longDateFormat[t] = n.replace(/MMMM|MM|DD|dddd/g, (function (t) {
                            return t.slice(1)
                        })), this._longDateFormat[t])
                    }, Fn.invalidDate = function () {
                        return this._invalidDate
                    }, Fn.ordinal = function (t) {
                        return this._ordinal.replace("%d", t)
                    }, Fn.preparse = On, Fn.postformat = On, Fn.relativeTime = function (t, e, n, r) {
                        var output = this._relativeTime[n];
                        return N(output) ? output(t, e, n, r) : output.replace(/%d/i, t)
                    }, Fn.pastFuture = function (t, output) {
                        var e = this._relativeTime[t > 0 ? "future" : "past"];
                        return N(e) ? e(output) : e.replace(/%s/i, output)
                    }, Fn.set = function (t) {
                        var e, i;
                        for (i in t) N(e = t[i]) ? this[i] = e : this["_" + i] = e;
                        this._config = t, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source)
                    }, Fn.months = function (t, e) {
                        return t ? o(this._months) ? this._months[t.month()] : this._months[(this._months.isFormat || Gt).test(e) ? "format" : "standalone"][t.month()] : o(this._months) ? this._months : this._months.standalone
                    }, Fn.monthsShort = function (t, e) {
                        return t ? o(this._monthsShort) ? this._monthsShort[t.month()] : this._monthsShort[Gt.test(e) ? "format" : "standalone"][t.month()] : o(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone
                    }, Fn.monthsParse = function (t, e, n) {
                        var i, r, o;
                        if (this._monthsParseExact) return Wt.call(this, t, e, n);
                        for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), i = 0; i < 12; i++) {
                            if (r = v([2e3, i]), n && !this._longMonthsParse[i] && (this._longMonthsParse[i] = new RegExp("^" + this.months(r, "").replace(".", "") + "$", "i"), this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(r, "").replace(".", "") + "$", "i")), n || this._monthsParse[i] || (o = "^" + this.months(r, "") + "|^" + this.monthsShort(r, ""), this._monthsParse[i] = new RegExp(o.replace(".", ""), "i")), n && "MMMM" === e && this._longMonthsParse[i].test(t)) return i;
                            if (n && "MMM" === e && this._shortMonthsParse[i].test(t)) return i;
                            if (!n && this._monthsParse[i].test(t)) return i
                        }
                    }, Fn.monthsRegex = function (t) {
                        return this._monthsParseExact ? (f(this, "_monthsRegex") || Jt.call(this), t ? this._monthsStrictRegex : this._monthsRegex) : (f(this, "_monthsRegex") || (this._monthsRegex = Zt), this._monthsStrictRegex && t ? this._monthsStrictRegex : this._monthsRegex)
                    }, Fn.monthsShortRegex = function (t) {
                        return this._monthsParseExact ? (f(this, "_monthsRegex") || Jt.call(this), t ? this._monthsShortStrictRegex : this._monthsShortRegex) : (f(this, "_monthsShortRegex") || (this._monthsShortRegex = Xt), this._monthsShortStrictRegex && t ? this._monthsShortStrictRegex : this._monthsShortRegex)
                    }, Fn.week = function (t) {
                        return ee(t, this._week.dow, this._week.doy).week
                    }, Fn.firstDayOfYear = function () {
                        return this._week.doy
                    }, Fn.firstDayOfWeek = function () {
                        return this._week.dow
                    }, Fn.weekdays = function (t, e) {
                        var n = o(this._weekdays) ? this._weekdays : this._weekdays[t && !0 !== t && this._weekdays.isFormat.test(e) ? "format" : "standalone"];
                        return !0 === t ? ie(n, this._week.dow) : t ? n[t.day()] : n
                    }, Fn.weekdaysMin = function (t) {
                        return !0 === t ? ie(this._weekdaysMin, this._week.dow) : t ? this._weekdaysMin[t.day()] : this._weekdaysMin
                    }, Fn.weekdaysShort = function (t) {
                        return !0 === t ? ie(this._weekdaysShort, this._week.dow) : t ? this._weekdaysShort[t.day()] : this._weekdaysShort
                    }, Fn.weekdaysParse = function (t, e, n) {
                        var i, r, o;
                        if (this._weekdaysParseExact) return se.call(this, t, e, n);
                        for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), i = 0; i < 7; i++) {
                            if (r = v([2e3, 1]).day(i), n && !this._fullWeekdaysParse[i] && (this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(r, "").replace(".", "\\.?") + "$", "i"), this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(r, "").replace(".", "\\.?") + "$", "i"), this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(r, "").replace(".", "\\.?") + "$", "i")), this._weekdaysParse[i] || (o = "^" + this.weekdays(r, "") + "|^" + this.weekdaysShort(r, "") + "|^" + this.weekdaysMin(r, ""), this._weekdaysParse[i] = new RegExp(o.replace(".", ""), "i")), n && "dddd" === e && this._fullWeekdaysParse[i].test(t)) return i;
                            if (n && "ddd" === e && this._shortWeekdaysParse[i].test(t)) return i;
                            if (n && "dd" === e && this._minWeekdaysParse[i].test(t)) return i;
                            if (!n && this._weekdaysParse[i].test(t)) return i
                        }
                    }, Fn.weekdaysRegex = function (t) {
                        return this._weekdaysParseExact ? (f(this, "_weekdaysRegex") || he.call(this), t ? this._weekdaysStrictRegex : this._weekdaysRegex) : (f(this, "_weekdaysRegex") || (this._weekdaysRegex = ue), this._weekdaysStrictRegex && t ? this._weekdaysStrictRegex : this._weekdaysRegex)
                    }, Fn.weekdaysShortRegex = function (t) {
                        return this._weekdaysParseExact ? (f(this, "_weekdaysRegex") || he.call(this), t ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (f(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = ce), this._weekdaysShortStrictRegex && t ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex)
                    }, Fn.weekdaysMinRegex = function (t) {
                        return this._weekdaysParseExact ? (f(this, "_weekdaysRegex") || he.call(this), t ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (f(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = le), this._weekdaysMinStrictRegex && t ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex)
                    }, Fn.isPM = function (input) {
                        return "p" === (input + "").toLowerCase().charAt(0)
                    }, Fn.meridiem = function (t, e, n) {
                        return t > 11 ? n ? "pm" : "PM" : n ? "am" : "AM"
                    }, we("en", {
                        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
                        ordinal: function (t) {
                            var b = t % 10;
                            return t + (1 === A(t % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th")
                        }
                    }), r.lang = R("moment.lang is deprecated. Use moment.locale instead.", we), r.langData = R("moment.langData is deprecated. Use moment.localeData instead.", Ee);
                    var kn = Math.abs;

                    function zn(t, input, e, n) {
                        var r = an(input, e);
                        return t._milliseconds += n * r._milliseconds, t._days += n * r._days, t._months += n * r._months, t._bubble()
                    }

                    function Un(t) {
                        return t < 0 ? Math.floor(t) : Math.ceil(t)
                    }

                    function Hn(t) {
                        return 4800 * t / 146097
                    }

                    function Gn(t) {
                        return 146097 * t / 4800
                    }

                    function Vn(t) {
                        return function () {
                            return this.as(t)
                        }
                    }
                    var jn = Vn("ms"),
                        Wn = Vn("s"),
                        Yn = Vn("m"),
                        qn = Vn("h"),
                        Xn = Vn("d"),
                        Zn = Vn("w"),
                        Jn = Vn("M"),
                        $n = Vn("Q"),
                        Qn = Vn("y");

                    function Kn(t) {
                        return function () {
                            return this.isValid() ? this._data[t] : NaN
                        }
                    }
                    var ti = Kn("milliseconds"),
                        ei = Kn("seconds"),
                        ni = Kn("minutes"),
                        ii = Kn("hours"),
                        ri = Kn("days"),
                        ai = Kn("months"),
                        oi = Kn("years"),
                        si = Math.round,
                        ui = {
                            ss: 44,
                            s: 45,
                            m: 45,
                            h: 22,
                            d: 26,
                            M: 11
                        };

                    function ci(t, e, n, r, o) {
                        return o.relativeTime(e || 1, !!n, t, r)
                    }
                    var hi = Math.abs;

                    function di(t) {
                        return (t > 0) - (t < 0) || +t
                    }

                    function pi() {
                        if (!this.isValid()) return this.localeData().invalidDate();
                        var t, e, n = hi(this._milliseconds) / 1e3,
                            r = hi(this._days),
                            o = hi(this._months);
                        t = S(n / 60), e = S(t / 60), n %= 60, t %= 60;
                        var c = S(o / 12),
                            l = o %= 12,
                            h = r,
                            d = e,
                            f = t,
                            s = n ? n.toFixed(3).replace(/\.?0+$/, "") : "",
                            m = this.asSeconds();
                        if (!m) return "P0D";
                        var v = m < 0 ? "-" : "",
                            y = di(this._months) !== di(m) ? "-" : "",
                            _ = di(this._days) !== di(m) ? "-" : "",
                            x = di(this._milliseconds) !== di(m) ? "-" : "";
                        return v + "P" + (c ? y + c + "Y" : "") + (l ? y + l + "M" : "") + (h ? _ + h + "D" : "") + (d || f || s ? "T" : "") + (d ? x + d + "H" : "") + (f ? x + f + "M" : "") + (s ? x + s + "S" : "")
                    }
                    var fi = qe.prototype;
                    return fi.isValid = function () {
                        return this._isValid
                    }, fi.abs = function () {
                        var data = this._data;
                        return this._milliseconds = kn(this._milliseconds), this._days = kn(this._days), this._months = kn(this._months), data.milliseconds = kn(data.milliseconds), data.seconds = kn(data.seconds), data.minutes = kn(data.minutes), data.hours = kn(data.hours), data.months = kn(data.months), data.years = kn(data.years), this
                    }, fi.add = function (input, t) {
                        return zn(this, input, t, 1)
                    }, fi.subtract = function (input, t) {
                        return zn(this, input, t, -1)
                    }, fi.as = function (t) {
                        if (!this.isValid()) return NaN;
                        var e, n, r = this._milliseconds;
                        if ("month" === (t = U(t)) || "quarter" === t || "year" === t) switch (e = this._days + r / 864e5, n = this._months + Hn(e), t) {
                            case "month":
                                return n;
                            case "quarter":
                                return n / 3;
                            case "year":
                                return n / 12
                        } else switch (e = this._days + Math.round(Gn(this._months)), t) {
                            case "week":
                                return e / 7 + r / 6048e5;
                            case "day":
                                return e + r / 864e5;
                            case "hour":
                                return 24 * e + r / 36e5;
                            case "minute":
                                return 1440 * e + r / 6e4;
                            case "second":
                                return 86400 * e + r / 1e3;
                            case "millisecond":
                                return Math.floor(864e5 * e) + r;
                            default:
                                throw new Error("Unknown unit " + t)
                        }
                    }, fi.asMilliseconds = jn, fi.asSeconds = Wn, fi.asMinutes = Yn, fi.asHours = qn, fi.asDays = Xn, fi.asWeeks = Zn, fi.asMonths = Jn, fi.asQuarters = $n, fi.asYears = Qn, fi.valueOf = function () {
                        return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * A(this._months / 12) : NaN
                    }, fi._bubble = function () {
                        var t, e, n, r, o, c = this._milliseconds,
                            l = this._days,
                            h = this._months,
                            data = this._data;
                        return c >= 0 && l >= 0 && h >= 0 || c <= 0 && l <= 0 && h <= 0 || (c += 864e5 * Un(Gn(h) + l), l = 0, h = 0), data.milliseconds = c % 1e3, t = S(c / 1e3), data.seconds = t % 60, e = S(t / 60), data.minutes = e % 60, n = S(e / 60), data.hours = n % 24, l += S(n / 24), o = S(Hn(l)), h += o, l -= Un(Gn(o)), r = S(h / 12), h %= 12, data.days = l, data.months = h, data.years = r, this
                    }, fi.clone = function () {
                        return an(this)
                    }, fi.get = function (t) {
                        return t = U(t), this.isValid() ? this[t + "s"]() : NaN
                    }, fi.milliseconds = ti, fi.seconds = ei, fi.minutes = ni, fi.hours = ii, fi.days = ri, fi.weeks = function () {
                        return S(this.days() / 7)
                    }, fi.months = ai, fi.years = oi, fi.humanize = function (t) {
                        if (!this.isValid()) return this.localeData().invalidDate();
                        var e = this.localeData(),
                            output = function (t, e, n) {
                                var r = an(t).abs(),
                                    o = si(r.as("s")),
                                    c = si(r.as("m")),
                                    l = si(r.as("h")),
                                    h = si(r.as("d")),
                                    d = si(r.as("M")),
                                    f = si(r.as("y")),
                                    a = o <= ui.ss && ["s", o] || o < ui.s && ["ss", o] || c <= 1 && ["m"] || c < ui.m && ["mm", c] || l <= 1 && ["h"] || l < ui.h && ["hh", l] || h <= 1 && ["d"] || h < ui.d && ["dd", h] || d <= 1 && ["M"] || d < ui.M && ["MM", d] || f <= 1 && ["y"] || ["yy", f];
                                return a[2] = e, a[3] = +t > 0, a[4] = n, ci.apply(null, a)
                            }(this, !t, e);
                        return t && (output = e.pastFuture(+this, output)), e.postformat(output)
                    }, fi.toISOString = pi, fi.toString = pi, fi.toJSON = pi, fi.locale = pn, fi.localeData = mn, fi.toIsoString = R("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", pi), fi.lang = fn, J("X", 0, 0, "unix"), J("x", 0, 0, "valueOf"), yt("x", pt), yt("X", /[+-]?\d+(\.\d{1,3})?/), wt("X", (function (input, t, e) {
                        e._d = new Date(1e3 * parseFloat(input, 10))
                    })), wt("x", (function (input, t, e) {
                        e._d = new Date(A(input))
                    })), r.version = "2.24.0", e = Ge, r.fn = Pn, r.min = function () {
                        return We("isBefore", [].slice.call(arguments, 0))
                    }, r.max = function () {
                        return We("isAfter", [].slice.call(arguments, 0))
                    }, r.now = function () {
                        return Date.now ? Date.now() : +new Date
                    }, r.utc = v, r.unix = function (input) {
                        return Ge(1e3 * input)
                    }, r.months = function (t, e) {
                        return In(t, e, "months")
                    }, r.isDate = d, r.locale = we, r.invalid = x, r.duration = an, r.isMoment = D, r.weekdays = function (t, e, n) {
                        return Bn(t, e, n, "weekdays")
                    }, r.parseZone = function () {
                        return Ge.apply(null, arguments).parseZone()
                    }, r.localeData = Ee, r.isDuration = Xe, r.monthsShort = function (t, e) {
                        return In(t, e, "monthsShort")
                    }, r.weekdaysMin = function (t, e, n) {
                        return Bn(t, e, n, "weekdaysMin")
                    }, r.defineLocale = Me, r.updateLocale = function (t, e) {
                        if (null != e) {
                            var n, r, o = ve;
                            null != (r = be(t)) && (o = r._config), e = I(o, e), (n = new B(e)).parentLocale = ye[t], ye[t] = n, we(t)
                        } else null != ye[t] && (null != ye[t].parentLocale ? ye[t] = ye[t].parentLocale : null != ye[t] && delete ye[t]);
                        return ye[t]
                    }, r.locales = function () {
                        return P(ye)
                    }, r.weekdaysShort = function (t, e, n) {
                        return Bn(t, e, n, "weekdaysShort")
                    }, r.normalizeUnits = U, r.relativeTimeRounding = function (t) {
                        return void 0 === t ? si : "function" == typeof t && (si = t, !0)
                    }, r.relativeTimeThreshold = function (t, e) {
                        return void 0 !== ui[t] && (void 0 === e ? ui[t] : (ui[t] = e, "s" === t && (ui.ss = e - 1), !0))
                    }, r.calendarFormat = function (t, e) {
                        var n = t.diff(e, "days", !0);
                        return n < -6 ? "sameElse" : n < -1 ? "lastWeek" : n < 0 ? "lastDay" : n < 1 ? "sameDay" : n < 2 ? "nextDay" : n < 7 ? "nextWeek" : "sameElse"
                    }, r.prototype = Pn, r.HTML5_FMT = {
                        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
                        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
                        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
                        DATE: "YYYY-MM-DD",
                        TIME: "HH:mm",
                        TIME_SECONDS: "HH:mm:ss",
                        TIME_MS: "HH:mm:ss.SSS",
                        WEEK: "GGGG-[W]WW",
                        MONTH: "YYYY-MM"
                    }, r
                }()
            }).call(this, n(266)(t))
        }
    }
]);
